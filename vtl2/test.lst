 AS V1.42 Beta [Bld 114] - source file test.asm - page 1 - 14/1/2017 13:53:10


       1/       0 :                     
       2/       0 :                     	cpu 	1802
       3/       0 :                     	
       4/       0 :                     return macro
       5/       0 :                     	dis
       6/       0 :                     	endm
       7/       0 :                     
       8/       0 : =0H                 r0 = 0 															; not used (may be used in interrupt display)
       9/       0 : =1H                 r1 = 1 															; interrupt register
      10/       0 : =2H                 r2 = 2 															; stack pointer
      11/       0 : =3H                 r3 = 3 															; general run P
      12/       0 :                     
      13/       0 : =6H                 rVarPtr = 6 													; always points to variables (64 variables 2 bytes each 6 bit ASCII)
      14/       0 : =7H                 rExprPC = 7 													; used as P register in expression (mandated)
      15/       0 : =8H                 rSrc = 8 														; source code.
      16/       0 : =9H                 rSpecialHandler = 9 											; special variables handler.
      17/       0 : =AH                 rParenthesisLevel = 10 											; bracket level (low byte)
      18/       0 : =BH                 rSaveStack = 11 												; original value of stack pointer
      19/       0 :                     
      20/       0 : =CH                 rUtilPC = 12 													; used as P register calling routines (not mandated)
      21/       0 : =DH                 rSubPC = 13														; used as P register to call routines within routines
      22/       0 : =EH                 rParam1 = 14 													; subroutine parameters/return values.
      23/       0 : =FH                 rParam2 = 15
      24/       0 :                     
      25/       0 :                     
      26/       0 :                     ldr macro 	r,n
      27/       0 :                     	ldi 	(n)/256
      28/       0 :                     	phi 	r
      29/       0 :                     	ldi 	(n)&255
      30/       0 :                     	plo 	r
      31/       0 :                     	endm
      32/       0 :                     
      33/       0 :                     
      34/       0 : 71                  	dis 														; preamble.
      35/       1 : 00                  	db 		0
      36/       2 : F8 03               	ldi 	start/256
      37/       4 : B3                  	phi 	r3
      38/       5 : F8 00               	ldi 	start&255
      39/       7 : A3                  	plo 	r3
      40/       8 : D3                  	sep 	r3
      41/       9 :                     
      42/       9 :                     	include 	expression.asm 									; expression evaluator, arithmetic, atoi/itoa (2 pages)
(1)    1/       9 :                     ; ***************************************************************************************************************
(1)    2/       9 :                     ; ***************************************************************************************************************
(1)    3/       9 :                     ;
(1)    4/       9 :                     ;		File:		expression.asm
(1)    5/       9 :                     ;		Purpose:	Evaluate an ASCII expression.
(1)    6/       9 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/       9 :                     ;		Date:		11th January 2017.
(1)    8/       9 :                     ;
(1)    9/       9 :                     ; ***************************************************************************************************************
(1)   10/       9 :                     ; ***************************************************************************************************************
(1)   11/       9 :                     
(1)   12/       9 :                     ; ***************************************************************************************************************
(1)   13/       9 :                     ;
(1)   14/       9 :                     ;	Expression Evaluator : L -> R evaluation with parenthesis.
(1)   15/       9 :                     ;
(1)   16/       9 :                     ;	rSrc 			points to ASCIIZ expression, next character on exit. 
(1)   17/       9 :                     ;	rExprPC 		runs in this R(P), this is mandatory.
(1)   18/       9 :                     ;	rVarPtr.1 		points to variables
 AS V1.42 Beta [Bld 114] - source file test.asm(expression.asm) - page 2 - 14/1/2017 13:53:10


(1)   19/       9 :                     ; 	rParam1 		returned value of expression.
(1)   20/       9 :                     ;	rSpecialHandler	Routine (ends with sep rExprPC) which processes the provided character for special values
(1)   21/       9 :                     ;					e.g. side effect variables like ?. Char in D, zeroes D if the character is found and processed,
(1)   22/       9 :                     ;					in which case the result should be in rParam2
(1)   23/       9 :                     ;
(1)   24/       9 :                     ;	This does not report errors. VTL-2 does not. So if you have an error then the result returned may be somewhat
(1)   25/       9 :                     ;	unexpected and should not be relied on, despite what the VTL-2 manual hints :)
(1)   26/       9 :                     ;
(1)   27/       9 :                     ;	Note this routine breaks most of the registers R6-R15. If this is called recursively it must still run in
(1)   28/       9 :                     ;	rExprPC and the original rExprPC,rSrc,rParenthesisLevel and rSaveStack must be saved. rVarPtr does not change
(1)   29/       9 :                     ;	but must be restored if changed by an external routine.
(1)   30/       9 :                     ;
(1)   31/       9 :                     ;	The routine is designed to occupy two complete pages. At present there are about 16 bytes free at the end of
(1)   32/       9 :                     ;	each page allowing for bug fixing, if the first page is preceded by the preamble (dis ; loading r3 ; sep r3)
(1)   33/       9 :                     ;
(1)   34/       9 :                     ; ***************************************************************************************************************
(1)   35/       9 :                     
(1)   36/       9 :                     __EXPRExitDec:
(1)   37/       9 : 28                  	dec 	rSrc 														; unpick bad source gets
(1)   38/       A :                     __EXPRExit:
(1)   39/       A : 8B                  	glo 	rSaveStack 													; because we don't handle errors properly we 
(1)   40/       B : A2                  	plo 	r2 															; may have incomplete operations on exit.
(1)   41/       C : 9B                  	ghi 	rSaveStack 													; (VTL-2 does not report expression syntax errors)
(1)   42/       D : B2                  	phi 	r2
(1)   43/       E : 22                  	dec 	r2 															; load top most expression which is the answer
(1)   44/       F : 42                  	lda 	r2 															; if it actually worked.
(1)   45/      10 : AE                  	plo 	rParam1
(1)   46/      11 : 42                  	lda 	r2
(1)   47/      12 : BE                  	phi 	rParam1
(1)   48/      13 : (MACRO)             	return
(1)   48/      13 : 71                          dis
(1)   49/      14 :                     
(1)   50/      14 :                     EXPREvaluate:
(1)   51/      14 : E2                  	sex 	r2 															; using X = 2 again
(1)   52/      15 : F8 00               	ldi 	0 															; clear parenthesis level to 0.
(1)   53/      17 : AA                  	plo 	rParenthesisLevel 
(1)   54/      18 :                     
(1)   55/      18 : 82                  	glo	 	r2 															; save original stack position
(1)   56/      19 : AB                  	plo 	rSaveStack
(1)   57/      1A : 92                  	ghi 	r2
(1)   58/      1B : BB                  	phi 	rSaveStack 
(1)   59/      1C :                     
(1)   60/      1C :                     __EXPRNewLevel:	
(1)   61/      1C : F8 00               	ldi 	0 															; push $0000  + on the stack.
(1)   62/      1E : 73                  	stxd 																; MSB first
(1)   63/      1F : 73                  	stxd 																; LSB
(1)   64/      20 : F8 2B               	ldi 	'+' 												 		; the put '+' on the stack as pending operation.
(1)   65/      22 : 73                  	stxd
(1)   66/      23 : 1A                  	inc 	rParenthesisLevel 											; bump the parenthesis level up 1.
(1)   67/      24 :                     ;
(1)   68/      24 :                     ;		On reaching this point, we are looking for a new Term.
(1)   69/      24 :                     ;
(1)   70/      24 :                     __EXPRNewTerm:
(1)   71/      24 : 88                  	glo 	rSrc 														; put rSrc into rParam1
(1)   72/      25 : AE                  	plo 	rParam1
(1)   73/      26 : 98                  	ghi 	rSrc
(1)   74/      27 : BE                  	phi 	rParam1
(1)   75/      28 :                     
(1)   76/      28 : F8 01               	ldi 	ASCIIToInteger/256  										; call the atoi() routine.
(1)   77/      2A : BC                  	phi 	rUtilPC 
 AS V1.42 Beta [Bld 114] - source file test.asm(expression.asm) - page 3 - 14/1/2017 13:53:10


(1)   78/      2B : F8 B0               	ldi 	ASCIIToInteger & 255 										
(1)   79/      2D : AC                  	plo 	rUtilPC
(1)   80/      2E : 79                  	mark
(1)   81/      2F : DC                  	sep 	rUtilPC
(1)   82/      30 : 22                  	dec 	r2 		
(1)   83/      31 :                     
(1)   84/      31 : FC FF               	adi 	0FFh 														; sets DF if non zero value returned
(1)   85/      33 : 8E                  	glo 	rParam1 													; constant rParam1 back into rSrc
(1)   86/      34 : A8                  	plo 	rSrc
(1)   87/      35 : 9E                  	ghi 	rParam1
(1)   88/      36 : B8                  	phi 	rSrc
(1)   89/      37 : 33 67               	bdf 	__EXPRGotTerm 												; if constant then done.
(1)   90/      39 :                     
(1)   91/      39 : 48                  	lda 	rSrc 														; look at character.
(1)   92/      3A : 32 09               	bz 		__EXPRExitDec 												; none provided.
(1)   93/      3C : FB 22               	xri 	'"'															; is it quote mark
(1)   94/      3E : 32 5F               	bz 		__EXPRGotCharacter 											; if so do that handler.
(1)   95/      40 : FB 0A               	xri	 	'('!'"' 													; is it open parenthesis.
(1)   96/      42 : 32 1C               	bz		__EXPRNewLevel 												; if so open new level.
(1)   97/      44 : FB 12               	xri 	':'!'('														; is it new array ?
(1)   98/      46 : 32 57               	bz 		__EXPRArray
(1)   99/      48 : FB 3A               	xri 	':' 														; so make it back to the correct character.
(1)  100/      4A : D9                  	sep 	rSpecialHandler 											; check for 'special ones'
(1)  101/      4B : 32 67               	bz 		__EXPRGotTerm 												; if found one, we've got a term.
(1)  102/      4D :                     
(1)  103/      4D : FA 3F               	ani 	03Fh 														; convert to six bit ASCII.
(1)  104/      4F : FE                  	shl 																; byte size to word size
(1)  105/      50 : A6                  	plo 	rVarPtr 													; now point to variable
(1)  106/      51 : 46                  	lda 	rVarPtr 													; read LSB into Param2
(1)  107/      52 : AF                  	plo 	rParam2
(1)  108/      53 : 06                  	ldn 	rVarPtr 													; and MSB
(1)  109/      54 : BF                  	phi 	rParam2
(1)  110/      55 : 30 67               	br 		__EXPRGotTerm 
(1)  111/      57 :                     ;
(1)  112/      57 :                     ;	Found an array : - same as open parenthesis except we stack a '@'
(1)  113/      57 :                     ;	
(1)  114/      57 :                     __EXPRArray:
(1)  115/      57 : F8 40               	ldi 	'@' 														; push @@@ on the stack,  the first two don't matter.
(1)  116/      59 : 73                  	stxd
(1)  117/      5A : 73                  	stxd
(1)  118/      5B : 73                  	stxd
(1)  119/      5C : 1A                  	inc 	rParenthesisLevel 											; it's like bracket with a different operator.
(1)  120/      5D : 30 24               	br 		__EXPRNewTerm
(1)  121/      5F :                     ;
(1)  122/      5F :                     ;	Found a "<char>" 
(1)  123/      5F :                     ;
(1)  124/      5F :                     __EXPRGotCharacter:
(1)  125/      5F : BF                  	phi 	rParam2 													; clear high byte of rParam2.
(1)  126/      60 : 48                  	lda 	rSrc 														; get character in quotes, skip over it
(1)  127/      61 : 32 09               	bz 		__EXPRExitDec 												; none provided, exit backing up.
(1)  128/      63 : AF                  	plo 	rParam2 													; put in rParam2.0
(1)  129/      64 : 48                  	lda 	rSrc 														; look for what should be a quote but we dont check
(1)  130/      65 : 32 09               	bz 		__EXPRExitDec
(1)  131/      67 :                     ;
(1)  132/      67 :                     ;	New term is in rParam2. Look at the TOS expression to do, look it up and do it.
(1)  133/      67 :                     ;
(1)  134/      67 :                     __EXPRGotTerm:  														; new term is in rParam2.
(1)  135/      67 : 12                  	inc 	r2 															; point stack to operator.
(1)  136/      68 : F8 00               	ldi 	(__OperatorTable-2)/256 									; rParam1 is the operator look up table.
(1)  137/      6A : BE                  	phi 	rParam1
 AS V1.42 Beta [Bld 114] - source file test.asm(expression.asm) - page 4 - 14/1/2017 13:53:10


(1)  138/      6B : F8 AD               	ldi 	(__OperatorTable-2)&255
(1)  139/      6D : AE                  	plo 	rParam1
(1)  140/      6E :                     __EXPRFindOperation:
(1)  141/      6E : 1E                  	inc 	rParam1
(1)  142/      6F : 1E                  	inc 	rParam1
(1)  143/      70 : 4E                  	lda 	rParam1 													; look to see what it is.
(1)  144/      71 : 32 76               	bz 		__EXPRFoundOperation 										; end of table.
(1)  145/      73 : F3                  	xor 																; same as stacked operator
(1)  146/      74 : 3A 6E               	bnz 	__EXPRFindOperation 
(1)  147/      76 :                     __EXPRFoundOperation:	
(1)  148/      76 : 42                  	lda 	r2 															; load the stacked value into rParenthesisLevel.1
(1)  149/      77 : BA                  	phi 	rParenthesisLevel
(1)  150/      78 : 4E                  	lda 	rParam1 													; put address of routine into rUtilPC
(1)  151/      79 : AC                  	plo 	rUtilPC
(1)  152/      7A : 0E                  	ldn 	rParam1
(1)  153/      7B : BC                  	phi 	rUtilPC
(1)  154/      7C :                     
(1)  155/      7C : 42                  	lda 	r2 															; read TOS for into param1
(1)  156/      7D : AE                  	plo 	rParam1
(1)  157/      7E : 02                  	ldn 	r2
(1)  158/      7F : BE                  	phi 	rParam1
(1)  159/      80 : 79                  	mark  																; and call the routine.
(1)  160/      81 : DC                  	sep 	rUtilPC
(1)  161/      82 : 22                  	dec 	r2
(1)  162/      83 :                     
(1)  163/      83 :                     ;
(1)  164/      83 :                     ;	Having got the result, check to see if it was divide, if so write out the remainder to '%'
(1)  165/      83 :                     ;
(1)  166/      83 : 9A                  	ghi 	rParenthesisLevel 											; get the operator
(1)  167/      84 : FB 2F               	xri 	'/'															; was it divide ?
(1)  168/      86 : 3A 90               	bnz 	__EXPRNotDivide
(1)  169/      88 : F8 4A               	ldi 	('%' & 03Fh) * 2 											; point rVarPtr to % variable
(1)  170/      8A : A6                  	plo 	rVarPtr
(1)  171/      8B : 8F                  	glo 	rParam2 													; save remainder there
(1)  172/      8C : 56                  	str 	rVarPtr
(1)  173/      8D : 9F                  	ghi 	rParam2
(1)  174/      8E : 16                  	inc 	rVarPtr
(1)  175/      8F : 56                  	str 	rVarPtr
(1)  176/      90 :                     __EXPRNotDivide:	
(1)  177/      90 :                     
(1)  178/      90 : 9E                  	ghi 	rParam1 													; push the result back on the stack.
(1)  179/      91 : 73                  	stxd
(1)  180/      92 : 8E                  	glo 	rParam1
(1)  181/      93 : 73                  	stxd
(1)  182/      94 :                     ;
(1)  183/      94 :                     ;	Get the next operation, this is normally stacked, except if ) in which case the bracketed operation is closed
(1)  184/      94 :                     ;
(1)  185/      94 :                     __EXPRSkipSpace:
(1)  186/      94 : 48                  	lda 	rSrc 														; get the next operator.
(1)  187/      95 : 32 09               	bz 		__EXPRExitDec 												; done the next operator.
(1)  188/      97 : FB 20               	xri 	' '
(1)  189/      99 : 32 94               	bz 		__EXPRSkipSpace
(1)  190/      9B : FB 09               	xri 	')'!' '														; was it )
(1)  191/      9D : 32 A4               	bz 		__EXPRDestackBracket
(1)  192/      9F : FB 29               	xri 	')' 														; get it back
(1)  193/      A1 : 73                  	stxd 																; push it on the stack.
(1)  194/      A2 : 30 24               	br 		__EXPRNewTerm 												; and get the next term.
(1)  195/      A4 :                     ;
(1)  196/      A4 :                     ; 	Close the bracketed operation
(1)  197/      A4 :                     ;
 AS V1.42 Beta [Bld 114] - source file test.asm(expression.asm) - page 5 - 14/1/2017 13:53:10


(1)  198/      A4 :                     __EXPRDestackBracket:
(1)  199/      A4 : 2A                  	dec 	rParenthesisLevel 											; dec brackets
(1)  200/      A5 : 8A                  	glo 	rParenthesisLevel 											; if zero it is end of expression ) so exit.	
(1)  201/      A6 : 32 0A               	bz 		__EXPRExit
(1)  202/      A8 :                     
(1)  203/      A8 : 12                  	inc 	r2 															; pop rParam2 off the stack.
(1)  204/      A9 : 42                  	lda 	r2
(1)  205/      AA : AF                  	plo 	rParam2
(1)  206/      AB : 02                  	ldn 	r2
(1)  207/      AC : BF                  	phi 	rParam2
(1)  208/      AD :                     
(1)  209/      AD : 30 67               	br 		__EXPRGotTerm 												; go back and do the stacked operation below
(1)  210/      AF :                     
(1)  211/      AF :                     ; ***************************************************************************************************************
(1)  212/      AF :                     ;
(1)  213/      AF :                     ;	Look up table for binary operators. 0 signifies the end of the table and default, so it covers - > < =
(1)  214/      AF :                     ;
(1)  215/      AF :                     ; ***************************************************************************************************************
(1)  216/      AF :                     
(1)  217/      AF :                     oper macro chdb,addr
(1)  218/      AF :                     	db 		chdb,addr & 255,addr / 256
(1)  219/      AF :                     	endm 
(1)  220/      AF :                     
(1)  221/      AF :                     __OperatorTable:
(1)  222/      AF : (MACRO)             	oper 		'+',__OpAdd 
(1)  222/      AF : 2B 00 01                    db              '+',__OPADD & 255,__OPADD / 256
(1)  223/      B2 : (MACRO)             	oper		'*',Multiply
(1)  223/      B2 : 2A 8B 01                    db              '*',MULTIPLY & 255,MULTIPLY / 256
(1)  224/      B5 : (MACRO)             	oper 		'/',Divide
(1)  224/      B5 : 2F C0 00                    db              '/',DIVIDE & 255,DIVIDE / 256
(1)  225/      B8 : (MACRO)             	oper 		'@',__OpLookUp 
(1)  225/      B8 : 40 0D 01                    db              '@',__OPLOOKUP & 255,__OPLOOKUP / 256
(1)  226/      BB : (MACRO)             	oper 		0,__OpSub
(1)  226/      BB : 00 26 01                    db              0,__OPSUB & 255,__OPSUB / 256
(1)  227/      BE :                     
(1)  228/      BE :                     ; ***************************************************************************************************************
(1)  229/      BE :                     ;
(1)  230/      BE :                     ;										Divide Code here
(1)  231/      BE :                     ;
(1)  232/      BE :                     ; ***************************************************************************************************************
(1)  233/      BE :                     
(1)  234/      BE :                     	include 	utility/divide.asm
(2)    1/      BE :                     ; ***************************************************************************************************************
(2)    2/      BE :                     ; ***************************************************************************************************************
(2)    3/      BE :                     ;
(2)    4/      BE :                     ;		File:		divide.asm
(2)    5/      BE :                     ;		Purpose:	Divide two 16 bit integers.
(2)    6/      BE :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(2)    7/      BE :                     ;		Date:		9th January 2017.
(2)    8/      BE :                     ;		Size: 		54 bytes.
(2)    9/      BE :                     ;
(2)   10/      BE :                     ; ***************************************************************************************************************
(2)   11/      BE :                     ; ***************************************************************************************************************
(2)   12/      BE :                     
(2)   13/      BE :                     ; *******************************************************************************************************************
(2)   14/      BE :                     ;
(2)   15/      BE :                     ;				Calculate rParam1 / rParam2.  Result in rParam1. Remainder in rParam2.
(2)   16/      BE :                     ;
(2)   17/      BE :                     ; *******************************************************************************************************************
(2)   18/      BE :                     
 AS V1.42 Beta [Bld 114] - source file test.asm(divide.asm) - page 6 - 14/1/2017 13:53:10


(2)   19/      BE :                     __DIVExit:
(2)   20/      BE : 12                  	inc 	r2 															; point to XP on the stack
(2)   21/      BF : (MACRO)             	return
(2)   21/      BF : 71                          dis
(2)   22/      C0 :                     
(2)   23/      C0 :                     Divide:
(2)   24/      C0 : E2                  	sex 	r2 															; back using R2 as the index register
(2)   25/      C1 :                     																		; rParam1 is the dividend.
(2)   26/      C1 :                     																		; rParam2 is the remainder.
(2)   27/      C1 :                     																		; tos is [divisor:2][counter:1] 
(2)   28/      C1 :                     
(2)   29/      C1 : F8 10               	ldi 	16															; push counter on stack - 16 because post	
(2)   30/      C3 : 73                  	stxd 																; decrements in main loop.
(2)   31/      C4 :                     
(2)   32/      C4 : 9F                  	ghi 	rParam2 													; push divisor on stack.
(2)   33/      C5 : 73                  	stxd
(2)   34/      C6 : 8F                  	glo 	rParam2
(2)   35/      C7 : 52                  	str 	r2 	
(2)   36/      C8 :                     	
(2)   37/      C8 : F8 00               	ldi 	0 															; clear the remainder
(2)   38/      CA : BF                  	phi 	rParam2
(2)   39/      CB : AF                  	plo 	rParam2
(2)   40/      CC : F4                  	add 																; anything + 0 clears DF.
(2)   41/      CD :                     
(2)   42/      CD :                     __DIVLoopIncR2IncR2:
(2)   43/      CD : 12                  	inc		r2 															; point R2 back to the counter.
(2)   44/      CE :                     __DIVLoopIncR2:
(2)   45/      CE : 12                  	inc 	r2
(2)   46/      CF :                     
(2)   47/      CF :                     __DIVLoop:
(2)   48/      CF :                     
(2)   49/      CF : 8E                  	glo 	rParam1 													; shift DF into dividend, shift old bit 15 to DF
(2)   50/      D0 : 7E                  	rshl
(2)   51/      D1 : AE                  	plo 	rParam1
(2)   52/      D2 : 9E                  	ghi 	rParam1
(2)   53/      D3 : 7E                  	rshl
(2)   54/      D4 : BE                  	phi 	rParam1
(2)   55/      D5 :                     
(2)   56/      D5 : 02                  	ldn 	r2 															; look at counter.
(2)   57/      D6 : 32 BE               	bz 		__DIVExit 													; if zero then complete (decrement done later)
(2)   58/      D8 :                     
(2)   59/      D8 : 8F                  	glo	 	rParam2 													; shift DF into then remainder (rParam2)
(2)   60/      D9 : 7E                  	rshl
(2)   61/      DA : AF                  	plo 	rParam2
(2)   62/      DB : 9F                  	ghi 	rParam2
(2)   63/      DC : 7E                  	rshl
(2)   64/      DD : BF                  	phi 	rParam2
(2)   65/      DE :                     
(2)   66/      DE : 02                  	ldn 	r2 															; decrement the counter (AFTER the test)
(2)   67/      DF : FF 01               	smi 	1
(2)   68/      E1 : 73                  	stxd 																; when saving back, point R2 to divisor LSB.
(2)   69/      E2 : 22                  	dec 	r2
(2)   70/      E3 :                     
(2)   71/      E3 : 8F                  	glo 	rParam2 													; calculate remainder.0 - divisor.0
(2)   72/      E4 : F7                  	sm
(2)   73/      E5 : 22                  	dec 	r2 															; save the interim value below the LSB.
(2)   74/      E6 : 52                  	str 	r2
(2)   75/      E7 : 12                  	inc 	r2 															; to LSB
(2)   76/      E8 : 12                  	inc		r2 															; to MSB
(2)   77/      E9 : 9F                  	ghi 	rParam2 													; calculate remainder.1 - divisor.1
 AS V1.42 Beta [Bld 114] - source file test.asm(divide.asm) - page 7 - 14/1/2017 13:53:10


(2)   78/      EA : 77                  	smb
(2)   79/      EB :                     
(2)   80/      EB : 3B CE               	bnf 	__DIVLoopIncR2 												; if DF = 0 then inc r2 (to ctr) and loop back
(2)   81/      ED :                     
(2)   82/      ED : BF                  	phi 	rParam2 													; copy result to remainder
(2)   83/      EE : 22                  	dec 	r2 															; to divisor.0
(2)   84/      EF : 22                  	dec 	r2 															; to temp result
(2)   85/      F0 : 42                  	lda 	r2 															; get temp result, to divisor.0
(2)   86/      F1 : AF                  	plo 	rParam2
(2)   87/      F2 : 30 CD               	br 		__DIVLoopIncR2IncR2 										; go back, inc r2 twice to counter
(2)   88/      F4 :                     
(1)  235/      F4 :                     
(1)  236/      F4 :                     NewPage1: 															; switch to the next page.
(1)  237/     100 :                     	org 	(NewPage1+255)/256*256 
(1)  238/     100 :                     
(1)  239/     100 :                     ; ***************************************************************************************************************
(1)  240/     100 :                     ;
(1)  241/     100 :                     ;								Addition. rParam1 := rParam1 + rParam2
(1)  242/     100 :                     ;
(1)  243/     100 :                     ; ***************************************************************************************************************
(1)  244/     100 :                     
(1)  245/     100 :                     __OpAdd:
(1)  246/     100 : E2                  	sex		r2 														; rParam1 := rParam1 + rParam2
(1)  247/     101 : 8F                  	glo 	rParam2
(1)  248/     102 : 52                  	str 	r2
(1)  249/     103 : 8E                  	glo 	rParam1
(1)  250/     104 : F4                  	add	
(1)  251/     105 : AE                  	plo 	rParam1
(1)  252/     106 : 9F                  	ghi 	rParam2
(1)  253/     107 : 52                  	str 	r2
(1)  254/     108 : 9E                  	ghi 	rParam1
(1)  255/     109 : 74                  	adc
(1)  256/     10A : BE                  	phi 	rParam1
(1)  257/     10B : 12                  	inc 	r2
(1)  258/     10C : (MACRO)             	return
(1)  258/     10C : 71                          dis
(1)  259/     10D :                     
(1)  260/     10D :                     ; ***************************************************************************************************************
(1)  261/     10D :                     ;
(1)  262/     10D :                     ;				Array Lookup. rParam1 := Memory['&' + rParam * 2]. '*' is the top of memory variable.
(1)  263/     10D :                     ;
(1)  264/     10D :                     ; ***************************************************************************************************************
(1)  265/     10D :                     
(1)  266/     10D :                     __OpLookUp: 														; rParam1 := Memory[& + rParam2 * 2]
(1)  267/     10D : E2                  	sex 	r2
(1)  268/     10E : 8F                  	glo 	rParam2 												; double rParam2
(1)  269/     10F : FE                  	shl
(1)  270/     110 : AF                  	plo 	rParam2
(1)  271/     111 : 9F                  	ghi 	rParam2
(1)  272/     112 : 7E                  	rshl
(1)  273/     113 : BF                  	phi 	rParam2
(1)  274/     114 : F8 4C               	ldi 	('&' & 03Fh) * 2 										; point VarPtr to '&' variable
(1)  275/     116 : A6                  	plo 	rVarPtr
(1)  276/     117 : E6                  	sex 	rVarPtr
(1)  277/     118 :                     
(1)  278/     118 : 8F                  	glo 	rParam2 												; add contents of & to rParam2 
(1)  279/     119 : F4                  	add
(1)  280/     11A : AF                  	plo 	rParam2		
(1)  281/     11B : 16                  	inc 	rVarPtr
(1)  282/     11C : 9F                  	ghi 	rParam2
 AS V1.42 Beta [Bld 114] - source file test.asm(expression.asm) - page 8 - 14/1/2017 13:53:10


(1)  283/     11D : 74                  	adc
(1)  284/     11E : BF                  	phi 	rParam2 
(1)  285/     11F :                     
(1)  286/     11F : 4F                  	lda 	rParam2 												; read rParam2 into rParam1
(1)  287/     120 : AE                  	plo 	rParam1
(1)  288/     121 : 0F                  	ldn 	rParam2
(1)  289/     122 : BE                  	phi 	rParam1
(1)  290/     123 :                     __OpReturn:	
(1)  291/     123 : E2                  	sex 	r2
(1)  292/     124 : 12                  	inc 	r2
(1)  293/     125 : (MACRO)             	return
(1)  293/     125 : 71                          dis
(1)  294/     126 :                     
(1)  295/     126 :                     ; ***************************************************************************************************************
(1)  296/     126 :                     ;
(1)  297/     126 :                     ;								Subtraction. rParam1 := rParam1 - rParam2
(1)  298/     126 :                     ;									 (Also > < = which return 0 or 1)
(1)  299/     126 :                     ;
(1)  300/     126 :                     ; ***************************************************************************************************************
(1)  301/     126 :                     
(1)  302/     126 :                     __OpSub:															; rParam1 := rParam1 - rParam2
(1)  303/     126 : E2                  	sex		r2
(1)  304/     127 : 8F                  	glo 	rParam2
(1)  305/     128 : 52                  	str 	r2
(1)  306/     129 : 8E                  	glo 	rParam1
(1)  307/     12A : F7                  	sm
(1)  308/     12B : AE                  	plo 	rParam1
(1)  309/     12C : 9F                  	ghi 	rParam2
(1)  310/     12D : 52                  	str 	r2
(1)  311/     12E : 9E                  	ghi 	rParam1
(1)  312/     12F : 77                  	smb
(1)  313/     130 : BE                  	phi 	rParam1
(1)  314/     131 :                     
(1)  315/     131 : 9A                  	ghi 	rParenthesisLevel 										; this is the saved operator character
(1)  316/     132 : FB 2D               	xri 	'-'														; exit if '-'
(1)  317/     134 : 32 23               	bz 		__OpReturn
(1)  318/     136 : FB 10               	xri 	'-'!'='													; check if equals.
(1)  319/     138 : 32 47               	bz 		__OpEquality
(1)  320/     13A :                     ;
(1)  321/     13A :                     ;	Handle < > option. Note that > is actually the >= operation and is also the overall default.
(1)  322/     13A :                     ;
(1)  323/     13A : FB 03               	xri 	'>'!'='													; will now be 0 if >= , nonzero for < if anything else.
(1)  324/     13C : 32 40               	bz 		__OpLT0 	
(1)  325/     13E : F8 01               	ldi 	1
(1)  326/     140 :                     __OpLT0: 															; now 0 if >, 1 if <
(1)  327/     140 : 7C 00               	adci 	0 														; will now be odd if correct - adds in result from subtract
(1)  328/     142 : FA 01               	ani 	1 														; so isolate bit zero
(1)  329/     144 : 30 51               	br 		__OpWriteBoolean 										; and write it out.
(1)  330/     146 :                     
(1)  331/     146 : (MACRO)             	return
(1)  331/     146 : 71                          dis
(1)  332/     147 :                     ;
(1)  333/     147 :                     ;	Handle = option
(1)  334/     147 :                     ;
(1)  335/     147 :                     __OpEquality:
(1)  336/     147 : 8E                  	glo 	rParam1 												; get low result
(1)  337/     148 : 3A 4B               	bnz 	__OpEqNZ 	
(1)  338/     14A : 9E                  	ghi 	rParam1 												; if zero get high result
(1)  339/     14B :                     __OpEqNZ:															; if zero here both are zero e.g. it is 'true'
(1)  340/     14B : 32 4F               	bz 		__OpEqIsTrue 											
 AS V1.42 Beta [Bld 114] - source file test.asm(expression.asm) - page 9 - 14/1/2017 13:53:10


(1)  341/     14D : F8 01               	ldi 	1 															
(1)  342/     14F :                     __OpEqIsTrue:														; now 0 true 1 false
(1)  343/     14F : FB 01               	xri 	1 														; now 1 true 0 false
(1)  344/     151 :                     __OpWriteBoolean:	
(1)  345/     151 : AE                  	plo 	rParam1 												; put into rParam1
(1)  346/     152 : F8 00               	ldi 	0
(1)  347/     154 : BE                  	phi 	rParam1 							
(1)  348/     155 : 30 23               	br 		__OpReturn
(1)  349/     157 :                     
(1)  350/     157 :                     ; ***************************************************************************************************************
(1)  351/     157 :                     ;
(1)  352/     157 :                     ;										Outstanding utility routines fit here
(1)  353/     157 :                     ;
(1)  354/     157 :                     ; ***************************************************************************************************************
(1)  355/     157 :                     
(1)  356/     157 :                     	include 	utility/itoa.asm
(2)    1/     157 :                     ; ***************************************************************************************************************
(2)    2/     157 :                     ; ***************************************************************************************************************
(2)    3/     157 :                     ;
(2)    4/     157 :                     ;		File:		itoa.asm
(2)    5/     157 :                     ;		Purpose:	Convert 16 bit integer to ASCIIZ string
(2)    6/     157 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(2)    7/     157 :                     ;		Date:		10th January 2017.
(2)    8/     157 :                     ;		Size: 		47 bytes.
(2)    9/     157 :                     ;
(2)   10/     157 :                     ; ***************************************************************************************************************
(2)   11/     157 :                     ; ***************************************************************************************************************
(2)   12/     157 :                     
(2)   13/     157 :                     ; *******************************************************************************************************************
(2)   14/     157 :                     ;
(2)   15/     157 :                     ;	rParam1 is the number to convert. rParam2 is the end of the buffer, the digits are written backwards. On exit.
(2)   16/     157 :                     ;	rParam2 points to the string terminated in a NULL character. The NULL character is at the original value
(2)   17/     157 :                     ;	of rParam2. 
(2)   18/     157 :                     ;
(2)   19/     157 :                     ; *******************************************************************************************************************
(2)   20/     157 :                     
(2)   21/     157 :                     __ITOAExit:
(2)   22/     157 : 12                  	inc 	r2
(2)   23/     158 : (MACRO)             	return
(2)   23/     158 : 71                          dis
(2)   24/     159 :                     
(2)   25/     159 :                     IntegerToASCII:
(2)   26/     159 : E2                  	sex 	r2 															; index back at 2
(2)   27/     15A : F8 00               	ldi 	0 															; write the NULL terminator.
(2)   28/     15C : 5F                  	str 	rParam2
(2)   29/     15D :                     __ITOALoop:
(2)   30/     15D : 73                  	stxd 																; push dummy value, digit return stored here.
(2)   31/     15E : 9F                  	ghi 	rParam2 													; push rParam2 on the stack.
(2)   32/     15F : 73                  	stxd
(2)   33/     160 : 8F                  	glo	 	rParam2
(2)   34/     161 : 73                  	stxd
(2)   35/     162 : F8 00               	ldi 	0		 													; set to divide by 10.
(2)   36/     164 : BF                  	phi 	rParam2
(2)   37/     165 : F8 0A               	ldi 	10
(2)   38/     167 : AF                  	plo 	rParam2
(2)   39/     168 : F8 00               	ldi 	Divide/256
(2)   40/     16A : BD                  	phi 	rSubPC
(2)   41/     16B : F8 C0               	ldi 	Divide&255
(2)   42/     16D : AD                  	plo 	rSubPC
(2)   43/     16E : 79                  	mark  
 AS V1.42 Beta [Bld 114] - source file test.asm(itoa.asm) - page 10 - 14/1/2017 13:53:10


(2)   44/     16F : DD                  	sep 	rSubPC 														; do the call.
(2)   45/     170 : 12                  	inc 	r2
(2)   46/     171 : 12                  	inc 	r2 															; save digit result in dummy space
(2)   47/     172 : 8F                  	glo 	rParam2
(2)   48/     173 : 73                  	stxd 
(2)   49/     174 : 22                  	dec 	r2 															; now points to memory pointer for result
(2)   50/     175 : 42                  	lda 	r2 															; restore buffer pointer
(2)   51/     176 : AF                  	plo 	rParam2
(2)   52/     177 : 42                  	lda 	r2
(2)   53/     178 : BF                  	phi 	rParam2
(2)   54/     179 : 02                  	ldn 	r2 															; restore digit
(2)   55/     17A : F9 30               	ori		'0'															; make ASCII 
(2)   56/     17C : 2F                  	dec 	rParam2 													; back one character.
(2)   57/     17D : 5F                  	str 	rParam2 													; write into buffer
(2)   58/     17E :                     
(2)   59/     17E : 8E                  	glo 	rParam1 													; go around again if non-zero
(2)   60/     17F : 3A 5D               	bnz 	__ITOALoop
(2)   61/     181 : 9E                  	ghi 	rParam1
(2)   62/     182 : 3A 5D               	bnz 	__ITOALoop
(2)   63/     184 : 30 57               	br 		__ITOAExit 													; and prepare to exit.
(1)  357/     186 :                     	include 	utility/multiply.asm
(2)    1/     186 :                     ; ***************************************************************************************************************
(2)    2/     186 :                     ; ***************************************************************************************************************
(2)    3/     186 :                     ;
(2)    4/     186 :                     ;		File:		multiply.asm
(2)    5/     186 :                     ;		Purpose:	Multiply two 16 bit integers.
(2)    6/     186 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(2)    7/     186 :                     ;		Date:		9th January 2017.
(2)    8/     186 :                     ;		Size: 		41 bytes.
(2)    9/     186 :                     ;
(2)   10/     186 :                     ; ***************************************************************************************************************
(2)   11/     186 :                     ; ***************************************************************************************************************
(2)   12/     186 :                     
(2)   13/     186 :                     ; *******************************************************************************************************************
(2)   14/     186 :                     ;
(2)   15/     186 :                     ;	Multiply the values in rParam1 and rParam2 , returning result in rParam1.
(2)   16/     186 :                     ;
(2)   17/     186 :                     ; *******************************************************************************************************************
(2)   18/     186 :                     
(2)   19/     186 :                     __MULExit:
(2)   20/     186 : 42                  	lda 	r2 															; pop LSB result off stack.
(2)   21/     187 : AE                  	plo 	rParam1
(2)   22/     188 : 42                  	lda 	r2  														; pop MSB result off stack, do inc r2
(2)   23/     189 : BE                  	phi 	rParam1
(2)   24/     18A : (MACRO)             	return
(2)   24/     18A : 71                          dis
(2)   25/     18B :                     
(2)   26/     18B :                     Multiply:
(2)   27/     18B : E2                  	sex 	r2 															; back using R2 as the index register
(2)   28/     18C : F8 00               	ldi 	0 															; reset the result, which is on the stack.
(2)   29/     18E : 73                  	stxd	
(2)   30/     18F : 52                  	str 	r2
(2)   31/     190 :                     
(2)   32/     190 :                     __MULLoop:
(2)   33/     190 :                     
(2)   34/     190 : 9E                  	ghi 	rParam1 													; shift first multiplier right into DF
(2)   35/     191 : F6                  	shr
(2)   36/     192 : BE                  	phi 	rParam1
(2)   37/     193 : 8E                  	glo 	rParam1
(2)   38/     194 : 76                  	rshr
 AS V1.42 Beta [Bld 114] - source file test.asm(multiply.asm) - page 11 - 14/1/2017 13:53:10


(2)   39/     195 : AE                  	plo 	rParam1
(2)   40/     196 : 3B 9F               	bnf 	__MULDontAdd 												; if DF is set add rParam2 to the result.
(2)   41/     198 :                     
(2)   42/     198 : 8F                  	glo 	rParam2 													; add rParam2 to result on TOS.
(2)   43/     199 : F4                  	add 
(2)   44/     19A : 52                  	str 	r2
(2)   45/     19B : 12                  	inc 	r2
(2)   46/     19C : 9F                  	ghi 	rParam2
(2)   47/     19D : 74                  	adc
(2)   48/     19E : 73                  	stxd 
(2)   49/     19F :                     
(2)   50/     19F :                     __MULDontAdd:
(2)   51/     19F : 8F                  	glo 	rParam2 													; shift rParam2 left
(2)   52/     1A0 : FE                  	shl
(2)   53/     1A1 : AF                  	plo 	rParam2
(2)   54/     1A2 : 9F                  	ghi 	rParam2
(2)   55/     1A3 : 7E                  	rshl
(2)   56/     1A4 : BF                  	phi 	rParam2
(2)   57/     1A5 :                     
(2)   58/     1A5 : 8E                  	glo 	rParam1 													; is first multiplier non zero, if not go back.
(2)   59/     1A6 : 3A 90               	bnz 	__MULLoop
(2)   60/     1A8 : 9E                  	ghi 	rParam1
(2)   61/     1A9 : 3A 90               	bnz 	__MULLoop
(2)   62/     1AB : 30 86               	br 		__MULExit 													; both are zero, so exit.	
(1)  358/     1AD :                     	include 	utility/atoi.asm
(2)    1/     1AD :                     ; ***************************************************************************************************************
(2)    2/     1AD :                     ; ***************************************************************************************************************
(2)    3/     1AD :                     ;
(2)    4/     1AD :                     ;		File:		atoi.asm
(2)    5/     1AD :                     ;		Purpose:	Extract 16 bit integer from ASCII string.
(2)    6/     1AD :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(2)    7/     1AD :                     ;		Date:		9th January 2017.
(2)    8/     1AD :                     ;		Size: 		67 bytes.
(2)    9/     1AD :                     ;
(2)   10/     1AD :                     ; ***************************************************************************************************************
(2)   11/     1AD :                     ; ***************************************************************************************************************
(2)   12/     1AD :                     
(2)   13/     1AD :                     ; *******************************************************************************************************************
(2)   14/     1AD :                     ;
(2)   15/     1AD :                     ;	Takes one value in rParam1, pointer to a string, returns number read in rParam2.
(2)   16/     1AD :                     ;	rParam1 points to the next character after the last one of the number.	
(2)   17/     1AD :                     ;	
(2)   18/     1AD :                     ;	On exit non-zero if a digit was read.
(2)   19/     1AD :                     ;
(2)   20/     1AD :                     ; *******************************************************************************************************************
(2)   21/     1AD :                     
(2)   22/     1AD :                     __ATOIExit:
(2)   23/     1AD : 2E                  	dec 	rParam1 													; undo the last read, wasn't a digit.
(2)   24/     1AE : 42                  	lda 	r2 															; read the flag for 'digits read'
(2)   25/     1AF : (MACRO)             	return
(2)   25/     1AF : 71                          dis
(2)   26/     1B0 :                     
(2)   27/     1B0 :                     ASCIIToInteger:
(2)   28/     1B0 : E2                  	sex 	r2 															; index back at 2
(2)   29/     1B1 : F8 00               	ldi 	0 															; clear number read
(2)   30/     1B3 : AF                  	plo 	rParam2
(2)   31/     1B4 : BF                  	phi 	rParam2
(2)   32/     1B5 : 52                  	str 	r2 															; [TOS] is count of digits read okay.
(2)   33/     1B6 :                     
(2)   34/     1B6 :                     __ATOILoop:
 AS V1.42 Beta [Bld 114] - source file test.asm(atoi.asm) - page 12 - 14/1/2017 13:53:10


(2)   35/     1B6 : 4E                  	lda 	rParam1 													; read next character and bump
(2)   36/     1B7 : FB 20               	xri 	' ' 														; skip over spaces.
(2)   37/     1B9 : 32 B6               	bz 		__ATOILoop 												
(2)   38/     1BB : FB 20               	xri 	' ' 														; fix it back.
(2)   39/     1BD : FC C6               	adi 	255-'9' 													; will cause DF if >= '9'
(2)   40/     1BF : 33 AD               	bdf 	__ATOIExit
(2)   41/     1C1 : FC 0A               	adi 	10 															; adding 10 will cause NF if < '0'	
(2)   42/     1C3 : 3B AD               	bnf 	__ATOIExit
(2)   43/     1C5 :                     
(2)   44/     1C5 : 73                  	stxd 																; push digit value, current value of number
(2)   45/     1C6 : 9F                  	ghi 	rParam2  													; on stack.
(2)   46/     1C7 : 73                  	stxd
(2)   47/     1C8 : 8F                  	glo 	rParam2
(2)   48/     1C9 : 52                  	str 	r2
(2)   49/     1CA :                     
(2)   50/     1CA :                     __ATOIDoubleRParam2 macro 												; macro that doubles the value in rParam2
(2)   51/     1CA :                     	glo 	rParam2 													
(2)   52/     1CA :                     	shl
(2)   53/     1CA :                     	plo 	rParam2
(2)   54/     1CA :                     	ghi 	rParam2
(2)   55/     1CA :                     	rshl
(2)   56/     1CA :                     	phi 	rParam2
(2)   57/     1CA :                     	endm
(2)   58/     1CA :                     
(2)   59/     1CA : (MACRO)             	__ATOIDoubleRParam2 												; rParam2 * 2
(2)   59/     1CA : 8F                          glo     rParam2                                                                                                         
(2)   59/     1CB : FE                          shl
(2)   59/     1CC : AF                          plo     rParam2
(2)   59/     1CD : 9F                          ghi     rParam2
(2)   59/     1CE : 7E                          rshl
(2)   59/     1CF : BF                          phi     rParam2
(2)   60/     1D0 : (MACRO)             	__ATOIDoubleRParam2 												; rParam2 * 4
(2)   60/     1D0 : 8F                          glo     rParam2                                                                                                         
(2)   60/     1D1 : FE                          shl
(2)   60/     1D2 : AF                          plo     rParam2
(2)   60/     1D3 : 9F                          ghi     rParam2
(2)   60/     1D4 : 7E                          rshl
(2)   60/     1D5 : BF                          phi     rParam2
(2)   61/     1D6 : 8F                  	glo 	rParam2 													; add stack values on there.
(2)   62/     1D7 : F4                  	add
(2)   63/     1D8 : AF                  	plo 	rParam2
(2)   64/     1D9 : 12                  	inc 	r2
(2)   65/     1DA : 9F                  	ghi 	rParam2
(2)   66/     1DB : 74                  	adc
(2)   67/     1DC : BF                  	phi 	rParam2  													; so now rParam * 5
(2)   68/     1DD : (MACRO)             	__ATOIDoubleRParam2 												; so now rParam * 10
(2)   68/     1DD : 8F                          glo     rParam2                                                                                                         
(2)   68/     1DE : FE                          shl
(2)   68/     1DF : AF                          plo     rParam2
(2)   68/     1E0 : 9F                          ghi     rParam2
(2)   68/     1E1 : 7E                          rshl
(2)   68/     1E2 : BF                          phi     rParam2
(2)   69/     1E3 :                     
(2)   70/     1E3 : 12                  	inc 	r2 															; point to digit value
(2)   71/     1E4 : 8F                  	glo 	rParam2
(2)   72/     1E5 : F4                  	add
(2)   73/     1E6 : AF                  	plo 	rParam2
(2)   74/     1E7 : 9F                  	ghi 	rParam2
(2)   75/     1E8 : 7C 00               	adci 	0
(2)   76/     1EA : BF                  	phi 	rParam2
 AS V1.42 Beta [Bld 114] - source file test.asm(atoi.asm) - page 13 - 14/1/2017 13:53:10


(2)   77/     1EB :                     
(2)   78/     1EB : F8 FF               	ldi 	0FFh 														; set the 'read a digit' flag.
(2)   79/     1ED : 52                  	str 	r2 
(2)   80/     1EE : 30 B6               	br 		__ATOILoop
(2)   81/     1F0 :                     
(1)  359/     1F0 :                     
(1)  360/     1F0 :                     NewPage2: 															; switch to the next page.
(1)  361/     200 :                     	org 	(NewPage2+255)/256*256 
(1)  362/     200 :                     
      43/     200 :                     
      44/     200 :                     	include 	handler.asm 									; special routine handler.
(1)    1/     200 :                     ; ***************************************************************************************************************
(1)    2/     200 :                     ; ***************************************************************************************************************
(1)    3/     200 :                     ;
(1)    4/     200 :                     ;		File:		handler.asm
(1)    5/     200 :                     ;		Purpose:	Handle side-effect variables on read.
(1)    6/     200 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     200 :                     ;		Date:		11th January 2017.
(1)    8/     200 :                     ;
(1)    9/     200 :                     ; ***************************************************************************************************************
(1)   10/     200 :                     ; ***************************************************************************************************************
(1)   11/     200 :                     
(1)   12/     200 :                     ; ***************************************************************************************************************
(1)   13/     200 :                     ;
(1)   14/     200 :                     ;		This routine provides the variable in D. On exit, if D = 0 the "variable" has been accessed and
(1)   15/     200 :                     ;		put in rParam2.
(1)   16/     200 :                     ;
(1)   17/     200 :                     ;		The right hand variables with side effects in VTL-2 are :-
(1)   18/     200 :                     ;
(1)   19/     200 :                     ;		?	input an integer (technically an expression .....)
(1)   20/     200 :                     ; 		$ 	input a single character
(1)   21/     200 :                     ;
(1)   22/     200 :                     ;		This is run with P = rSpecialHandler X = 2
(1)   23/     200 :                     ;
(1)   24/     200 :                     ;		Must preserve: rSrc, rVarPtr*, rExprPC, rParenthesisLevel, rSaveStack and of course R2.
(1)   25/     200 :                     ;
(1)   26/     200 :                     ;		* can be assumed constant.
(1)   27/     200 :                     ;
(1)   28/     200 :                     ;		Use: rUtilPC, rSubPC, rParam1, rParam2.
(1)   29/     200 :                     ;
(1)   30/     200 :                     ; ***************************************************************************************************************
(1)   31/     200 :                     
(1)   32/     200 :                     __SHExit:
(1)   33/     200 : D7                  	sep 	rExprPC
(1)   34/     201 :                     SpecialHandler:
(1)   35/     201 : FB 24               	xri 	'$'															; check if '$' (get character)
(1)   36/     203 : 32 0B               	bz 		__SHGetKey
(1)   37/     205 : FB 1B               	xri 	'$'!'?'														; check if '?' (get string expression)
(1)   38/     207 : 32 1A               	bz 		__SHInput
(1)   39/     209 : 30 00               	br 		__SHExit
(1)   40/     20B :                     
(1)   41/     20B :                     ; ***************************************************************************************************************
(1)   42/     20B :                     ;
(1)   43/     20B :                     ;							$ operator. Returns a single key press in rParam2
(1)   44/     20B :                     ;
(1)   45/     20B :                     ; ***************************************************************************************************************
(1)   46/     20B :                     
(1)   47/     20B :                     __SHGetKey:
(1)   48/     20B : (MACRO)             	ldr 	rUtilPC,XIOGetKey 											; this is the external function which reads the keyboard
(1)   48/     20B : F8 03                       ldi     (XIOGETKEY)/256
 AS V1.42 Beta [Bld 114] - source file test.asm(handler.asm) - page 14 - 14/1/2017 13:53:10


(1)   48/     20D : BC                          phi     RUTILPC
(1)   48/     20E : F8 36                       ldi     (XIOGETKEY)&255
(1)   48/     210 : AC                          plo     RUTILPC
(1)   49/     211 : 79                  	mark 																; and it is called using the MARK method. 
(1)   50/     212 : DC                  	sep 	rUtilPC
(1)   51/     213 : 22                  	dec 	r2
(1)   52/     214 : AF                  	plo 	rParam2 													; put result in rParam2.0
(1)   53/     215 : F8 00               	ldi 	0 															; clear rParam2.1 and D, indicating successful processing.
(1)   54/     217 : BF                  	phi 	rParam2
(1)   55/     218 : 30 00               	br 		__SHExit 													; and exit.
(1)   56/     21A :                     
(1)   57/     21A :                     ; ***************************************************************************************************************
(1)   58/     21A :                     ;
(1)   59/     21A :                     ;							? operator. Inputs a string, evaluates it and returns.
(1)   60/     21A :                     ;
(1)   61/     21A :                     ; ***************************************************************************************************************
(1)   62/     21A :                     
(1)   63/     21A :                     __SHInput:
(1)   64/     21A : (MACRO)             	ldr 	rSubPC,XIOWriteCharacter 									; prompt.
(1)   64/     21A : F8 03                       ldi     (XIOWRITECHARACTER)/256
(1)   64/     21C : BD                          phi     RSUBPC
(1)   64/     21D : F8 3C                       ldi     (XIOWRITECHARACTER)&255
(1)   64/     21F : AD                          plo     RSUBPC
(1)   65/     220 : F8 3F               	ldi 	'?'
(1)   66/     222 : 79                  	mark
(1)   67/     223 : DD                  	sep 	rSubPC
(1)   68/     224 : 22                  	dec 	r2
(1)   69/     225 :                     
(1)   70/     225 : (MACRO)             	ldr 	rUtilPC,READLine 											; read line into input buffer.
(1)   70/     225 : F8 02                       ldi     (READLINE)/256
(1)   70/     227 : BC                          phi     RUTILPC
(1)   70/     228 : F8 3D                       ldi     (READLINE)&255
(1)   70/     22A : AC                          plo     RUTILPC
(1)   71/     22B : 79                  	mark 																; returns it in rParam1
(1)   72/     22C : DC                  	sep 	rUtilPC 
(1)   73/     22D : 22                  	dec 	r2
(1)   74/     22E :                     
(1)   75/     22E : (MACRO)             	ldr 	rUtilPC,ASCIIToInteger										; convert to number
(1)   75/     22E : F8 01                       ldi     (ASCIITOINTEGER)/256
(1)   75/     230 : BC                          phi     RUTILPC
(1)   75/     231 : F8 B0                       ldi     (ASCIITOINTEGER)&255
(1)   75/     233 : AC                          plo     RUTILPC
(1)   76/     234 : 79                  	mark 																; and do so.
(1)   77/     235 : DC                  	sep 	rUtilPC
(1)   78/     236 : 22                  	dec 	r2
(1)   79/     237 : 32 1A               	bz 		__SHInput
(1)   80/     239 :                     
(1)   81/     239 : F8 00               	ldi 	0  															; and exit with D = 0 indicating done.
(1)   82/     23B : 30 00               	br 		__SHExit 
(1)   83/     23D :                     
(1)   84/     23D :                     ; ***************************************************************************************************************
(1)   85/     23D :                     ;
(1)   86/     23D :                     ;						Read Line in from Keyboard, returns address in rParam1
(1)   87/     23D :                     ;
(1)   88/     23D :                     ; ***************************************************************************************************************
(1)   89/     23D :                     
(1)   90/     23D :                     READLine:
(1)   91/     23D : F8 7F               	ldi 	7Fh 														; set up rParam1 to point to the string.
(1)   92/     23F : AE                  	plo 	rParam1
(1)   93/     240 : 96                  	ghi 	rVarPtr
 AS V1.42 Beta [Bld 114] - source file test.asm(handler.asm) - page 15 - 14/1/2017 13:53:10


(1)   94/     241 : BE                  	phi 	rParam1
(1)   95/     242 :                     
(1)   96/     242 :                     __RLLNextCharacter:
(1)   97/     242 : 1E                  	inc 	rParam1
(1)   98/     243 :                     __RLLLoop:
(1)   99/     243 : E2                  	sex 	r2 															; use R2 as index
(1)  100/     244 : (MACRO)             	ldr 	rSubPC,XIOGetKey 											; call get key routine.
(1)  100/     244 : F8 03                       ldi     (XIOGETKEY)/256
(1)  100/     246 : BD                          phi     RSUBPC
(1)  100/     247 : F8 36                       ldi     (XIOGETKEY)&255
(1)  100/     249 : AD                          plo     RSUBPC
(1)  101/     24A : 79                  	mark 	
(1)  102/     24B : DD                  	sep 	rSubPC
(1)  103/     24C : 22                  	dec 	r2
(1)  104/     24D : 5E                  	str 	rParam1	 													; save in text buffer.
(1)  105/     24E :                     
(1)  106/     24E : (MACRO)             	ldr 	rSubPC,XIOWriteCharacter
(1)  106/     24E : F8 03                       ldi     (XIOWRITECHARACTER)/256
(1)  106/     250 : BD                          phi     RSUBPC
(1)  106/     251 : F8 3C                       ldi     (XIOWRITECHARACTER)&255
(1)  106/     253 : AD                          plo     RSUBPC
(1)  107/     254 : 0E                  	ldn 	rParam1
(1)  108/     255 : 79                  	mark
(1)  109/     256 : DD                  	sep 	rSubPC
(1)  110/     257 : 22                  	dec 	r2
(1)  111/     258 :                     
(1)  112/     258 : 0E                  	ldn 	rParam1
(1)  113/     259 : FB 08               	xri 	8 															; Ctl+H
(1)  114/     25B : 32 67               	bz 		__RLLPrevCharacter 											; get previous character
(1)  115/     25D : FB 05               	xri 	13!8 														; is it CR ?
(1)  116/     25F : 3A 42               	bnz 	__RLLNextCharacter 											; no go around again
(1)  117/     261 :                     __RLLExit:
(1)  118/     261 : 5E                  	str 	rParam1 													; save the zero in rVarPtr making string ASCIIZ.
(1)  119/     262 : F8 80               	ldi 	80h 														; point rParam1 to the start of the string.
(1)  120/     264 : AE                  	plo 	rParam1
(1)  121/     265 : 12                  	inc 	r2 															; and exit.
(1)  122/     266 : (MACRO)             	return
(1)  122/     266 : 71                          dis
(1)  123/     267 :                     
(1)  124/     267 :                     __RLLPrevCharacter:
(1)  125/     267 : 2E                  	dec 	rParam1
(1)  126/     268 : 8E                  	glo 	rParam1
(1)  127/     269 : FE                  	shl
(1)  128/     26A : 33 43               	bdf 	__RLLLoop
(1)  129/     26C : 30 42               	br 		__RLLNextCharacter
(1)  130/     26E :                     
      45/     26E :                     
      46/     26E :                     NewPage3:
      47/     300 :                     	org 	(NewPage3+255)/256*256 
      48/     300 :                     
      49/     300 :                     start:
      50/     300 : (MACRO)             	ldr 	r2,3FFFh 											; stack
      50/     300 : F8 3F                       ldi     (3FFFH)/256
      50/     302 : B2                          phi     R2
      50/     303 : F8 FF                       ldi     (3FFFH)&255
      50/     305 : A2                          plo     R2
      51/     306 : E2                  	sex 	r2
      52/     307 :                     
      53/     307 : (MACRO)             	ldr 	rVarPtr,2800h 										; varptr high byte only reqd unchanged throughout
      53/     307 : F8 28                       ldi     (2800H)/256
 AS V1.42 Beta [Bld 114] - source file test.asm - page 16 - 14/1/2017 13:53:10


      53/     309 : B6                          phi     RVARPTR
      53/     30A : F8 00                       ldi     (2800H)&255
      53/     30C : A6                          plo     RVARPTR
      54/     30D : (MACRO)             	ldr 	rSrc,eString 										; evaluate the string
      54/     30D : F8 03                       ldi     (ESTRING)/256
      54/     30F : B8                          phi     RSRC
      54/     310 : F8 24                       ldi     (ESTRING)&255
      54/     312 : A8                          plo     RSRC
      55/     313 : (MACRO)             	ldr 	rExprPC,EXPRevaluate 								; the code
      55/     313 : F8 00                       ldi     (EXPREVALUATE)/256
      55/     315 : B7                          phi     REXPRPC
      55/     316 : F8 14                       ldi     (EXPREVALUATE)&255
      55/     318 : A7                          plo     REXPRPC
      56/     319 : (MACRO)             	ldr 	rSpecialHandler,SpecialHandler 						; dummy special handler.
      56/     319 : F8 02                       ldi     (SPECIALHANDLER)/256
      56/     31B : B9                          phi     RSPECIALHANDLER
      56/     31C : F8 01                       ldi     (SPECIALHANDLER)&255
      56/     31E : A9                          plo     RSPECIALHANDLER
      57/     31F : 79                  	mark
      58/     320 : D7                  	sep 	rExprPC
      59/     321 : 22                  	dec 	r2
      60/     322 :                     wait:
      61/     322 : 30 22               	br 	wait
      62/     324 :                     
      63/     324 :                     eString:
      64/     324 : 3F 2B 31 00         	db 		"?+1",0
      65/     328 :                     ;	db 		"40003>40004",0
      66/     328 :                     ;	db 		" \"A\"+1",0
      67/     328 :                     ;	db 		":2)-1",0
      68/     328 :                     ;	db 		"42 ) this is a comment",0
      69/     328 :                     ;	db 		"4+255+",0
      70/     328 : 28 34 2A 35 29 2D   	db 		"(4*5)-(2*3)*2",0
                    28 32 2A 33 29 2A 
                    32 00 
      71/     336 :                     
      72/     336 :                     	include	virtualio.asm 										; I/O routines that are hardware specific.
(1)    1/     336 :                     ; ***************************************************************************************************************
(1)    2/     336 :                     ; ***************************************************************************************************************
(1)    3/     336 :                     ;
(1)    4/     336 :                     ;		File:		virtualio.asm
(1)    5/     336 :                     ;		Purpose:	Input/Output routines.
(1)    6/     336 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     336 :                     ;		Date:		14th January 2017.
(1)    8/     336 :                     ;
(1)    9/     336 :                     ; ***************************************************************************************************************
(1)   10/     336 :                     ; ***************************************************************************************************************
(1)   11/     336 :                     
(1)   12/     336 :                     ; ***************************************************************************************************************
(1)   13/     336 :                     ;
(1)   14/     336 :                     ;	These routines will be entered with P = rUtilPC or P = rSubPC and should change no registers other than
(1)   15/     336 :                     ; 	D and DF. On entry R2 will point to an empty stack space.
(1)   16/     336 :                     ;
(1)   17/     336 :                     ; ***************************************************************************************************************
(1)   18/     336 :                     
(1)   19/     336 :                     ; ***************************************************************************************************************
(1)   20/     336 :                     ;
(1)   21/     336 :                     ;												Get a keystroke into D.
(1)   22/     336 :                     ;
(1)   23/     336 :                     ; ***************************************************************************************************************
(1)   24/     336 :                     
 AS V1.42 Beta [Bld 114] - source file test.asm(virtualio.asm) - page 17 - 14/1/2017 13:53:10


(1)   25/     336 :                     XIOGetKey:
(1)   26/     336 : E2                  	sex 	r2 															; fix up after Mark.
(1)   27/     337 : 69                  	inp 	1 															; read keyboard port
(1)   28/     338 : 32 36               	bz 		XIOGetKey 													; no key, keep trying
(1)   29/     33A : 12                  	inc 	r2 															; standard return.
(1)   30/     33B : (MACRO)             	return
(1)   30/     33B : 71                          dis
(1)   31/     33C :                     
(1)   32/     33C :                     ; ***************************************************************************************************************
(1)   33/     33C :                     ;
(1)   34/     33C :                     ;										    Write a character to the display
(1)   35/     33C :                     ;
(1)   36/     33C :                     ; ***************************************************************************************************************
(1)   37/     33C :                     
(1)   38/     33C :                     XIOWriteCharacter:
(1)   39/     33C : E2                  	sex 	r2
(1)   40/     33D : 52                  	str 	r2
(1)   41/     33E : 61                  	out 	1
(1)   42/     33F : 22                  	dec 	r2
(1)   43/     340 : 12                  	inc 	r2
(1)   44/     341 : (MACRO)             	return
(1)   44/     341 : 71                          dis
 AS V1.42 Beta [Bld 114] - source file test.asm - page 18 - 14/1/2017 13:53:10


  symbol table (* = unused):
  ------------------------

*ARCHITECTURE :                                        x86_64-unknown-linux - |
 ASCIITOINTEGER :               1B0 C | *BIGENDIAN :                      0 - |
*BRANCHEXT :                      0 - | *CASESENSITIVE :                  0 - |
*CONSTPI :        3.141592653589793 - | *DATE :                   14/1/2017 - |
 DIVIDE :                        C0 C |  ESTRING :                      324 C |
 EXPREVALUATE :                  14 C | *FALSE :                          0 - |
*FULLPMMU :                       1 - | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - | *INEXTMODE :                      0 - |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
*INTEGERTOASCII :               159 C | *LISTON :                         1 - |
*MACEXP :                         1 - | *MOMCPU :                      1802 - |
*MOMCPUNAME :                  1802 - |  MULTIPLY :                     18B C |
*NESTMAX :                      100 - |  NEWPAGE1 :                      F4 C |
 NEWPAGE2 :                     1F0 C |  NEWPAGE3 :                     26E C |
*PACKING :                        0 - | *PADDING :                        1 - |
*R0 :                             0 - | *R1 :                             1 - |
 R2 :                             2 - |  R3 :                             3 - |
 READLINE :                     23D C | *RELAXED :                        0 - |
 REXPRPC :                        7 - |  RPARAM1 :                        E - |
 RPARAM2 :                        F - |  RPARENTHESISLEVEL :              A - |
 RSAVESTACK :                     B - |  RSPECIALHANDLER :                9 - |
 RSRC :                           8 - |  RSUBPC :                         D - |
 RUTILPC :                        C - |  RVARPTR :                        6 - |
 SPECIALHANDLER :               201 C |  START :                        300 C |
*TIME :                    13:53:10 - | *TRUE :                           1 - |
*VERSION :                     142F - |  WAIT :                         322 C |
 XIOGETKEY :                    336 C |  XIOWRITECHARACTER :            33C C |
 __ATOIEXIT :                   1AD C |  __ATOILOOP :                   1B6 C |
 __DIVEXIT :                     BE C | *__DIVLOOP :                     CF C |
 __DIVLOOPINCR2 :                CE C |  __DIVLOOPINCR2INCR2 :           CD C |
 __EXPRARRAY :                   57 C |  __EXPRDESTACKBRACKET :          A4 C |
 __EXPREXIT :                     A C |  __EXPREXITDEC :                  9 C |
 __EXPRFINDOPERATION :           6E C |  __EXPRFOUNDOPERATION :          76 C |
 __EXPRGOTCHARACTER :            5F C |  __EXPRGOTTERM :                 67 C |
 __EXPRNEWLEVEL :                1C C |  __EXPRNEWTERM :                 24 C |
 __EXPRNOTDIVIDE :               90 C |  __EXPRSKIPSPACE :               94 C |
 __ITOAEXIT :                   157 C |  __ITOALOOP :                   15D C |
 __MULDONTADD :                 19F C |  __MULEXIT :                    186 C |
 __MULLOOP :                    190 C |  __OPADD :                      100 C |
 __OPEQISTRUE :                 14F C |  __OPEQNZ :                     14B C |
 __OPEQUALITY :                 147 C |  __OPERATORTABLE :               AF C |
 __OPLOOKUP :                   10D C |  __OPLT0 :                      140 C |
 __OPRETURN :                   123 C |  __OPSUB :                      126 C |
 __OPWRITEBOOLEAN :             151 C | *__RLLEXIT :                    261 C |
 __RLLLOOP :                    243 C |  __RLLNEXTCHARACTER :           242 C |
 __RLLPREVCHARACTER :           267 C |  __SHEXIT :                     200 C |
 __SHGETKEY :                   20B C |  __SHINPUT :                    21A C |

     97 symbols
     33 unused symbols

 AS V1.42 Beta [Bld 114] - source file test.asm - page 19 - 14/1/2017 13:53:10


  defined macros:
  ---------------

LDR                                   | OPER                                 
RETURN                                | __ATOIDOUBLERPARAM2                  

      4 macros

 AS V1.42 Beta [Bld 114] - source file test.asm - page 20 - 14/1/2017 13:53:10


  codepages:
  ----------

STANDARD (0 changed characters)


0.01 seconds assembly time

    902 lines source file
    980 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
