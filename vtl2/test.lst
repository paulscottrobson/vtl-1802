 AS V1.42 Beta [Bld 114] - source file test.asm - page 1 - 10/1/2017 20:08:44


       1/       0 :                     
       2/       0 :                     	cpu 	1802
       3/       0 :                     	
       4/       0 :                     return macro
       5/       0 :                     	dis
       6/       0 :                     	endm
       7/       0 :                     
       8/       0 : =0H                 r0 = 0 															; not used (may be used in interrupt display)
       9/       0 : =1H                 r1 = 1 															; interrupt register
      10/       0 : =2H                 r2 = 2 															; stack pointer
      11/       0 :                     
      12/       0 : =9H                 rVarPtr = 9 													; always points to variables.
      13/       0 : =AH                 rExprPC = 10 													; used as P register in expression (mandated)
      14/       0 : =BH                 rSrc = 11 														; source code.
      15/       0 : =CH                 rUtilPC = 12 													; used as P register calling routines (not mandated)
      16/       0 : =DH                 rSubPC = 13														; used as P register to call routines within routines
      17/       0 : =EH                 rParam1 = 14 													; subroutine parameters/return values.
      18/       0 : =FH                 rParam2 = 15
      19/       0 :                     
      20/       0 : =9H                 rParenthesisLevel = 9 											; bracket level (low byte)
      21/       0 :                     
      22/       0 :                     ldr macro 	r,n
      23/       0 :                     	ldi 	(n)/256
      24/       0 :                     	phi 	r
      25/       0 :                     	ldi 	(n)&255
      26/       0 :                     	plo 	r
      27/       0 :                     	endm
      28/       0 :                     
      29/       0 :                     
      30/       0 : 71                  	dis
      31/       1 : 00                  	db 		0
      32/       2 : (MACRO)             	ldr 	r2,3FFFh
      32/       2 : F8 3F                       ldi     (3FFFH)/256
      32/       4 : B2                          phi     R2
      32/       5 : F8 FF                       ldi     (3FFFH)&255
      32/       7 : A2                          plo     R2
      33/       8 : E2                  	sex 	r2
      34/       9 : (MACRO)             	ldr 	rVarPtr,2800h
      34/       9 : F8 28                       ldi     (2800H)/256
      34/       B : B9                          phi     RVARPTR
      34/       C : F8 00                       ldi     (2800H)&255
      34/       E : A9                          plo     RVARPTR
      35/       F : (MACRO)             	ldr 	rSrc,eString
      35/       F : F8 03                       ldi     (ESTRING)/256
      35/      11 : BB                          phi     RSRC
      35/      12 : F8 0C                       ldi     (ESTRING)&255
      35/      14 : AB                          plo     RSRC
      36/      15 : (MACRO)             	ldr 	rExprPC,EXPRevaluate
      36/      15 : F8 01                       ldi     (EXPREVALUATE)/256
      36/      17 : BA                          phi     REXPRPC
      36/      18 : F8 07                       ldi     (EXPREVALUATE)&255
      36/      1A : AA                          plo     REXPRPC
      37/      1B : 79                  	mark
      38/      1C : DA                  	sep 	rExprPC
      39/      1D : 22                  	dec 	r2
      40/      1E :                     wait:
      41/      1E : 30 1E               	br 	wait
      42/      20 :                     
      43/      20 :                     buffer:
      44/     100 :                     	org 		100h
 AS V1.42 Beta [Bld 114] - source file test.asm - page 2 - 10/1/2017 20:08:44


      45/     100 :                     	include 	expression.asm
(1)    1/     100 :                     
(1)    2/     100 :                     __EXPRExitDec:
(1)    3/     100 : 2B                  	dec 	rSrc 
(1)    4/     101 :                     __EXPRExit:
(1)    5/     101 : 12                  	inc 	r2
(1)    6/     102 : 42                  	lda 	r2
(1)    7/     103 : AE                  	plo 	rParam1
(1)    8/     104 : 42                  	lda 	r2
(1)    9/     105 : BE                  	phi 	rParam1
(1)   10/     106 : (MACRO)             	return
(1)   10/     106 : 71                          dis
(1)   11/     107 :                     
(1)   12/     107 :                     EXPREvaluate:
(1)   13/     107 : E2                  	sex 	r2 															; using X = 2 again
(1)   14/     108 : F8 FF               	ldi 	-1 															; clear parenthesis level to -1 (first increment)
(1)   15/     10A : A9                  	plo 	rParenthesisLevel 
(1)   16/     10B : F8 02               	ldi 	UtilityPage/256  											; set Utility Page.1
(1)   17/     10D : BC                  	phi 	rUtilPC 
(1)   18/     10E :                     __EXPRNewLevel:	
(1)   19/     10E : F8 00               	ldi 	0 															; push $0000  + on the stack.
(1)   20/     110 : 73                  	stxd 																; MSB first
(1)   21/     111 : 73                  	stxd 																; LSB
(1)   22/     112 : F8 2B               	ldi 	'+' 												 		; the put '+' on the stack as pending operation.
(1)   23/     114 : 73                  	stxd
(1)   24/     115 : 19                  	inc 	rParenthesisLevel 											; bump the parenthesis level up 1.
(1)   25/     116 :                     ;
(1)   26/     116 :                     ;		On reaching this point, we are looking for a new Term.
(1)   27/     116 :                     ;
(1)   28/     116 :                     __EXPRNewTerm:
(1)   29/     116 : 8B                  	glo 	rSrc 														; put rSrc into rParam1
(1)   30/     117 : AE                  	plo 	rParam1
(1)   31/     118 : 9B                  	ghi 	rSrc
(1)   32/     119 : BE                  	phi 	rParam1
(1)   33/     11A : F8 8F               	ldi 	ASCIIToInteger & 255 										; call the atoi() routine.
(1)   34/     11C : AC                  	plo 	rUtilPC
(1)   35/     11D : 79                  	mark
(1)   36/     11E : DC                  	sep 	rUtilPC
(1)   37/     11F : 22                  	dec 	r2 		
(1)   38/     120 :                     
(1)   39/     120 : FC FF               	adi 	0FFh 														; sets DF if non zero value returned
(1)   40/     122 : 8E                  	glo 	rParam1 													; constant rParam1 back into rSrc
(1)   41/     123 : AB                  	plo 	rSrc
(1)   42/     124 : 9E                  	ghi 	rParam1
(1)   43/     125 : BB                  	phi 	rSrc
(1)   44/     126 : 33 54               	bdf 	__EXPRGotTerm 												; if constant then done.
(1)   45/     128 :                     
(1)   46/     128 : 4B                  	lda 	rSrc 														; look at character.
(1)   47/     129 : 32 00               	bz 		__EXPRExitDec 												; none provided.
(1)   48/     12B : FB 22               	xri 	'"'															; is it quote mark
(1)   49/     12D : 32 4C               	bz 		__EXPRGotCharacter 											; if so do that handler.
(1)   50/     12F : FB 0A               	xri	 	'('!'"' 													; is it open parenthesis.
(1)   51/     131 : 32 0E               	bz		__EXPRNewLevel 												; if so open new level.
(1)   52/     133 : FB 12               	xri 	':'!'('														; is it new array ?
(1)   53/     135 : 32 44               	bz 		__EXPRArray
(1)   54/     137 : FB 3A               	xri 	':' 														; so make it back to the correct character.
(1)   55/     139 : DA                  	sep 	rExprPC 													; check for 'special ones'
(1)   56/     13A : 32 54               	bz 		__EXPRGotTerm 												; if found one, we've got a term.
(1)   57/     13C : FE                  	shl 																; byte size to word size
(1)   58/     13D : A9                  	plo 	rVarPtr 													; now point to variable
 AS V1.42 Beta [Bld 114] - source file test.asm(expression.asm) - page 3 - 10/1/2017 20:08:44


(1)   59/     13E : 49                  	lda 	rVarPtr 													; read LSB into Param2
(1)   60/     13F : AF                  	plo 	rParam2
(1)   61/     140 : 09                  	ldn 	rVarPtr 													; and MSB
(1)   62/     141 : BF                  	phi 	rParam2
(1)   63/     142 : 30 54               	br 		__EXPRGotTerm 
(1)   64/     144 :                     ;
(1)   65/     144 :                     ;	Found an array : - same as open parenthesis except we stack a '@'
(1)   66/     144 :                     ;	
(1)   67/     144 :                     __EXPRArray:
(1)   68/     144 : F8 40               	ldi 	'@' 														; push @@@ on the stack,  the first two don't matter.
(1)   69/     146 : 73                  	stxd
(1)   70/     147 : 73                  	stxd
(1)   71/     148 : 73                  	stxd
(1)   72/     149 : 19                  	inc 	rParenthesisLevel 											; it's like bracket with a different operator.
(1)   73/     14A : 30 16               	br 		__EXPRNewTerm
(1)   74/     14C :                     ;
(1)   75/     14C :                     ;	Found a "<char>" 
(1)   76/     14C :                     ;
(1)   77/     14C :                     __EXPRGotCharacter:
(1)   78/     14C : BF                  	phi 	rParam2 													; clear high byte of rParam2.
(1)   79/     14D : 4B                  	lda 	rSrc 														; get character in quotes, skip over it
(1)   80/     14E : 32 00               	bz 		__EXPRExitDec 												; none provided, exit backing up.
(1)   81/     150 : AF                  	plo 	rParam2 													; put in rParam2.0
(1)   82/     151 : 4B                  	lda 	rSrc 														; look for what should be a quote but we dont check
(1)   83/     152 : 32 00               	bz 		__EXPRExitDec
(1)   84/     154 :                     ;
(1)   85/     154 :                     ;	New term is in rParam2. Look at the TOS expression to do, look it up and do it.
(1)   86/     154 :                     ;
(1)   87/     154 :                     __EXPRGotTerm:  														; new term is in rParam2.
(1)   88/     154 : 12                  	inc 	r2 															; point stack to operator.
(1)   89/     155 : (MACRO)             	ldr 	rParam1,__OperatorTable-1 									; rParam1 is the operator look up table.
(1)   89/     155 : F8 03                       ldi     (__OPERATORTABLE-1)/256
(1)   89/     157 : BE                          phi     RPARAM1
(1)   89/     158 : F8 01                       ldi     (__OPERATORTABLE-1)&255
(1)   89/     15A : AE                          plo     RPARAM1
(1)   90/     15B :                     __EXPRFindOperation:
(1)   91/     15B : 1E                  	inc 	rParam1
(1)   92/     15C : 4E                  	lda 	rParam1 													; look to see what it is.
(1)   93/     15D : 32 62               	bz 		__EXPRFoundOperation 										; end of table.
(1)   94/     15F : F3                  	xor 																; same as stacked operator
(1)   95/     160 : 3A 5B               	bnz 	__EXPRFindOperation 
(1)   96/     162 :                     __EXPRFoundOperation:	
(1)   97/     162 : 42                  	lda 	r2 															; load the stacked value into rParenthesisLevel.1
(1)   98/     163 : B9                  	phi 	rParenthesisLevel
(1)   99/     164 : 0E                  	ldn 	rParam1 													; put address of routine into rUtilPC
(1)  100/     165 : AC                  	plo 	rUtilPC
(1)  101/     166 : 42                  	lda 	r2 			
(1)  102/     167 : AE                  	plo 	rParam1
(1)  103/     168 : 02                  	ldn 	r2
(1)  104/     169 : BE                  	phi 	rParam1
(1)  105/     16A : 79                  	mark  																; and call the routine.
(1)  106/     16B : DC                  	sep 	rUtilPC
(1)  107/     16C : 22                  	dec 	r2
(1)  108/     16D :                     ;
(1)  109/     16D :                     ;	Having got the result, check to see if it was divide, if so write out the remainder to '%'
(1)  110/     16D :                     ;
(1)  111/     16D : 99                  	ghi 	rParenthesisLevel 											; get the operator
(1)  112/     16E : FB 2F               	xri 	'/'															; was it divide ?
(1)  113/     170 : 3A 7A               	bnz 	__EXPRNotDivide
(1)  114/     172 : F8 4A               	ldi 	'%' * 2 													; point rVarPtr to % variable
 AS V1.42 Beta [Bld 114] - source file test.asm(expression.asm) - page 4 - 10/1/2017 20:08:44


(1)  115/     174 : A9                  	plo 	rVarPtr
(1)  116/     175 : 8F                  	glo 	rParam2 													; save remainder there
(1)  117/     176 : 59                  	str 	rVarPtr
(1)  118/     177 : 9F                  	ghi 	rParam2
(1)  119/     178 : 19                  	inc 	rVarPtr
(1)  120/     179 : 59                  	str 	rVarPtr
(1)  121/     17A :                     __EXPRNotDivide:	
(1)  122/     17A :                     
(1)  123/     17A : 9E                  	ghi 	rParam1 													; push the result back on the stack.
(1)  124/     17B : 73                  	stxd
(1)  125/     17C : 8E                  	glo 	rParam1
(1)  126/     17D : 73                  	stxd
(1)  127/     17E :                     
(1)  128/     17E :                     __EXPRSkipSpace:
(1)  129/     17E : 4B                  	lda 	rSrc 														; get the next operator.
(1)  130/     17F : 32 00               	bz 		__EXPRExitDec 												; done the next operator.
(1)  131/     181 : FB 20               	xri 	' '
(1)  132/     183 : 32 7E               	bz 		__EXPRSkipSpace
(1)  133/     185 : FB 09               	xri 	')'!' '														; was it )
(1)  134/     187 : 32 8E               	bz 		__EXPRDestackBracket
(1)  135/     189 : FB 29               	xri 	')' 														; get it back
(1)  136/     18B : 73                  	stxd 																; push it on the stack.
(1)  137/     18C : 30 16               	br 		__EXPRNewTerm 												; and get the next term.
(1)  138/     18E :                     
(1)  139/     18E :                     
(1)  140/     18E :                     __EXPRDestackBracket:
(1)  141/     18E :                     	; pop rParam2 off the stack.
(1)  142/     18E :                     	; adjust and test the parenthesis level counter. ) comment
(1)  143/     18E :                     	; go back to the got-term
(1)  144/     18E :                     	; maybe have 2 byte addresses for operator functions.
(1)  145/     18E : 30 8E               	br 		__EXPRDestackBracket	
(1)  146/     190 :                     
(1)  147/     190 :                     
      46/     190 :                     
      47/     200 :                     	org 		200h
      48/     200 :                     UtilityPage:	
      49/     200 :                     	include 	utility/itoa.asm
(1)    1/     200 :                     ; ***************************************************************************************************************
(1)    2/     200 :                     ; ***************************************************************************************************************
(1)    3/     200 :                     ;
(1)    4/     200 :                     ;		File:		itoa.asm
(1)    5/     200 :                     ;		Purpose:	Convert 16 bit integer to ASCIIZ string
(1)    6/     200 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     200 :                     ;		Date:		10th January 2017.
(1)    8/     200 :                     ;		Size: 		47 bytes.
(1)    9/     200 :                     ;
(1)   10/     200 :                     ; ***************************************************************************************************************
(1)   11/     200 :                     ; ***************************************************************************************************************
(1)   12/     200 :                     
(1)   13/     200 :                     ; *******************************************************************************************************************
(1)   14/     200 :                     ;
(1)   15/     200 :                     ;	rParam1 is the number to convert. rParam2 is the end of the buffer, the digits are written backwards. On exit.
(1)   16/     200 :                     ;	rParam2 points to the string terminated in a NULL character. The NULL character is at the original value
(1)   17/     200 :                     ;	of rParam2. 
(1)   18/     200 :                     ;
(1)   19/     200 :                     ; *******************************************************************************************************************
(1)   20/     200 :                     
(1)   21/     200 :                     __ITOAExit:
(1)   22/     200 : 12                  	inc 	r2
(1)   23/     201 : (MACRO)             	return
 AS V1.42 Beta [Bld 114] - source file test.asm(itoa.asm) - page 5 - 10/1/2017 20:08:44


(1)   23/     201 : 71                          dis
(1)   24/     202 :                     
(1)   25/     202 :                     IntegerToASCII:
(1)   26/     202 : E2                  	sex 	r2 															; index back at 2
(1)   27/     203 : F8 00               	ldi 	0 															; write the NULL terminator.
(1)   28/     205 : 5F                  	str 	rParam2
(1)   29/     206 :                     __ITOALoop:
(1)   30/     206 : 73                  	stxd 																; push dummy value, digit return stored here.
(1)   31/     207 : 9F                  	ghi 	rParam2 													; push rParam2 on the stack.
(1)   32/     208 : 73                  	stxd
(1)   33/     209 : 8F                  	glo	 	rParam2
(1)   34/     20A : 73                  	stxd
(1)   35/     20B : F8 00               	ldi 	0		 													; set to divide by 10.
(1)   36/     20D : BF                  	phi 	rParam2
(1)   37/     20E : F8 0A               	ldi 	10
(1)   38/     210 : AF                  	plo 	rParam2
(1)   39/     211 : F8 02               	ldi 	Divide/256
(1)   40/     213 : BD                  	phi 	rSubPC
(1)   41/     214 : F8 58               	ldi 	Divide&255
(1)   42/     216 : AD                  	plo 	rSubPC
(1)   43/     217 : 79                  	mark  
(1)   44/     218 : DD                  	sep 	rSubPC 														; do the call.
(1)   45/     219 : 12                  	inc 	r2
(1)   46/     21A : 12                  	inc 	r2 															; save digit result in dummy space
(1)   47/     21B : 8F                  	glo 	rParam2
(1)   48/     21C : 73                  	stxd 
(1)   49/     21D : 22                  	dec 	r2 															; now points to memory pointer for result
(1)   50/     21E : 42                  	lda 	r2 															; restore buffer pointer
(1)   51/     21F : AF                  	plo 	rParam2
(1)   52/     220 : 42                  	lda 	r2
(1)   53/     221 : BF                  	phi 	rParam2
(1)   54/     222 : 02                  	ldn 	r2 															; restore digit
(1)   55/     223 : F9 30               	ori		'0'															; make ASCII 
(1)   56/     225 : 2F                  	dec 	rParam2 													; back one character.
(1)   57/     226 : 5F                  	str 	rParam2 													; write into buffer
(1)   58/     227 :                     
(1)   59/     227 : 8E                  	glo 	rParam1 													; go around again if non-zero
(1)   60/     228 : 3A 06               	bnz 	__ITOALoop
(1)   61/     22A : 9E                  	ghi 	rParam1
(1)   62/     22B : 3A 06               	bnz 	__ITOALoop
(1)   63/     22D : 30 00               	br 		__ITOAExit 													; and prepare to exit.
      50/     22F :                     	include 	utility/multiply.asm
(1)    1/     22F :                     ; ***************************************************************************************************************
(1)    2/     22F :                     ; ***************************************************************************************************************
(1)    3/     22F :                     ;
(1)    4/     22F :                     ;		File:		multiply.asm
(1)    5/     22F :                     ;		Purpose:	Multiply two 16 bit integers.
(1)    6/     22F :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     22F :                     ;		Date:		9th January 2017.
(1)    8/     22F :                     ;		Size: 		41 bytes.
(1)    9/     22F :                     ;
(1)   10/     22F :                     ; ***************************************************************************************************************
(1)   11/     22F :                     ; ***************************************************************************************************************
(1)   12/     22F :                     
(1)   13/     22F :                     ; *******************************************************************************************************************
(1)   14/     22F :                     ;
(1)   15/     22F :                     ;	Multiply the values in rParam1 and rParam2 , returning result in rParam1.
(1)   16/     22F :                     ;
(1)   17/     22F :                     ; *******************************************************************************************************************
(1)   18/     22F :                     
 AS V1.42 Beta [Bld 114] - source file test.asm(multiply.asm) - page 6 - 10/1/2017 20:08:44


(1)   19/     22F :                     __MULExit:
(1)   20/     22F : 42                  	lda 	r2 															; pop LSB result off stack.
(1)   21/     230 : AE                  	plo 	rParam1
(1)   22/     231 : 42                  	lda 	r2  														; pop MSB result off stack, do inc r2
(1)   23/     232 : BE                  	phi 	rParam1
(1)   24/     233 : (MACRO)             	return
(1)   24/     233 : 71                          dis
(1)   25/     234 :                     
(1)   26/     234 :                     Multiply:
(1)   27/     234 : E2                  	sex 	r2 															; back using R2 as the index register
(1)   28/     235 : F8 00               	ldi 	0 															; reset the result, which is on the stack.
(1)   29/     237 : 73                  	stxd	
(1)   30/     238 : 52                  	str 	r2
(1)   31/     239 :                     
(1)   32/     239 :                     __MULLoop:
(1)   33/     239 :                     
(1)   34/     239 : 9E                  	ghi 	rParam1 													; shift first multiplier right into DF
(1)   35/     23A : F6                  	shr
(1)   36/     23B : BE                  	phi 	rParam1
(1)   37/     23C : 8E                  	glo 	rParam1
(1)   38/     23D : 76                  	rshr
(1)   39/     23E : AE                  	plo 	rParam1
(1)   40/     23F : 3B 48               	bnf 	__MULDontAdd 												; if DF is set add rParam2 to the result.
(1)   41/     241 :                     
(1)   42/     241 : 8F                  	glo 	rParam2 													; add rParam2 to result on TOS.
(1)   43/     242 : F4                  	add 
(1)   44/     243 : 52                  	str 	r2
(1)   45/     244 : 12                  	inc 	r2
(1)   46/     245 : 9F                  	ghi 	rParam2
(1)   47/     246 : 74                  	adc
(1)   48/     247 : 73                  	stxd 
(1)   49/     248 :                     
(1)   50/     248 :                     __MULDontAdd:
(1)   51/     248 : 8F                  	glo 	rParam2 													; shift rParam2 left
(1)   52/     249 : FE                  	shl
(1)   53/     24A : AF                  	plo 	rParam2
(1)   54/     24B : 9F                  	ghi 	rParam2
(1)   55/     24C : 7E                  	rshl
(1)   56/     24D : BF                  	phi 	rParam2
(1)   57/     24E :                     
(1)   58/     24E : 8E                  	glo 	rParam1 													; is first multiplier non zero, if not go back.
(1)   59/     24F : 3A 39               	bnz 	__MULLoop
(1)   60/     251 : 9E                  	ghi 	rParam1
(1)   61/     252 : 3A 39               	bnz 	__MULLoop
(1)   62/     254 : 30 2F               	br 		__MULExit 													; both are zero, so exit.	
      51/     256 :                     	include 	utility/divide.asm
(1)    1/     256 :                     ; ***************************************************************************************************************
(1)    2/     256 :                     ; ***************************************************************************************************************
(1)    3/     256 :                     ;
(1)    4/     256 :                     ;		File:		divide.asm
(1)    5/     256 :                     ;		Purpose:	Divide two 16 bit integers.
(1)    6/     256 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     256 :                     ;		Date:		9th January 2017.
(1)    8/     256 :                     ;		Size: 		54 bytes.
(1)    9/     256 :                     ;
(1)   10/     256 :                     ; ***************************************************************************************************************
(1)   11/     256 :                     ; ***************************************************************************************************************
(1)   12/     256 :                     
(1)   13/     256 :                     ; *******************************************************************************************************************
(1)   14/     256 :                     ;
 AS V1.42 Beta [Bld 114] - source file test.asm(divide.asm) - page 7 - 10/1/2017 20:08:44


(1)   15/     256 :                     ;				Calculate rParam1 / rParam2.  Result in rParam1. Remainder in rParam2.
(1)   16/     256 :                     ;
(1)   17/     256 :                     ; *******************************************************************************************************************
(1)   18/     256 :                     
(1)   19/     256 :                     __DIVExit:
(1)   20/     256 : 12                  	inc 	r2 															; point to XP on the stack
(1)   21/     257 : (MACRO)             	return
(1)   21/     257 : 71                          dis
(1)   22/     258 :                     
(1)   23/     258 :                     Divide:
(1)   24/     258 : E2                  	sex 	r2 															; back using R2 as the index register
(1)   25/     259 :                     																		; rParam1 is the dividend.
(1)   26/     259 :                     																		; rParam2 is the remainder.
(1)   27/     259 :                     																		; tos is [divisor:2][counter:1] 
(1)   28/     259 :                     
(1)   29/     259 : F8 10               	ldi 	16															; push counter on stack - 16 because post	
(1)   30/     25B : 73                  	stxd 																; decrements in main loop.
(1)   31/     25C :                     
(1)   32/     25C : 9F                  	ghi 	rParam2 													; push divisor on stack.
(1)   33/     25D : 73                  	stxd
(1)   34/     25E : 8F                  	glo 	rParam2
(1)   35/     25F : 52                  	str 	r2 	
(1)   36/     260 :                     	
(1)   37/     260 : F8 00               	ldi 	0 															; clear the remainder
(1)   38/     262 : BF                  	phi 	rParam2
(1)   39/     263 : AF                  	plo 	rParam2
(1)   40/     264 : F4                  	add 																; anything + 0 clears DF.
(1)   41/     265 :                     
(1)   42/     265 :                     __DIVLoopIncR2IncR2:
(1)   43/     265 : 12                  	inc		r2 															; point R2 back to the counter.
(1)   44/     266 :                     __DIVLoopIncR2:
(1)   45/     266 : 12                  	inc 	r2
(1)   46/     267 :                     
(1)   47/     267 :                     __DIVLoop:
(1)   48/     267 :                     
(1)   49/     267 : 8E                  	glo 	rParam1 													; shift DF into dividend, shift old bit 15 to DF
(1)   50/     268 : 7E                  	rshl
(1)   51/     269 : AE                  	plo 	rParam1
(1)   52/     26A : 9E                  	ghi 	rParam1
(1)   53/     26B : 7E                  	rshl
(1)   54/     26C : BE                  	phi 	rParam1
(1)   55/     26D :                     
(1)   56/     26D : 02                  	ldn 	r2 															; look at counter.
(1)   57/     26E : 32 56               	bz 		__DIVExit 													; if zero then complete (decrement done later)
(1)   58/     270 :                     
(1)   59/     270 : 8F                  	glo	 	rParam2 													; shift DF into then remainder (rParam2)
(1)   60/     271 : 7E                  	rshl
(1)   61/     272 : AF                  	plo 	rParam2
(1)   62/     273 : 9F                  	ghi 	rParam2
(1)   63/     274 : 7E                  	rshl
(1)   64/     275 : BF                  	phi 	rParam2
(1)   65/     276 :                     
(1)   66/     276 : 02                  	ldn 	r2 															; decrement the counter (AFTER the test)
(1)   67/     277 : FF 01               	smi 	1
(1)   68/     279 : 73                  	stxd 																; when saving back, point R2 to divisor LSB.
(1)   69/     27A : 22                  	dec 	r2
(1)   70/     27B :                     
(1)   71/     27B : 8F                  	glo 	rParam2 													; calculate remainder.0 - divisor.0
(1)   72/     27C : F7                  	sm
(1)   73/     27D : 22                  	dec 	r2 															; save the interim value below the LSB.
 AS V1.42 Beta [Bld 114] - source file test.asm(divide.asm) - page 8 - 10/1/2017 20:08:44


(1)   74/     27E : 52                  	str 	r2
(1)   75/     27F : 12                  	inc 	r2 															; to LSB
(1)   76/     280 : 12                  	inc		r2 															; to MSB
(1)   77/     281 : 9F                  	ghi 	rParam2 													; calculate remainder.1 - divisor.1
(1)   78/     282 : 77                  	smb
(1)   79/     283 :                     
(1)   80/     283 : 3B 66               	bnf 	__DIVLoopIncR2 												; if DF = 0 then inc r2 (to ctr) and loop back
(1)   81/     285 :                     
(1)   82/     285 : BF                  	phi 	rParam2 													; copy result to remainder
(1)   83/     286 : 22                  	dec 	r2 															; to divisor.0
(1)   84/     287 : 22                  	dec 	r2 															; to temp result
(1)   85/     288 : 42                  	lda 	r2 															; get temp result, to divisor.0
(1)   86/     289 : AF                  	plo 	rParam2
(1)   87/     28A : 30 65               	br 		__DIVLoopIncR2IncR2 										; go back, inc r2 twice to counter
(1)   88/     28C :                     
      52/     28C :                     	include 	utility/atoi.asm
(1)    1/     28C :                     ; ***************************************************************************************************************
(1)    2/     28C :                     ; ***************************************************************************************************************
(1)    3/     28C :                     ;
(1)    4/     28C :                     ;		File:		atoi.asm
(1)    5/     28C :                     ;		Purpose:	Extract 16 bit integer from ASCII string.
(1)    6/     28C :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     28C :                     ;		Date:		9th January 2017.
(1)    8/     28C :                     ;		Size: 		67 bytes.
(1)    9/     28C :                     ;
(1)   10/     28C :                     ; ***************************************************************************************************************
(1)   11/     28C :                     ; ***************************************************************************************************************
(1)   12/     28C :                     
(1)   13/     28C :                     ; *******************************************************************************************************************
(1)   14/     28C :                     ;
(1)   15/     28C :                     ;	Takes one value in rParam1, pointer to a string, returns number read in rParam2.
(1)   16/     28C :                     ;	rParam1 points to the next character after the last one of the number.	
(1)   17/     28C :                     ;	
(1)   18/     28C :                     ;	On exit non-zero if a digit was read.
(1)   19/     28C :                     ;
(1)   20/     28C :                     ; *******************************************************************************************************************
(1)   21/     28C :                     
(1)   22/     28C :                     __ATOIExit:
(1)   23/     28C : 2E                  	dec 	rParam1 													; undo the last read, wasn't a digit.
(1)   24/     28D : 42                  	lda 	r2 															; read the flag for 'digits read'
(1)   25/     28E : (MACRO)             	return
(1)   25/     28E : 71                          dis
(1)   26/     28F :                     
(1)   27/     28F :                     ASCIIToInteger:
(1)   28/     28F : E2                  	sex 	r2 															; index back at 2
(1)   29/     290 : F8 00               	ldi 	0 															; clear number read
(1)   30/     292 : AF                  	plo 	rParam2
(1)   31/     293 : BF                  	phi 	rParam2
(1)   32/     294 : 52                  	str 	r2 															; [TOS] is count of digits read okay.
(1)   33/     295 :                     
(1)   34/     295 :                     __ATOILoop:
(1)   35/     295 : 4E                  	lda 	rParam1 													; read next character and bump
(1)   36/     296 : FB 20               	xri 	' ' 														; skip over spaces.
(1)   37/     298 : 32 95               	bz 		__ATOILoop 												
(1)   38/     29A : FB 20               	xri 	' ' 														; fix it back.
(1)   39/     29C : FC C6               	adi 	255-'9' 													; will cause DF if >= '9'
(1)   40/     29E : 33 8C               	bdf 	__ATOIExit
(1)   41/     2A0 : FC 0A               	adi 	10 															; adding 10 will cause NF if < '0'	
(1)   42/     2A2 : 3B 8C               	bnf 	__ATOIExit
(1)   43/     2A4 :                     
 AS V1.42 Beta [Bld 114] - source file test.asm(atoi.asm) - page 9 - 10/1/2017 20:08:44


(1)   44/     2A4 : 73                  	stxd 																; push digit value, current value of number
(1)   45/     2A5 : 9F                  	ghi 	rParam2  													; on stack.
(1)   46/     2A6 : 73                  	stxd
(1)   47/     2A7 : 8F                  	glo 	rParam2
(1)   48/     2A8 : 52                  	str 	r2
(1)   49/     2A9 :                     
(1)   50/     2A9 :                     __ATOIDoubleRParam2 macro 												; macro that doubles the value in rParam2
(1)   51/     2A9 :                     	glo 	rParam2 													
(1)   52/     2A9 :                     	shl
(1)   53/     2A9 :                     	plo 	rParam2
(1)   54/     2A9 :                     	ghi 	rParam2
(1)   55/     2A9 :                     	rshl
(1)   56/     2A9 :                     	phi 	rParam2
(1)   57/     2A9 :                     	endm
(1)   58/     2A9 :                     
(1)   59/     2A9 : (MACRO)             	__ATOIDoubleRParam2 												; rParam2 * 2
(1)   59/     2A9 : 8F                          glo     rParam2                                                                                                         
(1)   59/     2AA : FE                          shl
(1)   59/     2AB : AF                          plo     rParam2
(1)   59/     2AC : 9F                          ghi     rParam2
(1)   59/     2AD : 7E                          rshl
(1)   59/     2AE : BF                          phi     rParam2
(1)   60/     2AF : (MACRO)             	__ATOIDoubleRParam2 												; rParam2 * 4
(1)   60/     2AF : 8F                          glo     rParam2                                                                                                         
(1)   60/     2B0 : FE                          shl
(1)   60/     2B1 : AF                          plo     rParam2
(1)   60/     2B2 : 9F                          ghi     rParam2
(1)   60/     2B3 : 7E                          rshl
(1)   60/     2B4 : BF                          phi     rParam2
(1)   61/     2B5 : 8F                  	glo 	rParam2 													; add stack values on there.
(1)   62/     2B6 : F4                  	add
(1)   63/     2B7 : AF                  	plo 	rParam2
(1)   64/     2B8 : 12                  	inc 	r2
(1)   65/     2B9 : 9F                  	ghi 	rParam2
(1)   66/     2BA : 74                  	adc
(1)   67/     2BB : BF                  	phi 	rParam2  													; so now rParam * 5
(1)   68/     2BC : (MACRO)             	__ATOIDoubleRParam2 												; so now rParam * 10
(1)   68/     2BC : 8F                          glo     rParam2                                                                                                         
(1)   68/     2BD : FE                          shl
(1)   68/     2BE : AF                          plo     rParam2
(1)   68/     2BF : 9F                          ghi     rParam2
(1)   68/     2C0 : 7E                          rshl
(1)   68/     2C1 : BF                          phi     rParam2
(1)   69/     2C2 :                     
(1)   70/     2C2 : 12                  	inc 	r2 															; point to digit value
(1)   71/     2C3 : 8F                  	glo 	rParam2
(1)   72/     2C4 : F4                  	add
(1)   73/     2C5 : AF                  	plo 	rParam2
(1)   74/     2C6 : 9F                  	ghi 	rParam2
(1)   75/     2C7 : 7C 00               	adci 	0
(1)   76/     2C9 : BF                  	phi 	rParam2
(1)   77/     2CA :                     
(1)   78/     2CA : F8 FF               	ldi 	0FFh 														; set the 'read a digit' flag.
(1)   79/     2CC : 52                  	str 	r2 
(1)   80/     2CD : 30 95               	br 		__ATOILoop
(1)   81/     2CF :                     
      53/     2CF :                     
      54/     2CF :                     
      55/     2CF :                     __OpAdd:
      56/     2CF : E2                  	sex		r2 														; rParam1 := rParam1 + rParam2
 AS V1.42 Beta [Bld 114] - source file test.asm - page 10 - 10/1/2017 20:08:44


      57/     2D0 : 8F                  	glo 	rParam2
      58/     2D1 : 52                  	str 	r2
      59/     2D2 : 8E                  	glo 	rParam1
      60/     2D3 : F4                  	add	
      61/     2D4 : AE                  	plo 	rParam1
      62/     2D5 : 9F                  	ghi 	rParam2
      63/     2D6 : 52                  	str 	r2
      64/     2D7 : 9E                  	ghi 	rParam1
      65/     2D8 : 74                  	adc
      66/     2D9 : BE                  	phi 	rParam1
      67/     2DA : 12                  	inc 	r2
      68/     2DB : (MACRO)             	return
      68/     2DB : 71                          dis
      69/     2DC :                     
      70/     2DC :                     __OpSub:															; rParam1 := rParam1 - rParam2
      71/     2DC : E2                  	sex		r2
      72/     2DD : 8F                  	glo 	rParam2
      73/     2DE : 52                  	str 	r2
      74/     2DF : 8E                  	glo 	rParam1
      75/     2E0 : F7                  	sm
      76/     2E1 : AE                  	plo 	rParam1
      77/     2E2 : 9F                  	ghi 	rParam2
      78/     2E3 : 52                  	str 	r2
      79/     2E4 : 9E                  	ghi 	rParam1
      80/     2E5 : 77                  	smb
      81/     2E6 : BE                  	phi 	rParam1
      82/     2E7 : 12                  	inc 	r2
      83/     2E8 : (MACRO)             	return
      83/     2E8 : 71                          dis
      84/     2E9 :                     
      85/     2E9 :                     __OpLookUp: 														; rParam1 := Memory[* + rParam2 * 2]
      86/     2E9 : E2                  	sex 	r2
      87/     2EA : 8F                  	glo 	rParam2 												; double rParam2
      88/     2EB : FE                  	shl
      89/     2EC : AF                  	plo 	rParam2
      90/     2ED : 9F                  	ghi 	rParam2
      91/     2EE : 7E                  	rshl
      92/     2EF : BF                  	phi 	rParam2
      93/     2F0 : F8 54               	ldi 	'*' * 2 												; point VarPtr to '*' variable
      94/     2F2 : A9                  	plo 	rVarPtr
      95/     2F3 : E9                  	sex 	rVarPtr
      96/     2F4 :                     
      97/     2F4 : 8F                  	glo 	rParam2 												; add * to rParam2 
      98/     2F5 : F4                  	add
      99/     2F6 : AF                  	plo 	rParam2		
     100/     2F7 : 19                  	inc 	rVarPtr
     101/     2F8 : 9F                  	ghi 	rParam2
     102/     2F9 : 74                  	adc
     103/     2FA : BF                  	phi 	rParam2 
     104/     2FB :                     
     105/     2FB : 4F                  	lda 	rParam2 												; read rParam2 into rParam1
     106/     2FC : AE                  	plo 	rParam1
     107/     2FD : 0F                  	ldn 	rParam2
     108/     2FE : BE                  	phi 	rParam1
     109/     2FF : E2                  	sex 	r2
     110/     300 : 12                  	inc 	r2
     111/     301 : (MACRO)             	return
     111/     301 : 71                          dis
     112/     302 :                     
     113/     302 :                     oper macro chdb,addr
 AS V1.42 Beta [Bld 114] - source file test.asm - page 11 - 10/1/2017 20:08:44


     114/     302 :                     	db 		chdb,addr & 255
     115/     302 :                     	endm 
     116/     302 :                     
     117/     302 :                     __OperatorTable:
     118/     302 : (MACRO)             	oper 		'+',__OpAdd 
     118/     302 : 2B CF                       db              '+',__OPADD & 255
     119/     304 : (MACRO)             	oper		'*',Multiply
     119/     304 : 2A 34                       db              '*',MULTIPLY & 255
     120/     306 : (MACRO)             	oper 		'/',Divide
     120/     306 : 2F 58                       db              '/',DIVIDE & 255
     121/     308 : (MACRO)             	oper 		'@',__OpLookUp 
     121/     308 : 40 E9                       db              '@',__OPLOOKUP & 255
     122/     30A : (MACRO)             	oper 		0,__OpSub
     122/     30A : 00 DC                       db              0,__OPSUB & 255
     123/     30C :                     
     124/     30C :                     eString:
     125/     30C : 31 2B 28 32 2A 33   	db 		"1+(2*3)",0
                    29 00 
     126/     314 :                     
 AS V1.42 Beta [Bld 114] - source file test.asm - page 12 - 10/1/2017 20:08:44


  symbol table (* = unused):
  ------------------------

*ARCHITECTURE :                                        x86_64-unknown-linux - |
 ASCIITOINTEGER :               28F C | *BIGENDIAN :                      0 - |
*BRANCHEXT :                      0 - | *BUFFER :                        20 C |
*CASESENSITIVE :                  0 - | *CONSTPI :        3.141592653589793 - |
*DATE :                   10/1/2017 - |  DIVIDE :                       258 C |
 ESTRING :                      30C C |  EXPREVALUATE :                 107 C |
*FALSE :                          0 - | *FULLPMMU :                       1 - |
*HAS64 :                          1 - | *HASDSP :                         0 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
*INEXTMODE :                      0 - | *INLWORDMODE :                    0 - |
*INMAXMODE :                      0 - | *INSRCMODE :                      0 - |
*INSUPMODE :                      0 - | *INTEGERTOASCII :               202 C |
*LISTON :                         1 - | *MACEXP :                         1 - |
*MOMCPU :                      1802 - | *MOMCPUNAME :                  1802 - |
 MULTIPLY :                     234 C | *NESTMAX :                      100 - |
*PACKING :                        0 - | *PADDING :                        1 - |
*R0 :                             0 - | *R1 :                             1 - |
 R2 :                             2 - | *RELAXED :                        0 - |
 REXPRPC :                        A - |  RPARAM1 :                        E - |
 RPARAM2 :                        F - |  RPARENTHESISLEVEL :              9 - |
 RSRC :                           B - |  RSUBPC :                         D - |
 RUTILPC :                        C - |  RVARPTR :                        9 - |
*TIME :                    20:08:44 - | *TRUE :                           1 - |
 UTILITYPAGE :                  200 C | *VERSION :                     142F - |
 WAIT :                          1E C |  __ATOIEXIT :                   28C C |
 __ATOILOOP :                   295 C |  __DIVEXIT :                    256 C |
*__DIVLOOP :                    267 C |  __DIVLOOPINCR2 :               266 C |
 __DIVLOOPINCR2INCR2 :          265 C |  __EXPRARRAY :                  144 C |
 __EXPRDESTACKBRACKET :         18E C | *__EXPREXIT :                   101 C |
 __EXPREXITDEC :                100 C |  __EXPRFINDOPERATION :          15B C |
 __EXPRFOUNDOPERATION :         162 C |  __EXPRGOTCHARACTER :           14C C |
 __EXPRGOTTERM :                154 C |  __EXPRNEWLEVEL :               10E C |
 __EXPRNEWTERM :                116 C |  __EXPRNOTDIVIDE :              17A C |
 __EXPRSKIPSPACE :              17E C |  __ITOAEXIT :                   200 C |
 __ITOALOOP :                   206 C |  __MULDONTADD :                 248 C |
 __MULEXIT :                    22F C |  __MULLOOP :                    239 C |
 __OPADD :                      2CF C |  __OPERATORTABLE :              302 C |
 __OPLOOKUP :                   2E9 C |  __OPSUB :                      2DC C |

     75 symbols
     34 unused symbols

 AS V1.42 Beta [Bld 114] - source file test.asm - page 13 - 10/1/2017 20:08:44


  defined macros:
  ---------------

LDR                                   | OPER                                 
RETURN                                | __ATOIDOUBLERPARAM2                  

      4 macros

 AS V1.42 Beta [Bld 114] - source file test.asm - page 14 - 10/1/2017 20:08:44


  codepages:
  ----------

STANDARD (0 changed characters)


0.00 seconds assembly time

    567 lines source file
    618 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
