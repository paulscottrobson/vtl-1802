 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 1 - 15/1/2017 18:19:44


       1/       0 :                     ; ***************************************************************************************************************
       2/       0 :                     ; ***************************************************************************************************************
       3/       0 :                     ;
       4/       0 :                     ;		File:		vtl2.asm
       5/       0 :                     ;		Purpose:	Main Program.
       6/       0 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
       7/       0 :                     ;		Date:		14th January 2017.
       8/       0 :                     ;
       9/       0 :                     ; ***************************************************************************************************************
      10/       0 :                     ; ***************************************************************************************************************
      11/       0 :                     
      12/       0 :                     	cpu 	1802 														; obviously !
      13/       0 :                     	
      14/       0 : =0H                 r0 = 0 																	; not used (may be used in interrupt display)
      15/       0 : =1H                 r1 = 1 																	; interrupt register
      16/       0 : =2H                 r2 = 2 																	; stack pointer
      17/       0 : =3H                 r3 = 3 																	; general run P
      18/       0 :                     
      19/       0 : =6H                 rVarPtr = 6 															; always points to variables (64 variables 2 bytes each 6 bit ASCII)
      20/       0 : =7H                 rExprPC = 7 															; used as P register in expression (mandated)
      21/       0 : =8H                 rSrc = 8 																; source code.
      22/       0 : =9H                 rSpecialHandler = 9 													; special variables handler.
      23/       0 : =AH                 rParenthesisLevel = 10 													; bracket level (low byte)
      24/       0 : =BH                 rSaveStack = 11 														; original value of stack pointer
      25/       0 :                     
      26/       0 : =CH                 rUtilPC = 12 															; used as P register calling routines (not mandated)
      27/       0 : =DH                 rSubPC = 13																; used as P register to call routines within routines
      28/       0 : =EH                 rParam1 = 14 															; subroutine parameters/return values.
      29/       0 : =FH                 rParam2 = 15
      30/       0 :                     
      31/       0 :                     return macro 															; allows subroutine returns to disable/enable interrupts as you want.
      32/       0 :                     	dis 																; this program uses MARK-subroutines
      33/       0 :                     	endm
      34/       0 :                     
      35/       0 :                     lrx macro 	r,n 														; load 16 bit value into register macro
      36/       0 :                     	ldi 	(n)/256
      37/       0 :                     	phi 	r
      38/       0 :                     	ldi 	(n)&255
      39/       0 :                     	plo 	r
      40/       0 :                     	endm
      41/       0 :                     
      42/       0 :                     ; ***************************************************************************************************************
      43/       0 :                     ;
      44/       0 :                     ;													Start up 1802
      45/       0 :                     ;
      46/       0 :                     ; ***************************************************************************************************************
      47/       0 :                     
      48/       0 : (MACRO)             	return 																; enable/disable interrupts, switch to R3.
      48/       0 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
      49/       1 : 00                  	db 		000h
      50/       2 : (MACRO)             	lrx 	r3,Initialise 												; jump to start.
      50/       2 : F8 03                       ldi     (INITIALISE)/256
      50/       4 : B3                          phi     R3
      50/       5 : F8 00                       ldi     (INITIALISE)&255
      50/       7 : A3                          plo     R3
      51/       8 : D3                  	sep 	r3
      52/       9 :                     
      53/       9 :                     	include expression.asm 												; expression evaluator, all arithmetic, atoi/itoa
(1)    1/       9 :                     ; ***************************************************************************************************************
(1)    2/       9 :                     ; ***************************************************************************************************************
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 2 - 15/1/2017 18:19:44


(1)    3/       9 :                     ;
(1)    4/       9 :                     ;		File:		expression.asm
(1)    5/       9 :                     ;		Purpose:	Evaluate an ASCII expression.
(1)    6/       9 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/       9 :                     ;		Date:		11th January 2017.
(1)    8/       9 :                     ;
(1)    9/       9 :                     ; ***************************************************************************************************************
(1)   10/       9 :                     ; ***************************************************************************************************************
(1)   11/       9 :                     
(1)   12/       9 :                     ; ***************************************************************************************************************
(1)   13/       9 :                     ;
(1)   14/       9 :                     ;	Expression Evaluator : L -> R evaluation with parenthesis.
(1)   15/       9 :                     ;
(1)   16/       9 :                     ;	rSrc 			points to ASCIIZ expression, next character on exit. 
(1)   17/       9 :                     ;	rExprPC 		runs in this R(P), this is mandatory.
(1)   18/       9 :                     ;	rVarPtr.1 		points to variables
(1)   19/       9 :                     ; 	rParam1 		returned value of expression.
(1)   20/       9 :                     ;	rSpecialHandler	Routine (ends with sep rExprPC) which processes the provided character for special values
(1)   21/       9 :                     ;					e.g. side effect variables like ?. Char in D, zeroes D if the character is found and processed,
(1)   22/       9 :                     ;					in which case the result should be in rParam2
(1)   23/       9 :                     ;
(1)   24/       9 :                     ;	This does not report errors. VTL-2 does not. So if you have an error then the result returned may be somewhat
(1)   25/       9 :                     ;	unexpected and should not be relied on, despite what the VTL-2 manual hints :)
(1)   26/       9 :                     ;
(1)   27/       9 :                     ;	Note this routine breaks most of the registers R6-R15. If this is called recursively it must still run in
(1)   28/       9 :                     ;	rExprPC and the original rExprPC,rSrc,rParenthesisLevel and rSaveStack must be saved. rVarPtr does not change
(1)   29/       9 :                     ;	but must be restored if changed by an external routine.
(1)   30/       9 :                     ;
(1)   31/       9 :                     ;	The routine is designed to occupy two complete pages. At present there are about 16 bytes free at the end of
(1)   32/       9 :                     ;	each page allowing for bug fixing, if the first page is preceded by the preamble (dis ; loading r3 ; sep r3)
(1)   33/       9 :                     ;
(1)   34/       9 :                     ; ***************************************************************************************************************
(1)   35/       9 :                     
(1)   36/       9 :                     __EXPRExitDec:
(1)   37/       9 : 28                  	dec 	rSrc 														; unpick bad source gets
(1)   38/       A :                     __EXPRExit:
(1)   39/       A : 8B                  	glo 	rSaveStack 													; because we don't handle errors properly we 
(1)   40/       B : A2                  	plo 	r2 															; may have incomplete operations on exit.
(1)   41/       C : 9B                  	ghi 	rSaveStack 													; (VTL-2 does not report expression syntax errors)
(1)   42/       D : B2                  	phi 	r2
(1)   43/       E : 22                  	dec 	r2 															; load top most expression which is the answer
(1)   44/       F : 42                  	lda 	r2 															; if it actually worked.
(1)   45/      10 : AE                  	plo 	rParam1
(1)   46/      11 : 42                  	lda 	r2
(1)   47/      12 : BE                  	phi 	rParam1
(1)   48/      13 : (MACRO)             	return
(1)   48/      13 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)   49/      14 :                     
(1)   50/      14 :                     EXPREvaluate:
(1)   51/      14 : E2                  	sex 	r2 															; using X = 2 again
(1)   52/      15 : F8 00               	ldi 	0 															; clear parenthesis level to 0.
(1)   53/      17 : AA                  	plo 	rParenthesisLevel 
(1)   54/      18 :                     
(1)   55/      18 : 82                  	glo	 	r2 															; save original stack position
(1)   56/      19 : AB                  	plo 	rSaveStack
(1)   57/      1A : 92                  	ghi 	r2
(1)   58/      1B : BB                  	phi 	rSaveStack 
(1)   59/      1C :                     
(1)   60/      1C :                     __EXPRNewLevel:	
(1)   61/      1C : F8 00               	ldi 	0 															; push $0000  + on the stack.
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 3 - 15/1/2017 18:19:44


(1)   62/      1E : 73                  	stxd 																; MSB first
(1)   63/      1F : 73                  	stxd 																; LSB
(1)   64/      20 : F8 2B               	ldi 	'+' 												 		; the put '+' on the stack as pending operation.
(1)   65/      22 : 73                  	stxd
(1)   66/      23 : 1A                  	inc 	rParenthesisLevel 											; bump the parenthesis level up 1.
(1)   67/      24 :                     ;
(1)   68/      24 :                     ;		On reaching this point, we are looking for a new Term.
(1)   69/      24 :                     ;
(1)   70/      24 :                     __EXPRNewTerm:
(1)   71/      24 : 88                  	glo 	rSrc 														; put rSrc into rParam1
(1)   72/      25 : AE                  	plo 	rParam1
(1)   73/      26 : 98                  	ghi 	rSrc
(1)   74/      27 : BE                  	phi 	rParam1
(1)   75/      28 :                     
(1)   76/      28 : (MACRO)             	lrx 	rUtilPC,ASCIIToInteger 										; call the atoi() routine.
(1)   76/      28 : F8 01                       ldi     (ASCIITOINTEGER)/256
(1)   76/      2A : BC                          phi     RUTILPC
(1)   76/      2B : F8 B0                       ldi     (ASCIITOINTEGER)&255
(1)   76/      2D : AC                          plo     RUTILPC
(1)   77/      2E : 79                  	mark
(1)   78/      2F : DC                  	sep 	rUtilPC
(1)   79/      30 : 22                  	dec 	r2 		
(1)   80/      31 :                     
(1)   81/      31 : FC FF               	adi 	0FFh 														; sets DF if non zero value returned
(1)   82/      33 : 8E                  	glo 	rParam1 													; constant rParam1 back into rSrc
(1)   83/      34 : A8                  	plo 	rSrc
(1)   84/      35 : 9E                  	ghi 	rParam1
(1)   85/      36 : B8                  	phi 	rSrc
(1)   86/      37 : 33 67               	bdf 	__EXPRGotTerm 												; if constant then done.
(1)   87/      39 :                     
(1)   88/      39 : 48                  	lda 	rSrc 														; look at character.
(1)   89/      3A : 32 09               	bz 		__EXPRExitDec 												; none provided.
(1)   90/      3C : FB 22               	xri 	'"'															; is it quote mark
(1)   91/      3E : 32 5F               	bz 		__EXPRGotCharacter 											; if so do that handler.
(1)   92/      40 : FB 0A               	xri	 	'('!'"' 													; is it open parenthesis.
(1)   93/      42 : 32 1C               	bz		__EXPRNewLevel 												; if so open new level.
(1)   94/      44 : FB 12               	xri 	':'!'('														; is it new array ?
(1)   95/      46 : 32 57               	bz 		__EXPRArray
(1)   96/      48 : FB 3A               	xri 	':' 														; so make it back to the correct character.
(1)   97/      4A : D9                  	sep 	rSpecialHandler 											; check for 'special ones'
(1)   98/      4B : 32 67               	bz 		__EXPRGotTerm 												; if found one, we've got a term.
(1)   99/      4D :                     
(1)  100/      4D : FA 3F               	ani 	03Fh 														; convert to six bit ASCII.
(1)  101/      4F : FE                  	shl 																; byte size to word size
(1)  102/      50 : A6                  	plo 	rVarPtr 													; now point to variable
(1)  103/      51 : 46                  	lda 	rVarPtr 													; read LSB into Param2
(1)  104/      52 : AF                  	plo 	rParam2
(1)  105/      53 : 06                  	ldn 	rVarPtr 													; and MSB
(1)  106/      54 : BF                  	phi 	rParam2
(1)  107/      55 : 30 67               	br 		__EXPRGotTerm 
(1)  108/      57 :                     ;
(1)  109/      57 :                     ;	Found an array : - same as open parenthesis except we stack a '@'
(1)  110/      57 :                     ;	
(1)  111/      57 :                     __EXPRArray:
(1)  112/      57 : F8 40               	ldi 	'@' 														; push @@@ on the stack,  the first two don't matter.
(1)  113/      59 : 73                  	stxd
(1)  114/      5A : 73                  	stxd
(1)  115/      5B : 73                  	stxd
(1)  116/      5C : 1A                  	inc 	rParenthesisLevel 											; it's like bracket with a different operator.
(1)  117/      5D : 30 24               	br 		__EXPRNewTerm
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 4 - 15/1/2017 18:19:44


(1)  118/      5F :                     ;
(1)  119/      5F :                     ;	Found a "<char>" 
(1)  120/      5F :                     ;
(1)  121/      5F :                     __EXPRGotCharacter:
(1)  122/      5F : BF                  	phi 	rParam2 													; clear high byte of rParam2.
(1)  123/      60 : 48                  	lda 	rSrc 														; get character in quotes, skip over it
(1)  124/      61 : 32 09               	bz 		__EXPRExitDec 												; none provided, exit backing up.
(1)  125/      63 : AF                  	plo 	rParam2 													; put in rParam2.0
(1)  126/      64 : 48                  	lda 	rSrc 														; look for what should be a quote but we dont check
(1)  127/      65 : 32 09               	bz 		__EXPRExitDec
(1)  128/      67 :                     ;
(1)  129/      67 :                     ;	New term is in rParam2. Look at the TOS expression to do, look it up and do it.
(1)  130/      67 :                     ;
(1)  131/      67 :                     __EXPRGotTerm:  														; new term is in rParam2.
(1)  132/      67 : 12                  	inc 	r2 															; point stack to operator.
(1)  133/      68 : (MACRO)             	lrx 	rParam1,(__OperatorTable-2) 								; rParam1 is the operator look up table.
(1)  133/      68 : F8 00                       ldi     ((__OPERATORTABLE-2))/256
(1)  133/      6A : BE                          phi     RPARAM1
(1)  133/      6B : F8 AD                       ldi     ((__OPERATORTABLE-2))&255
(1)  133/      6D : AE                          plo     RPARAM1
(1)  134/      6E :                     __EXPRFindOperation:
(1)  135/      6E : 1E                  	inc 	rParam1
(1)  136/      6F : 1E                  	inc 	rParam1
(1)  137/      70 : 4E                  	lda 	rParam1 													; look to see what it is.
(1)  138/      71 : 32 76               	bz 		__EXPRFoundOperation 										; end of table.
(1)  139/      73 : F3                  	xor 																; same as stacked operator
(1)  140/      74 : 3A 6E               	bnz 	__EXPRFindOperation 
(1)  141/      76 :                     __EXPRFoundOperation:	
(1)  142/      76 : 42                  	lda 	r2 															; load the stacked value into rParenthesisLevel.1
(1)  143/      77 : BA                  	phi 	rParenthesisLevel
(1)  144/      78 : 4E                  	lda 	rParam1 													; put address of routine into rUtilPC
(1)  145/      79 : AC                  	plo 	rUtilPC
(1)  146/      7A : 0E                  	ldn 	rParam1
(1)  147/      7B : BC                  	phi 	rUtilPC
(1)  148/      7C :                     
(1)  149/      7C : 42                  	lda 	r2 															; read TOS for into param1
(1)  150/      7D : AE                  	plo 	rParam1
(1)  151/      7E : 02                  	ldn 	r2
(1)  152/      7F : BE                  	phi 	rParam1
(1)  153/      80 : 79                  	mark  																; and call the routine.
(1)  154/      81 : DC                  	sep 	rUtilPC
(1)  155/      82 : 22                  	dec 	r2
(1)  156/      83 :                     
(1)  157/      83 :                     ;
(1)  158/      83 :                     ;	Having got the result, check to see if it was divide, if so write out the remainder to '%'
(1)  159/      83 :                     ;
(1)  160/      83 : 9A                  	ghi 	rParenthesisLevel 											; get the operator
(1)  161/      84 : FB 2F               	xri 	'/'															; was it divide ?
(1)  162/      86 : 3A 90               	bnz 	__EXPRNotDivide
(1)  163/      88 : F8 4A               	ldi 	('%' & 03Fh) * 2 											; point rVarPtr to % variable
(1)  164/      8A : A6                  	plo 	rVarPtr
(1)  165/      8B : 8F                  	glo 	rParam2 													; save remainder there
(1)  166/      8C : 56                  	str 	rVarPtr
(1)  167/      8D : 9F                  	ghi 	rParam2
(1)  168/      8E : 16                  	inc 	rVarPtr
(1)  169/      8F : 56                  	str 	rVarPtr
(1)  170/      90 :                     __EXPRNotDivide:	
(1)  171/      90 :                     
(1)  172/      90 : 9E                  	ghi 	rParam1 													; push the result back on the stack.
(1)  173/      91 : 73                  	stxd
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 5 - 15/1/2017 18:19:44


(1)  174/      92 : 8E                  	glo 	rParam1
(1)  175/      93 : 73                  	stxd
(1)  176/      94 :                     ;
(1)  177/      94 :                     ;	Get the next operation, this is normally stacked, except if ) in which case the bracketed operation is closed
(1)  178/      94 :                     ;
(1)  179/      94 :                     __EXPRSkipSpace:
(1)  180/      94 : 48                  	lda 	rSrc 														; get the next operator.
(1)  181/      95 : 32 09               	bz 		__EXPRExitDec 												; done the next operator.
(1)  182/      97 : FB 20               	xri 	' '
(1)  183/      99 : 32 94               	bz 		__EXPRSkipSpace
(1)  184/      9B : FB 09               	xri 	')'!' '														; was it )
(1)  185/      9D : 32 A4               	bz 		__EXPRDestackBracket
(1)  186/      9F : FB 29               	xri 	')' 														; get it back
(1)  187/      A1 : 73                  	stxd 																; push it on the stack.
(1)  188/      A2 : 30 24               	br 		__EXPRNewTerm 												; and get the next term.
(1)  189/      A4 :                     ;
(1)  190/      A4 :                     ; 	Close the bracketed operation
(1)  191/      A4 :                     ;
(1)  192/      A4 :                     __EXPRDestackBracket:
(1)  193/      A4 : 2A                  	dec 	rParenthesisLevel 											; dec brackets
(1)  194/      A5 : 8A                  	glo 	rParenthesisLevel 											; if zero it is end of expression ) so exit.	
(1)  195/      A6 : 32 0A               	bz 		__EXPRExit
(1)  196/      A8 :                     
(1)  197/      A8 : 12                  	inc 	r2 															; pop rParam2 off the stack.
(1)  198/      A9 : 42                  	lda 	r2
(1)  199/      AA : AF                  	plo 	rParam2
(1)  200/      AB : 02                  	ldn 	r2
(1)  201/      AC : BF                  	phi 	rParam2
(1)  202/      AD :                     
(1)  203/      AD : 30 67               	br 		__EXPRGotTerm 												; go back and do the stacked operation below
(1)  204/      AF :                     
(1)  205/      AF :                     ; ***************************************************************************************************************
(1)  206/      AF :                     ;
(1)  207/      AF :                     ;	Look up table for binary operators. 0 signifies the end of the table and default, so it covers - > < =
(1)  208/      AF :                     ;
(1)  209/      AF :                     ; ***************************************************************************************************************
(1)  210/      AF :                     
(1)  211/      AF :                     oper macro chdb,addr
(1)  212/      AF :                     	db 		chdb,(addr) & 255,(addr) / 256
(1)  213/      AF :                     	endm 
(1)  214/      AF :                     
(1)  215/      AF :                     __OperatorTable:
(1)  216/      AF : (MACRO)             	oper 	'+',__OpAdd 
(1)  216/      AF : 2B 00 01                    db              '+',(__OPADD) & 255,(__OPADD) / 256
(1)  217/      B2 : (MACRO)             	oper	'*',Multiply
(1)  217/      B2 : 2A 8B 01                    db              '*',(MULTIPLY) & 255,(MULTIPLY) / 256
(1)  218/      B5 : (MACRO)             	oper 	'/',Divide
(1)  218/      B5 : 2F C0 00                    db              '/',(DIVIDE) & 255,(DIVIDE) / 256
(1)  219/      B8 : (MACRO)             	oper 	'@',__OpLookUp 
(1)  219/      B8 : 40 0D 01                    db              '@',(__OPLOOKUP) & 255,(__OPLOOKUP) / 256
(1)  220/      BB : (MACRO)             	oper 	0,__OpSub
(1)  220/      BB : 00 26 01                    db              0,(__OPSUB) & 255,(__OPSUB) / 256
(1)  221/      BE :                     
(1)  222/      BE :                     ; ***************************************************************************************************************
(1)  223/      BE :                     ;
(1)  224/      BE :                     ;										Divide Code here
(1)  225/      BE :                     ;
(1)  226/      BE :                     ; ***************************************************************************************************************
(1)  227/      BE :                     
(1)  228/      BE :                     	include utility/divide.asm
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(divide.asm) - page 6 - 15/1/2017 18:19:44


(2)    1/      BE :                     ; ***************************************************************************************************************
(2)    2/      BE :                     ; ***************************************************************************************************************
(2)    3/      BE :                     ;
(2)    4/      BE :                     ;		File:		divide.asm
(2)    5/      BE :                     ;		Purpose:	Divide two 16 bit integers.
(2)    6/      BE :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(2)    7/      BE :                     ;		Date:		9th January 2017.
(2)    8/      BE :                     ;		Size: 		54 bytes.
(2)    9/      BE :                     ;
(2)   10/      BE :                     ; ***************************************************************************************************************
(2)   11/      BE :                     ; ***************************************************************************************************************
(2)   12/      BE :                     
(2)   13/      BE :                     ; *******************************************************************************************************************
(2)   14/      BE :                     ;
(2)   15/      BE :                     ;				Calculate rParam1 / rParam2.  Result in rParam1. Remainder in rParam2.
(2)   16/      BE :                     ;
(2)   17/      BE :                     ; *******************************************************************************************************************
(2)   18/      BE :                     
(2)   19/      BE :                     __DIVExit:
(2)   20/      BE : 12                  	inc 	r2 															; point to XP on the stack
(2)   21/      BF : (MACRO)             	return
(2)   21/      BF : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(2)   22/      C0 :                     
(2)   23/      C0 :                     Divide:
(2)   24/      C0 : E2                  	sex 	r2 															; back using R2 as the index register
(2)   25/      C1 :                     																		; rParam1 is the dividend.
(2)   26/      C1 :                     																		; rParam2 is the remainder.
(2)   27/      C1 :                     																		; tos is [divisor:2][counter:1] 
(2)   28/      C1 :                     
(2)   29/      C1 : F8 10               	ldi 	16															; push counter on stack - 16 because post	
(2)   30/      C3 : 73                  	stxd 																; decrements in main loop.
(2)   31/      C4 :                     
(2)   32/      C4 : 9F                  	ghi 	rParam2 													; push divisor on stack.
(2)   33/      C5 : 73                  	stxd
(2)   34/      C6 : 8F                  	glo 	rParam2
(2)   35/      C7 : 52                  	str 	r2 	
(2)   36/      C8 :                     	
(2)   37/      C8 : F8 00               	ldi 	0 															; clear the remainder
(2)   38/      CA : BF                  	phi 	rParam2
(2)   39/      CB : AF                  	plo 	rParam2
(2)   40/      CC : F4                  	add 																; anything + 0 clears DF.
(2)   41/      CD :                     
(2)   42/      CD :                     __DIVLoopIncR2IncR2:
(2)   43/      CD : 12                  	inc		r2 															; point R2 back to the counter.
(2)   44/      CE :                     __DIVLoopIncR2:
(2)   45/      CE : 12                  	inc 	r2
(2)   46/      CF :                     
(2)   47/      CF :                     __DIVLoop:
(2)   48/      CF :                     
(2)   49/      CF : 8E                  	glo 	rParam1 													; shift DF into dividend, shift old bit 15 to DF
(2)   50/      D0 : 7E                  	rshl
(2)   51/      D1 : AE                  	plo 	rParam1
(2)   52/      D2 : 9E                  	ghi 	rParam1
(2)   53/      D3 : 7E                  	rshl
(2)   54/      D4 : BE                  	phi 	rParam1
(2)   55/      D5 :                     
(2)   56/      D5 : 02                  	ldn 	r2 															; look at counter.
(2)   57/      D6 : 32 BE               	bz 		__DIVExit 													; if zero then complete (decrement done later)
(2)   58/      D8 :                     
(2)   59/      D8 : 8F                  	glo	 	rParam2 													; shift DF into then remainder (rParam2)
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(divide.asm) - page 7 - 15/1/2017 18:19:44


(2)   60/      D9 : 7E                  	rshl
(2)   61/      DA : AF                  	plo 	rParam2
(2)   62/      DB : 9F                  	ghi 	rParam2
(2)   63/      DC : 7E                  	rshl
(2)   64/      DD : BF                  	phi 	rParam2
(2)   65/      DE :                     
(2)   66/      DE : 02                  	ldn 	r2 															; decrement the counter (AFTER the test)
(2)   67/      DF : FF 01               	smi 	1
(2)   68/      E1 : 73                  	stxd 																; when saving back, point R2 to divisor LSB.
(2)   69/      E2 : 22                  	dec 	r2
(2)   70/      E3 :                     
(2)   71/      E3 : 8F                  	glo 	rParam2 													; calculate remainder.0 - divisor.0
(2)   72/      E4 : F7                  	sm
(2)   73/      E5 : 22                  	dec 	r2 															; save the interim value below the LSB.
(2)   74/      E6 : 52                  	str 	r2
(2)   75/      E7 : 12                  	inc 	r2 															; to LSB
(2)   76/      E8 : 12                  	inc		r2 															; to MSB
(2)   77/      E9 : 9F                  	ghi 	rParam2 													; calculate remainder.1 - divisor.1
(2)   78/      EA : 77                  	smb
(2)   79/      EB :                     
(2)   80/      EB : 3B CE               	bnf 	__DIVLoopIncR2 												; if DF = 0 then inc r2 (to ctr) and loop back
(2)   81/      ED :                     
(2)   82/      ED : BF                  	phi 	rParam2 													; copy result to remainder
(2)   83/      EE : 22                  	dec 	r2 															; to divisor.0
(2)   84/      EF : 22                  	dec 	r2 															; to temp result
(2)   85/      F0 : 42                  	lda 	r2 															; get temp result, to divisor.0
(2)   86/      F1 : AF                  	plo 	rParam2
(2)   87/      F2 : 30 CD               	br 		__DIVLoopIncR2IncR2 										; go back, inc r2 twice to counter
(2)   88/      F4 :                     
(1)  229/      F4 :                     	align 	256
(1)  230/     100 :                     	
(1)  231/     100 :                     ; ***************************************************************************************************************
(1)  232/     100 :                     ;
(1)  233/     100 :                     ;								Addition. rParam1 := rParam1 + rParam2
(1)  234/     100 :                     ;
(1)  235/     100 :                     ; ***************************************************************************************************************
(1)  236/     100 :                     
(1)  237/     100 :                     __OpAdd:
(1)  238/     100 : E2                  	sex		r2 														; rParam1 := rParam1 + rParam2
(1)  239/     101 : 8F                  	glo 	rParam2
(1)  240/     102 : 52                  	str 	r2
(1)  241/     103 : 8E                  	glo 	rParam1
(1)  242/     104 : F4                  	add	
(1)  243/     105 : AE                  	plo 	rParam1
(1)  244/     106 : 9F                  	ghi 	rParam2
(1)  245/     107 : 52                  	str 	r2
(1)  246/     108 : 9E                  	ghi 	rParam1
(1)  247/     109 : 74                  	adc
(1)  248/     10A : BE                  	phi 	rParam1
(1)  249/     10B : 12                  	inc 	r2
(1)  250/     10C : (MACRO)             	return
(1)  250/     10C : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)  251/     10D :                     
(1)  252/     10D :                     ; ***************************************************************************************************************
(1)  253/     10D :                     ;
(1)  254/     10D :                     ;				Array Lookup. rParam1 := Memory['&' + rParam * 2]. '*' is the top of memory variable.
(1)  255/     10D :                     ;
(1)  256/     10D :                     ; ***************************************************************************************************************
(1)  257/     10D :                     
(1)  258/     10D :                     __OpLookUp: 														; rParam1 := Memory[& + rParam2 * 2]
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 8 - 15/1/2017 18:19:44


(1)  259/     10D : E2                  	sex 	r2
(1)  260/     10E : 8F                  	glo 	rParam2 												; double rParam2
(1)  261/     10F : FE                  	shl
(1)  262/     110 : AF                  	plo 	rParam2
(1)  263/     111 : 9F                  	ghi 	rParam2
(1)  264/     112 : 7E                  	rshl
(1)  265/     113 : BF                  	phi 	rParam2
(1)  266/     114 : F8 4C               	ldi 	('&' & 03Fh) * 2 										; point VarPtr to '&' variable
(1)  267/     116 : A6                  	plo 	rVarPtr
(1)  268/     117 : E6                  	sex 	rVarPtr
(1)  269/     118 :                     
(1)  270/     118 : 8F                  	glo 	rParam2 												; add contents of & to rParam2 
(1)  271/     119 : F4                  	add
(1)  272/     11A : AF                  	plo 	rParam2		
(1)  273/     11B : 16                  	inc 	rVarPtr
(1)  274/     11C : 9F                  	ghi 	rParam2
(1)  275/     11D : 74                  	adc
(1)  276/     11E : BF                  	phi 	rParam2 
(1)  277/     11F :                     
(1)  278/     11F : 4F                  	lda 	rParam2 												; read rParam2 into rParam1
(1)  279/     120 : AE                  	plo 	rParam1
(1)  280/     121 : 0F                  	ldn 	rParam2
(1)  281/     122 : BE                  	phi 	rParam1
(1)  282/     123 :                     __OpReturn:	
(1)  283/     123 : E2                  	sex 	r2
(1)  284/     124 : 12                  	inc 	r2
(1)  285/     125 : (MACRO)             	return
(1)  285/     125 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)  286/     126 :                     
(1)  287/     126 :                     ; ***************************************************************************************************************
(1)  288/     126 :                     ;
(1)  289/     126 :                     ;								Subtraction. rParam1 := rParam1 - rParam2
(1)  290/     126 :                     ;									 (Also > < = which return 0 or 1)
(1)  291/     126 :                     ;
(1)  292/     126 :                     ; ***************************************************************************************************************
(1)  293/     126 :                     
(1)  294/     126 :                     __OpSub:															; rParam1 := rParam1 - rParam2
(1)  295/     126 : E2                  	sex		r2
(1)  296/     127 : 8F                  	glo 	rParam2
(1)  297/     128 : 52                  	str 	r2
(1)  298/     129 : 8E                  	glo 	rParam1
(1)  299/     12A : F7                  	sm
(1)  300/     12B : AE                  	plo 	rParam1
(1)  301/     12C : 9F                  	ghi 	rParam2
(1)  302/     12D : 52                  	str 	r2
(1)  303/     12E : 9E                  	ghi 	rParam1
(1)  304/     12F : 77                  	smb
(1)  305/     130 : BE                  	phi 	rParam1
(1)  306/     131 :                     
(1)  307/     131 : 9A                  	ghi 	rParenthesisLevel 										; this is the saved operator character
(1)  308/     132 : FB 2D               	xri 	'-'														; exit if '-'
(1)  309/     134 : 32 23               	bz 		__OpReturn
(1)  310/     136 : FB 10               	xri 	'-'!'='													; check if equals.
(1)  311/     138 : 32 47               	bz 		__OpEquality
(1)  312/     13A :                     ;
(1)  313/     13A :                     ;	Handle < > option. Note that > is actually the >= operation and is also the overall default.
(1)  314/     13A :                     ;
(1)  315/     13A : FB 03               	xri 	'>'!'='													; will now be 0 if >= , nonzero for < if anything else.
(1)  316/     13C : 32 40               	bz 		__OpLT0 	
(1)  317/     13E : F8 01               	ldi 	1
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 9 - 15/1/2017 18:19:44


(1)  318/     140 :                     __OpLT0: 															; now 0 if >, 1 if <
(1)  319/     140 : 7C 00               	adci 	0 														; will now be odd if correct - adds in result from subtract
(1)  320/     142 : FA 01               	ani 	1 														; so isolate bit zero
(1)  321/     144 : 30 51               	br 		__OpWriteBoolean 										; and write it out.
(1)  322/     146 :                     
(1)  323/     146 : (MACRO)             	return
(1)  323/     146 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)  324/     147 :                     ;
(1)  325/     147 :                     ;	Handle = option
(1)  326/     147 :                     ;
(1)  327/     147 :                     __OpEquality:
(1)  328/     147 : 8E                  	glo 	rParam1 												; get low result
(1)  329/     148 : 3A 4B               	bnz 	__OpEqNZ 	
(1)  330/     14A : 9E                  	ghi 	rParam1 												; if zero get high result
(1)  331/     14B :                     __OpEqNZ:															; if zero here both are zero e.g. it is 'true'
(1)  332/     14B : 32 4F               	bz 		__OpEqIsTrue 											
(1)  333/     14D : F8 01               	ldi 	1 															
(1)  334/     14F :                     __OpEqIsTrue:														; now 0 true 1 false
(1)  335/     14F : FB 01               	xri 	1 														; now 1 true 0 false
(1)  336/     151 :                     __OpWriteBoolean:	
(1)  337/     151 : AE                  	plo 	rParam1 												; put into rParam1
(1)  338/     152 : F8 00               	ldi 	0
(1)  339/     154 : BE                  	phi 	rParam1 							
(1)  340/     155 : 30 23               	br 		__OpReturn
(1)  341/     157 :                     
(1)  342/     157 :                     ; ***************************************************************************************************************
(1)  343/     157 :                     ;
(1)  344/     157 :                     ;										Outstanding utility routines fit here
(1)  345/     157 :                     ;
(1)  346/     157 :                     ; ***************************************************************************************************************
(1)  347/     157 :                     
(1)  348/     157 :                     	include utility/itoa.asm
(2)    1/     157 :                     ; ***************************************************************************************************************
(2)    2/     157 :                     ; ***************************************************************************************************************
(2)    3/     157 :                     ;
(2)    4/     157 :                     ;		File:		itoa.asm
(2)    5/     157 :                     ;		Purpose:	Convert 16 bit integer to ASCIIZ string
(2)    6/     157 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(2)    7/     157 :                     ;		Date:		10th January 2017.
(2)    8/     157 :                     ;		Size: 		47 bytes.
(2)    9/     157 :                     ;
(2)   10/     157 :                     ; ***************************************************************************************************************
(2)   11/     157 :                     ; ***************************************************************************************************************
(2)   12/     157 :                     
(2)   13/     157 :                     ; *******************************************************************************************************************
(2)   14/     157 :                     ;
(2)   15/     157 :                     ;	rParam1 is the number to convert. rParam2 is the end of the buffer, the digits are written backwards. On exit.
(2)   16/     157 :                     ;	rParam2 points to the string terminated in a NULL character. The NULL character is at the original value
(2)   17/     157 :                     ;	of rParam2. 
(2)   18/     157 :                     ;
(2)   19/     157 :                     ; *******************************************************************************************************************
(2)   20/     157 :                     
(2)   21/     157 :                     __ITOAExit:
(2)   22/     157 : 12                  	inc 	r2
(2)   23/     158 : (MACRO)             	return
(2)   23/     158 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(2)   24/     159 :                     
(2)   25/     159 :                     IntegerToASCII:
(2)   26/     159 : E2                  	sex 	r2 															; index back at 2
(2)   27/     15A : F8 00               	ldi 	0 															; write the NULL terminator.
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(itoa.asm) - page 10 - 15/1/2017 18:19:44


(2)   28/     15C : 5F                  	str 	rParam2
(2)   29/     15D :                     __ITOALoop:
(2)   30/     15D : 73                  	stxd 																; push dummy value, digit return stored here.
(2)   31/     15E : 9F                  	ghi 	rParam2 													; push rParam2 on the stack.
(2)   32/     15F : 73                  	stxd
(2)   33/     160 : 8F                  	glo	 	rParam2
(2)   34/     161 : 73                  	stxd
(2)   35/     162 : F8 00               	ldi 	0		 													; set to divide by 10.
(2)   36/     164 : BF                  	phi 	rParam2
(2)   37/     165 : F8 0A               	ldi 	10
(2)   38/     167 : AF                  	plo 	rParam2
(2)   39/     168 : F8 00               	ldi 	Divide/256
(2)   40/     16A : BD                  	phi 	rSubPC
(2)   41/     16B : F8 C0               	ldi 	Divide&255
(2)   42/     16D : AD                  	plo 	rSubPC
(2)   43/     16E : 79                  	mark  
(2)   44/     16F : DD                  	sep 	rSubPC 														; do the call.
(2)   45/     170 : 12                  	inc 	r2
(2)   46/     171 : 12                  	inc 	r2 															; save digit result in dummy space
(2)   47/     172 : 8F                  	glo 	rParam2
(2)   48/     173 : 73                  	stxd 
(2)   49/     174 : 22                  	dec 	r2 															; now points to memory pointer for result
(2)   50/     175 : 42                  	lda 	r2 															; restore buffer pointer
(2)   51/     176 : AF                  	plo 	rParam2
(2)   52/     177 : 42                  	lda 	r2
(2)   53/     178 : BF                  	phi 	rParam2
(2)   54/     179 : 02                  	ldn 	r2 															; restore digit
(2)   55/     17A : F9 30               	ori		'0'															; make ASCII 
(2)   56/     17C : 2F                  	dec 	rParam2 													; back one character.
(2)   57/     17D : 5F                  	str 	rParam2 													; write into buffer
(2)   58/     17E :                     
(2)   59/     17E : 8E                  	glo 	rParam1 													; go around again if non-zero
(2)   60/     17F : 3A 5D               	bnz 	__ITOALoop
(2)   61/     181 : 9E                  	ghi 	rParam1
(2)   62/     182 : 3A 5D               	bnz 	__ITOALoop
(2)   63/     184 : 30 57               	br 		__ITOAExit 													; and prepare to exit.
(1)  349/     186 :                     	include utility/multiply.asm
(2)    1/     186 :                     ; ***************************************************************************************************************
(2)    2/     186 :                     ; ***************************************************************************************************************
(2)    3/     186 :                     ;
(2)    4/     186 :                     ;		File:		multiply.asm
(2)    5/     186 :                     ;		Purpose:	Multiply two 16 bit integers.
(2)    6/     186 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(2)    7/     186 :                     ;		Date:		9th January 2017.
(2)    8/     186 :                     ;		Size: 		41 bytes.
(2)    9/     186 :                     ;
(2)   10/     186 :                     ; ***************************************************************************************************************
(2)   11/     186 :                     ; ***************************************************************************************************************
(2)   12/     186 :                     
(2)   13/     186 :                     ; *******************************************************************************************************************
(2)   14/     186 :                     ;
(2)   15/     186 :                     ;	Multiply the values in rParam1 and rParam2 , returning result in rParam1.
(2)   16/     186 :                     ;
(2)   17/     186 :                     ; *******************************************************************************************************************
(2)   18/     186 :                     
(2)   19/     186 :                     __MULExit:
(2)   20/     186 : 42                  	lda 	r2 															; pop LSB result off stack.
(2)   21/     187 : AE                  	plo 	rParam1
(2)   22/     188 : 42                  	lda 	r2  														; pop MSB result off stack, do inc r2
(2)   23/     189 : BE                  	phi 	rParam1
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(multiply.asm) - page 11 - 15/1/2017 18:19:44


(2)   24/     18A : (MACRO)             	return
(2)   24/     18A : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(2)   25/     18B :                     
(2)   26/     18B :                     Multiply:
(2)   27/     18B : E2                  	sex 	r2 															; back using R2 as the index register
(2)   28/     18C : F8 00               	ldi 	0 															; reset the result, which is on the stack.
(2)   29/     18E : 73                  	stxd	
(2)   30/     18F : 52                  	str 	r2
(2)   31/     190 :                     
(2)   32/     190 :                     __MULLoop:
(2)   33/     190 :                     
(2)   34/     190 : 9E                  	ghi 	rParam1 													; shift first multiplier right into DF
(2)   35/     191 : F6                  	shr
(2)   36/     192 : BE                  	phi 	rParam1
(2)   37/     193 : 8E                  	glo 	rParam1
(2)   38/     194 : 76                  	rshr
(2)   39/     195 : AE                  	plo 	rParam1
(2)   40/     196 : 3B 9F               	bnf 	__MULDontAdd 												; if DF is set add rParam2 to the result.
(2)   41/     198 :                     
(2)   42/     198 : 8F                  	glo 	rParam2 													; add rParam2 to result on TOS.
(2)   43/     199 : F4                  	add 
(2)   44/     19A : 52                  	str 	r2
(2)   45/     19B : 12                  	inc 	r2
(2)   46/     19C : 9F                  	ghi 	rParam2
(2)   47/     19D : 74                  	adc
(2)   48/     19E : 73                  	stxd 
(2)   49/     19F :                     
(2)   50/     19F :                     __MULDontAdd:
(2)   51/     19F : 8F                  	glo 	rParam2 													; shift rParam2 left
(2)   52/     1A0 : FE                  	shl
(2)   53/     1A1 : AF                  	plo 	rParam2
(2)   54/     1A2 : 9F                  	ghi 	rParam2
(2)   55/     1A3 : 7E                  	rshl
(2)   56/     1A4 : BF                  	phi 	rParam2
(2)   57/     1A5 :                     
(2)   58/     1A5 : 8E                  	glo 	rParam1 													; is first multiplier non zero, if not go back.
(2)   59/     1A6 : 3A 90               	bnz 	__MULLoop
(2)   60/     1A8 : 9E                  	ghi 	rParam1
(2)   61/     1A9 : 3A 90               	bnz 	__MULLoop
(2)   62/     1AB : 30 86               	br 		__MULExit 													; both are zero, so exit.	
(1)  350/     1AD :                     	include utility/atoi.asm
(2)    1/     1AD :                     ; ***************************************************************************************************************
(2)    2/     1AD :                     ; ***************************************************************************************************************
(2)    3/     1AD :                     ;
(2)    4/     1AD :                     ;		File:		atoi.asm
(2)    5/     1AD :                     ;		Purpose:	Extract 16 bit integer from ASCII string.
(2)    6/     1AD :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(2)    7/     1AD :                     ;		Date:		9th January 2017.
(2)    8/     1AD :                     ;		Size: 		67 bytes.
(2)    9/     1AD :                     ;
(2)   10/     1AD :                     ; ***************************************************************************************************************
(2)   11/     1AD :                     ; ***************************************************************************************************************
(2)   12/     1AD :                     
(2)   13/     1AD :                     ; *******************************************************************************************************************
(2)   14/     1AD :                     ;
(2)   15/     1AD :                     ;	Takes one value in rParam1, pointer to a string, returns number read in rParam2.
(2)   16/     1AD :                     ;	rParam1 points to the next character after the last one of the number.	
(2)   17/     1AD :                     ;	
(2)   18/     1AD :                     ;	On exit non-zero if a digit was read.
(2)   19/     1AD :                     ;
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(atoi.asm) - page 12 - 15/1/2017 18:19:44


(2)   20/     1AD :                     ; *******************************************************************************************************************
(2)   21/     1AD :                     
(2)   22/     1AD :                     __ATOIExit:
(2)   23/     1AD : 2E                  	dec 	rParam1 													; undo the last read, wasn't a digit.
(2)   24/     1AE : 42                  	lda 	r2 															; read the flag for 'digits read'
(2)   25/     1AF : (MACRO)             	return
(2)   25/     1AF : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(2)   26/     1B0 :                     
(2)   27/     1B0 :                     ASCIIToInteger:
(2)   28/     1B0 : E2                  	sex 	r2 															; index back at 2
(2)   29/     1B1 : F8 00               	ldi 	0 															; clear number read
(2)   30/     1B3 : AF                  	plo 	rParam2
(2)   31/     1B4 : BF                  	phi 	rParam2
(2)   32/     1B5 : 52                  	str 	r2 															; [TOS] is count of digits read okay.
(2)   33/     1B6 :                     
(2)   34/     1B6 :                     __ATOILoop:
(2)   35/     1B6 : 4E                  	lda 	rParam1 													; read next character and bump
(2)   36/     1B7 : FB 20               	xri 	' ' 														; skip over spaces.
(2)   37/     1B9 : 32 B6               	bz 		__ATOILoop 												
(2)   38/     1BB : FB 20               	xri 	' ' 														; fix it back.
(2)   39/     1BD : FC C6               	adi 	255-'9' 													; will cause DF if >= '9'
(2)   40/     1BF : 33 AD               	bdf 	__ATOIExit
(2)   41/     1C1 : FC 0A               	adi 	10 															; adding 10 will cause NF if < '0'	
(2)   42/     1C3 : 3B AD               	bnf 	__ATOIExit
(2)   43/     1C5 :                     
(2)   44/     1C5 : 73                  	stxd 																; push digit value, current value of number
(2)   45/     1C6 : 9F                  	ghi 	rParam2  													; on stack.
(2)   46/     1C7 : 73                  	stxd
(2)   47/     1C8 : 8F                  	glo 	rParam2
(2)   48/     1C9 : 52                  	str 	r2
(2)   49/     1CA :                     
(2)   50/     1CA :                     __ATOIDoubleRParam2 macro 												; macro that doubles the value in rParam2
(2)   51/     1CA :                     	glo 	rParam2 													
(2)   52/     1CA :                     	shl
(2)   53/     1CA :                     	plo 	rParam2
(2)   54/     1CA :                     	ghi 	rParam2
(2)   55/     1CA :                     	rshl
(2)   56/     1CA :                     	phi 	rParam2
(2)   57/     1CA :                     	endm
(2)   58/     1CA :                     
(2)   59/     1CA : (MACRO)             	__ATOIDoubleRParam2 												; rParam2 * 2
(2)   59/     1CA : 8F                          glo     rParam2                                                                                                         
(2)   59/     1CB : FE                          shl
(2)   59/     1CC : AF                          plo     rParam2
(2)   59/     1CD : 9F                          ghi     rParam2
(2)   59/     1CE : 7E                          rshl
(2)   59/     1CF : BF                          phi     rParam2
(2)   60/     1D0 : (MACRO)             	__ATOIDoubleRParam2 												; rParam2 * 4
(2)   60/     1D0 : 8F                          glo     rParam2                                                                                                         
(2)   60/     1D1 : FE                          shl
(2)   60/     1D2 : AF                          plo     rParam2
(2)   60/     1D3 : 9F                          ghi     rParam2
(2)   60/     1D4 : 7E                          rshl
(2)   60/     1D5 : BF                          phi     rParam2
(2)   61/     1D6 : 8F                  	glo 	rParam2 													; add stack values on there.
(2)   62/     1D7 : F4                  	add
(2)   63/     1D8 : AF                  	plo 	rParam2
(2)   64/     1D9 : 12                  	inc 	r2
(2)   65/     1DA : 9F                  	ghi 	rParam2
(2)   66/     1DB : 74                  	adc
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(atoi.asm) - page 13 - 15/1/2017 18:19:44


(2)   67/     1DC : BF                  	phi 	rParam2  													; so now rParam * 5
(2)   68/     1DD : (MACRO)             	__ATOIDoubleRParam2 												; so now rParam * 10
(2)   68/     1DD : 8F                          glo     rParam2                                                                                                         
(2)   68/     1DE : FE                          shl
(2)   68/     1DF : AF                          plo     rParam2
(2)   68/     1E0 : 9F                          ghi     rParam2
(2)   68/     1E1 : 7E                          rshl
(2)   68/     1E2 : BF                          phi     rParam2
(2)   69/     1E3 :                     
(2)   70/     1E3 : 12                  	inc 	r2 															; point to digit value
(2)   71/     1E4 : 8F                  	glo 	rParam2
(2)   72/     1E5 : F4                  	add
(2)   73/     1E6 : AF                  	plo 	rParam2
(2)   74/     1E7 : 9F                  	ghi 	rParam2
(2)   75/     1E8 : 7C 00               	adci 	0
(2)   76/     1EA : BF                  	phi 	rParam2
(2)   77/     1EB :                     
(2)   78/     1EB : F8 FF               	ldi 	0FFh 														; set the 'read a digit' flag.
(2)   79/     1ED : 52                  	str 	r2 
(2)   80/     1EE : 30 B6               	br 		__ATOILoop
(2)   81/     1F0 :                     
(1)  351/     1F0 :                     
      54/     1F0 :                     
      55/     1F0 :                     	align 	256 
      56/     200 :                     	include handler.asm 												; special routine handler.
(1)    1/     200 :                     ; ***************************************************************************************************************
(1)    2/     200 :                     ; ***************************************************************************************************************
(1)    3/     200 :                     ;
(1)    4/     200 :                     ;		File:		handler.asm
(1)    5/     200 :                     ;		Purpose:	Handle side-effect variables on read.
(1)    6/     200 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     200 :                     ;		Date:		11th January 2017.
(1)    8/     200 :                     ;
(1)    9/     200 :                     ; ***************************************************************************************************************
(1)   10/     200 :                     ; ***************************************************************************************************************
(1)   11/     200 :                     
(1)   12/     200 :                     ; ***************************************************************************************************************
(1)   13/     200 :                     ;
(1)   14/     200 :                     ;		This routine provides the variable in D. On exit, if D = 0 the "variable" has been accessed and
(1)   15/     200 :                     ;		put in rParam2. Otherwise D should be unchanged.
(1)   16/     200 :                     ;
(1)   17/     200 :                     ;		The right hand variables with side effects in VTL-2 are :-
(1)   18/     200 :                     ;
(1)   19/     200 :                     ;		?	input an integer (technically an expression .....)
(1)   20/     200 :                     ; 		$ 	input a single character
(1)   21/     200 :                     ;
(1)   22/     200 :                     ;		This is run with P = rSpecialHandler X = 2
(1)   23/     200 :                     ;
(1)   24/     200 :                     ;		Must preserve: rSrc, rVarPtr*, rExprPC, rParenthesisLevel, rSaveStack and of course R2.
(1)   25/     200 :                     ;
(1)   26/     200 :                     ;		* can be assumed constant.
(1)   27/     200 :                     ;
(1)   28/     200 :                     ;		Use: rUtilPC, rSubPC, rParam1, rParam2.
(1)   29/     200 :                     ;
(1)   30/     200 :                     ; ***************************************************************************************************************
(1)   31/     200 :                     
(1)   32/     200 :                     __SHExit:
(1)   33/     200 : D7                  	sep 	rExprPC
(1)   34/     201 :                     SpecialHandler:
(1)   35/     201 : FB 24               	xri 	'$'															; check if '$' (get character)
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(handler.asm) - page 14 - 15/1/2017 18:19:44


(1)   36/     203 : 32 0D               	bz 		__SHGetKey
(1)   37/     205 : FB 1B               	xri 	'$'!'?'														; check if '?' (get string expression)
(1)   38/     207 : 32 1C               	bz 		__SHInput
(1)   39/     209 : FB 3F               	xri 	'?'
(1)   40/     20B : 30 00               	br 		__SHExit
(1)   41/     20D :                     
(1)   42/     20D :                     ; ***************************************************************************************************************
(1)   43/     20D :                     ;
(1)   44/     20D :                     ;							$ operator. Returns a single key press in rParam2
(1)   45/     20D :                     ;
(1)   46/     20D :                     ; ***************************************************************************************************************
(1)   47/     20D :                     
(1)   48/     20D :                     __SHGetKey:
(1)   49/     20D : (MACRO)             	lrx 	rUtilPC,XIOGetKey 											; this is the external function which reads the keyboard
(1)   49/     20D : F8 04                       ldi     (XIOGETKEY)/256
(1)   49/     20F : BC                          phi     RUTILPC
(1)   49/     210 : F8 01                       ldi     (XIOGETKEY)&255
(1)   49/     212 : AC                          plo     RUTILPC
(1)   50/     213 : 79                  	mark 																; and it is called using the MARK method. 
(1)   51/     214 : DC                  	sep 	rUtilPC
(1)   52/     215 : 22                  	dec 	r2
(1)   53/     216 : AF                  	plo 	rParam2 													; put result in rParam2.0
(1)   54/     217 : F8 00               	ldi 	0 															; clear rParam2.1 and D, indicating successful processing.
(1)   55/     219 : BF                  	phi 	rParam2
(1)   56/     21A : 30 00               	br 		__SHExit 													; and exit.
(1)   57/     21C :                     
(1)   58/     21C :                     ; ***************************************************************************************************************
(1)   59/     21C :                     ;
(1)   60/     21C :                     ;							? operator. Inputs a string, evaluates it and returns.
(1)   61/     21C :                     ;
(1)   62/     21C :                     ; ***************************************************************************************************************
(1)   63/     21C :                     
(1)   64/     21C :                     __SHInput:
(1)   65/     21C : (MACRO)             	lrx 	rSubPC,XIOWriteCharacter 									; prompt.
(1)   65/     21C : F8 04                       ldi     (XIOWRITECHARACTER)/256
(1)   65/     21E : BD                          phi     RSUBPC
(1)   65/     21F : F8 09                       ldi     (XIOWRITECHARACTER)&255
(1)   65/     221 : AD                          plo     RSUBPC
(1)   66/     222 : F8 3F               	ldi 	'?'
(1)   67/     224 : 79                  	mark
(1)   68/     225 : DD                  	sep 	rSubPC
(1)   69/     226 : 22                  	dec 	r2
(1)   70/     227 :                     
(1)   71/     227 : (MACRO)             	lrx 	rUtilPC,READLine 											; read line into input buffer.
(1)   71/     227 : F8 02                       ldi     (READLINE)/256
(1)   71/     229 : BC                          phi     RUTILPC
(1)   71/     22A : F8 3F                       ldi     (READLINE)&255
(1)   71/     22C : AC                          plo     RUTILPC
(1)   72/     22D : 79                  	mark 																; returns it in rParam1
(1)   73/     22E : DC                  	sep 	rUtilPC 
(1)   74/     22F : 22                  	dec 	r2
(1)   75/     230 :                     
(1)   76/     230 : (MACRO)             	lrx 	rUtilPC,ASCIIToInteger										; convert to number
(1)   76/     230 : F8 01                       ldi     (ASCIITOINTEGER)/256
(1)   76/     232 : BC                          phi     RUTILPC
(1)   76/     233 : F8 B0                       ldi     (ASCIITOINTEGER)&255
(1)   76/     235 : AC                          plo     RUTILPC
(1)   77/     236 : 79                  	mark 																; and do so.
(1)   78/     237 : DC                  	sep 	rUtilPC
(1)   79/     238 : 22                  	dec 	r2
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(handler.asm) - page 15 - 15/1/2017 18:19:44


(1)   80/     239 : 32 1C               	bz 		__SHInput
(1)   81/     23B :                     
(1)   82/     23B : F8 00               	ldi 	0  															; and exit with D = 0 indicating done.
(1)   83/     23D : 30 00               	br 		__SHExit 
(1)   84/     23F :                     
(1)   85/     23F :                     
      57/     23F :                     	include readline.asm 												; line input routine.
(1)    1/     23F :                     ; ***************************************************************************************************************
(1)    2/     23F :                     ; ***************************************************************************************************************
(1)    3/     23F :                     ;
(1)    4/     23F :                     ;		File:		readline.asm
(1)    5/     23F :                     ;		Purpose:	Read an input line
(1)    6/     23F :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     23F :                     ;		Date:		14th January 2017.
(1)    8/     23F :                     ;
(1)    9/     23F :                     ; ***************************************************************************************************************
(1)   10/     23F :                     ; ***************************************************************************************************************
(1)   11/     23F :                     
(1)   12/     23F :                     ; ***************************************************************************************************************
(1)   13/     23F :                     ;
(1)   14/     23F :                     ;						Read Line in from Keyboard, returns address in rParam1
(1)   15/     23F :                     ;
(1)   16/     23F :                     ; ***************************************************************************************************************
(1)   17/     23F :                     
(1)   18/     23F :                     READLine:
(1)   19/     23F : F8 7F               	ldi 	7Fh 														; set up rParam1 to point to the string.
(1)   20/     241 : AE                  	plo 	rParam1
(1)   21/     242 : 96                  	ghi 	rVarPtr
(1)   22/     243 : BE                  	phi 	rParam1
(1)   23/     244 :                     
(1)   24/     244 :                     __RLLNextCharacter:
(1)   25/     244 : 1E                  	inc 	rParam1
(1)   26/     245 :                     __RLLLoop:
(1)   27/     245 : E2                  	sex 	r2 															; use R2 as index
(1)   28/     246 : (MACRO)             	lrx 	rSubPC,XIOGetKey 											; call get key routine.
(1)   28/     246 : F8 04                       ldi     (XIOGETKEY)/256
(1)   28/     248 : BD                          phi     RSUBPC
(1)   28/     249 : F8 01                       ldi     (XIOGETKEY)&255
(1)   28/     24B : AD                          plo     RSUBPC
(1)   29/     24C : 79                  	mark 	
(1)   30/     24D : DD                  	sep 	rSubPC
(1)   31/     24E : 22                  	dec 	r2
(1)   32/     24F : 5E                  	str 	rParam1	 													; save in text buffer.
(1)   33/     250 :                     
(1)   34/     250 : (MACRO)             	lrx 	rSubPC,XIOWriteCharacter
(1)   34/     250 : F8 04                       ldi     (XIOWRITECHARACTER)/256
(1)   34/     252 : BD                          phi     RSUBPC
(1)   34/     253 : F8 09                       ldi     (XIOWRITECHARACTER)&255
(1)   34/     255 : AD                          plo     RSUBPC
(1)   35/     256 : 0E                  	ldn 	rParam1
(1)   36/     257 : 79                  	mark
(1)   37/     258 : DD                  	sep 	rSubPC
(1)   38/     259 : 22                  	dec 	r2
(1)   39/     25A :                     
(1)   40/     25A : 0E                  	ldn 	rParam1
(1)   41/     25B : FB 08               	xri 	8 															; Ctl+H
(1)   42/     25D : 32 69               	bz 		__RLLPrevCharacter 											; get previous character
(1)   43/     25F : FB 05               	xri 	13!8 														; is it CR ?
(1)   44/     261 : 3A 44               	bnz 	__RLLNextCharacter 											; no go around again
(1)   45/     263 :                     __RLLExit:
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(readline.asm) - page 16 - 15/1/2017 18:19:44


(1)   46/     263 : 5E                  	str 	rParam1 													; save the zero in rVarPtr making string ASCIIZ.
(1)   47/     264 : F8 80               	ldi 	80h 														; point rParam1 to the start of the string.
(1)   48/     266 : AE                  	plo 	rParam1
(1)   49/     267 : 12                  	inc 	r2 															; and exit.
(1)   50/     268 : (MACRO)             	return
(1)   50/     268 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)   51/     269 :                     
(1)   52/     269 :                     __RLLPrevCharacter:
(1)   53/     269 : 2E                  	dec 	rParam1 													; handle backspace (chr(8))
(1)   54/     26A : 8E                  	glo 	rParam1
(1)   55/     26B : FE                  	shl
(1)   56/     26C : 33 45               	bdf 	__RLLLoop
(1)   57/     26E : 30 44               	br 		__RLLNextCharacter
(1)   58/     270 :                     
      58/     270 :                     	include editing.asm 												; line editing code	
(1)    1/     270 :                     ; ***************************************************************************************************************
(1)    2/     270 :                     ; ***************************************************************************************************************
(1)    3/     270 :                     ;
(1)    4/     270 :                     ;		File:		editing.asm
(1)    5/     270 :                     ;		Purpose:	Line editing/finding functionality.
(1)    6/     270 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     270 :                     ;		Date:		14th January 2017.
(1)    8/     270 :                     ;
(1)    9/     270 :                     ; ***************************************************************************************************************
(1)   10/     270 :                     ; ***************************************************************************************************************
(1)   11/     270 :                     
(1)   12/     270 :                     ; ***************************************************************************************************************
(1)   13/     270 :                     ;
(1)   14/     270 :                     ;	Find line number, return pointer to it in rParam2, return DF = 1 if exact match. DF = 0 if just next one.
(1)   15/     270 :                     ;	So if lines are 10,20,30 25 will be ^30 and DF = 0, 20 will be ^20 and DF = 1
(1)   16/     270 :                     ;
(1)   17/     270 :                     ; ***************************************************************************************************************
(1)   18/     270 :                     
(1)   19/     270 :                     LocateLine:
(1)   20/     270 : E2                  	sex 	r2 															; save the target on the stack.
(1)   21/     271 : 22                  	dec 	r2
(1)   22/     272 : 9F                  	ghi 	rParam2
(1)   23/     273 : 73                  	stxd
(1)   24/     274 : 8F                  	glo 	rParam2
(1)   25/     275 : 52                  	str 	r2
(1)   26/     276 :                     
(1)   27/     276 : (MACRO)             	lrx 	rParam2,ProgramStart  										; read base of program into rParam2
(1)   27/     276 : F8 04                       ldi     (PROGRAMSTART)/256
(1)   27/     278 : BF                          phi     RPARAM2
(1)   27/     279 : F8 10                       ldi     (PROGRAMSTART)&255
(1)   27/     27B : AF                          plo     RPARAM2
(1)   28/     27C :                     	
(1)   29/     27C :                     __LLSearch:
(1)   30/     27C : 0F                  	ldn 	rParam2 													; look at the link.	
(1)   31/     27D : FC FF               	adi 	255 														; DF will be zero if the link was zero, any +ve sets it.
(1)   32/     27F : 3B A5               	bnf 	__LLExit
(1)   33/     281 :                     
(1)   34/     281 : 1F                  	inc 	rParam2 													; point to line number.0
(1)   35/     282 : 4F                  	lda 	rParam2 													; calculate current - required
(1)   36/     283 : F7                  	sm 
(1)   37/     284 : A6                  	plo 	rVarPtr 													; save interim value in rVarPtr.0
(1)   38/     285 : 12                  	inc 	r2 													
(1)   39/     286 : 0F                  	ldn 	rParam2 											
(1)   40/     287 : 77                  	smb 
(1)   41/     288 : 22                  	dec 	r2
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(editing.asm) - page 17 - 15/1/2017 18:19:44


(1)   42/     289 : 33 9A               	bdf 	__LLFound 													; if DF set is >= so this is the find point.
(1)   43/     28B :                     
(1)   44/     28B : 2F                  	dec 	rParam2 													; point rParam2 back to the offset address
(1)   45/     28C : 2F                  	dec 	rParam2
(1)   46/     28D : 0F                  	ldn 	rParam2 													; read offset
(1)   47/     28E : 22                  	dec 	r2 															; save on stack.
(1)   48/     28F : 52                  	str 	r2 												
(1)   49/     290 : 8F                  	glo 	rParam2 													; add to position.
(1)   50/     291 : F4                  	add
(1)   51/     292 : AF                  	plo 	rParam2
(1)   52/     293 : 9F                  	ghi 	rParam2
(1)   53/     294 : 7C 00               	adci 	0
(1)   54/     296 : BF                  	phi 	rParam2
(1)   55/     297 : 12                  	inc 	r2 															; drop stacked value.
(1)   56/     298 : 30 7C               	br 		__LLSearch 													; and go to the next one.
(1)   57/     29A :                     
(1)   58/     29A :                     __LLFound: 																; found answer, DF set. 
(1)   59/     29A : 2F                  	dec 	rParam2 													; point back to the link.
(1)   60/     29B : 2F                  	dec 	rParam2
(1)   61/     29C : FC 00               	adi 	0 															; clear DF.
(1)   62/     29E : 3A A5               	bnz 	__LLExit 													; if results non-zero return DF = 0
(1)   63/     2A0 : 86                  	glo 	rVarPtr 													
(1)   64/     2A1 : 3A A5               	bnz 	__LLExit 
(1)   65/     2A3 : FD 00               	sdi 	0 															; set DF
(1)   66/     2A5 :                     
(1)   67/     2A5 :                     __LLExit:
(1)   68/     2A5 : 12                  	inc 	r2 															; throw stacked values.
(1)   69/     2A6 : 12                  	inc 	r2
(1)   70/     2A7 : 12                  	inc 	r2 															; return from subroutine.
(1)   71/     2A8 : (MACRO)             	return 
(1)   71/     2A8 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)   72/     2A9 :                     
(1)   73/     2A9 :                     ; ***************************************************************************************************************
(1)   74/     2A9 :                     ;
(1)   75/     2A9 :                     ;				Delete program line at rParam2 (address), breaks rSubPC, rParenthesisLevel
(1)   76/     2A9 :                     ;
(1)   77/     2A9 :                     ; ***************************************************************************************************************
(1)   78/     2A9 :                     
(1)   79/     2A9 :                     DeleteLine:
(1)   80/     2A9 : EF                  	sex 	rParam2 													; (X) is the offset
(1)   81/     2AA :                     
(1)   82/     2AA : 8F                  	glo 	rParam2 
(1)   83/     2AB : AA                  	plo 	rParenthesisLevel
(1)   84/     2AC : F4                  	add
(1)   85/     2AD : AD                  	plo 	rSubPC 														; copy from rSubPC to rParenthesisLevel
(1)   86/     2AE : 9F                  	ghi 	rParam2
(1)   87/     2AF : BA                  	phi 	rParenthesisLevel
(1)   88/     2B0 : 7C 00               	adci 	0
(1)   89/     2B2 : BD                  	phi 	rSubPC
(1)   90/     2B3 :                     
(1)   91/     2B3 : F8 4C               	ldi 	('&' & 03Fh) * 2 											; point rVarPtr to the end of memory.
(1)   92/     2B5 : A6                  	plo 	rVarPtr
(1)   93/     2B6 : E6                  	sex 	rVarPtr
(1)   94/     2B7 :                     
(1)   95/     2B7 : 2D                  	dec 	rSubPC
(1)   96/     2B8 : 2A                  	dec 	rParenthesisLevel
(1)   97/     2B9 :                     __DeleteLoop:
(1)   98/     2B9 : 1A                  	inc 	rParenthesisLevel 											; copy one byte over.
(1)   99/     2BA : 1D                  	inc 	rSubPC
(1)  100/     2BB : 0D                  	ldn 	rSubPC
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(editing.asm) - page 18 - 15/1/2017 18:19:44


(1)  101/     2BC : 5A                  	str 	rParenthesisLevel
(1)  102/     2BD : F8 00               	ldi 	0 															; clear newly cleared memory (not really required)
(1)  103/     2BF : 5D                  	str 	rSubPC
(1)  104/     2C0 : 8D                  	glo 	rSubPC 														; loop back if not at end
(1)  105/     2C1 : F3                  	xor
(1)  106/     2C2 : 3A B9               	bnz 	__DeleteLoop
(1)  107/     2C4 : 16                  	inc 	rVarPtr
(1)  108/     2C5 : 9D                  	ghi 	rSubPC 														; source reached program top ?
(1)  109/     2C6 : F3                  	xor
(1)  110/     2C7 : 26                  	dec 	rVarPtr
(1)  111/     2C8 : 3A B9               	bnz 	__DeleteLoop 												
(1)  112/     2CA :                     
(1)  113/     2CA : 8A                  	glo 	rParenthesisLevel 											; update top of program.
(1)  114/     2CB : 56                  	str 	rVarPtr
(1)  115/     2CC : 16                  	inc 	rVarPtr
(1)  116/     2CD : 9A                  	ghi 	rParenthesisLevel
(1)  117/     2CE : 56                  	str 	rVarPtr
(1)  118/     2CF :                     
(1)  119/     2CF : E2                  	sex 	r2
(1)  120/     2D0 : 12                  	inc 	r2
(1)  121/     2D1 : (MACRO)             	return	
(1)  121/     2D1 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)  122/     2D2 :                     
      59/     2D2 :                     	align 	256
      60/     300 :                     
      61/     300 :                     ; ***************************************************************************************************************
      62/     300 :                     ;
      63/     300 :                     ;												Initialisation
      64/     300 :                     ;
      65/     300 :                     ; ***************************************************************************************************************
      66/     300 :                     
      67/     300 :                     Initialise:
      68/     300 : (MACRO)             	lrx 	r2,0FFFFh 													; find top of memory for stack & vartop.
      68/     300 : F8 FF                       ldi     (0FFFFH)/256
      68/     302 : B2                          phi     R2
      68/     303 : F8 FF                       ldi     (0FFFFH)&255
      68/     305 : A2                          plo     R2
      69/     306 : E2                  	sex 	r2 															; this won't work with mirrored memory.
      70/     307 :                     findRAMTop:
      71/     307 : F8 5A               	ldi 	05Ah 														; write this and re-read it.
      72/     309 : 52                  	str 	r2 													
      73/     30A : 02                  	ldn 	r2	
      74/     30B : FB 5A               	xri 	05Ah 														; check the write actually worked.
      75/     30D : 32 15               	bz		foundRAMTop
      76/     30F : 92                  	ghi 	r2
      77/     310 : FF 01               	smi 	1
      78/     312 : B2                  	phi 	r2
      79/     313 : 30 07               	br 		findRAMTop 
      80/     315 :                     foundRAMTop:
      81/     315 : F8 55               	ldi 	('*' & 03Fh) * 2 + 1 										; set up rVarPtr.0 so it will point to MSB of RAMTop.
      82/     317 : A6                  	plo 	rVarPtr
      83/     318 : 92                  	ghi 	r2 															; use the top page of RAM for the variables + keyboard buffer
      84/     319 : B6                  	phi 	rVarPtr
      85/     31A : FF 01               	smi 	1 															; and the page below that is the stack.
      86/     31C : B2                  	phi 	r2
      87/     31D : 56                  	str 	rVarPtr 													; save in RAMTop MSB
      88/     31E : 26                  	dec 	rVarPtr
      89/     31F : F8 00               	ldi 	0 															; zero RAMTop LSB
      90/     321 : 56                  	str 	rVarPtr
      91/     322 :                     
 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 19 - 15/1/2017 18:19:44


      92/     322 : F8 4C               	ldi 	('&' & 03Fh) * 2  											; set program end pointer (&)
      93/     324 : A6                  	plo 	rVarPtr
      94/     325 : F8 59               	ldi 	(ProgramEnd & 255)
      95/     327 : 56                  	str 	rVarPtr
      96/     328 : 16                  	inc 	rVarPtr
      97/     329 : F8 04               	ldi 	(ProgramEnd / 256)
      98/     32B : 56                  	str 	rVarPtr
      99/     32C :                     
     100/     32C :                     ; ***************************************************************************************************************
     101/     32C :                     ;
     102/     32C :                     ;										OK Prompt (Come here after CMD exec, or #=0)
     103/     32C :                     ;
     104/     32C :                     ; ***************************************************************************************************************
     105/     32C :                     
     106/     32C :                     Prompt:
     107/     32C : (MACRO)             	lrx 	rUtilPC,__PrintString 										; print Prompt
     107/     32C : F8 03                       ldi     (__PRINTSTRING)/256
     107/     32E : BC                          phi     RUTILPC
     107/     32F : F8 98                       ldi     (__PRINTSTRING)&255
     107/     331 : AC                          plo     RUTILPC
     108/     332 : (MACRO)             	lrx 	rParam2,__Prompt
     108/     332 : F8 03                       ldi     (__PROMPT)/256
     108/     334 : BF                          phi     RPARAM2
     108/     335 : F8 A6                       ldi     (__PROMPT)&255
     108/     337 : AF                          plo     RPARAM2
     109/     338 : DC                  	sep 	rUtilPC
     110/     339 :                     
     111/     339 : F8 46               	ldi 	('#' & 03Fh) * 2 											; # = 0
     112/     33B : A6                  	plo 	rVarPtr
     113/     33C : F8 00               	ldi 	0
     114/     33E : 56                  	str 	rVarPtr
     115/     33F : 16                  	inc 	rVarPtr
     116/     340 : 56                  	str 	rVarPtr
     117/     341 : (MACRO)             	lrx 	rSpecialHandler,SpecialHandler 								; initialise 'special handler' vector.
     117/     341 : F8 02                       ldi     (SPECIALHANDLER)/256
     117/     343 : B9                          phi     RSPECIALHANDLER
     117/     344 : F8 01                       ldi     (SPECIALHANDLER)&255
     117/     346 : A9                          plo     RSPECIALHANDLER
     118/     347 :                     
     119/     347 :                     ; ***************************************************************************************************************
     120/     347 :                     ;
     121/     347 :                     ;							Read line loop (come back here if modifying program)
     122/     347 :                     ;
     123/     347 :                     ; ***************************************************************************************************************
     124/     347 :                     
     125/     347 :                     EnterCommand:
     126/     347 : (MACRO)             	lrx 	rUtilPC,READLine 											; input a new line.
     126/     347 : F8 02                       ldi     (READLINE)/256
     126/     349 : BC                          phi     RUTILPC
     126/     34A : F8 3F                       ldi     (READLINE)&255
     126/     34C : AC                          plo     RUTILPC
     127/     34D : 79                  	mark
     128/     34E : DC                  	sep 	rUtilPC
     129/     34F : 22                  	dec 	r2
     130/     350 :                     
     131/     350 : (MACRO)             	lrx 	rUtilPC,ASCIIToInteger 										; see if there is a number up front
     131/     350 : F8 01                       ldi     (ASCIITOINTEGER)/256
     131/     352 : BC                          phi     RUTILPC
     131/     353 : F8 B0                       ldi     (ASCIITOINTEGER)&255
     131/     355 : AC                          plo     RUTILPC
 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 20 - 15/1/2017 18:19:44


     132/     356 : 79                  	mark
     133/     357 : DC                  	sep 	rUtilPC
     134/     358 : 22                  	dec 	r2 															; if there is it will be in rParam2 and D # 0, rParam1 points to first non-space
     135/     359 :                     
     136/     359 : 32 C7               	bz 		Execute 													; if D = 0, it is text, so execute the command in rParam1.
     137/     35B :                     
     138/     35B : 8F                  	glo 	rParam2 													; if rParam2 is non zero, then go to edit
     139/     35C : 3A AA               	bnz 	Edit 														; if zero (e.g. typed line number zero) this is actually list.
     140/     35E : 9F                  	ghi 	rParam2
     141/     35F : 3A AA               	bnz 	Edit
     142/     361 :                     
     143/     361 :                     ; ***************************************************************************************************************
     144/     361 :                     ;
     145/     361 :                     ;												Program Listing
     146/     361 :                     ;
     147/     361 :                     ; ***************************************************************************************************************
     148/     361 :                     
     149/     361 :                     ListProgram:
     150/     361 :                     
     151/     361 : (MACRO)             	lrx 	rSrc,ProgramStart 											; point rSrc to the start of the program
     151/     361 : F8 04                       ldi     (PROGRAMSTART)/256
     151/     363 : B8                          phi     RSRC
     151/     364 : F8 10                       ldi     (PROGRAMSTART)&255
     151/     366 : A8                          plo     RSRC
     152/     367 :                     __ListLoop:
     153/     367 : 48                  	lda 	rSrc 														; read the offset link, which we don't use as a step
     154/     368 : 32 2C               	bz 		Prompt 														; if the link is zero, we have reached the end of the program.
     155/     36A :                     
     156/     36A : 48                  	lda 	rSrc 														; read line number into rParam1
     157/     36B : AE                  	plo 	rParam1 													
     158/     36C : 48                  	lda 	rSrc
     159/     36D : BE                  	phi 	rParam1 													
     160/     36E :                     
     161/     36E : 96                  	ghi 	rVarPtr 													; use keyboard buffer for conversion
     162/     36F : BF                  	phi 	rParam2
     163/     370 : F8 FF               	ldi 	0FFh
     164/     372 : AF                  	plo 	rParam2
     165/     373 : (MACRO)             	lrx 	rUtilPC,IntegerToASCII 										; and convert it to ASCII
     165/     373 : F8 01                       ldi     (INTEGERTOASCII)/256
     165/     375 : BC                          phi     RUTILPC
     165/     376 : F8 59                       ldi     (INTEGERTOASCII)&255
     165/     378 : AC                          plo     RUTILPC
     166/     379 : 79                  	mark 	
     167/     37A : DC                  	sep 	rUtilPC
     168/     37B : 22                  	dec 	r2
     169/     37C :                     
     170/     37C : (MACRO)             	lrx 	rUtilPC,__PrintString 										; print it.
     170/     37C : F8 03                       ldi     (__PRINTSTRING)/256
     170/     37E : BC                          phi     RUTILPC
     170/     37F : F8 98                       ldi     (__PRINTSTRING)&255
     170/     381 : AC                          plo     RUTILPC
     171/     382 : DC                  	sep 	rUtilPC
     172/     383 :                     
     173/     383 : F8 20               	ldi 	' '															; print a space - note this takes advantage of __PrintString
     174/     385 : 79                  	mark 																; loading rSubPC with the XIOWriteCharacter() routine.
     175/     386 : DD                  	sep 	rSubPC
     176/     387 : 22                  	dec 	r2
     177/     388 :                     
     178/     388 : 88                  	glo 	rSrc 														; put rSrc -> rParam2 and print that.
     179/     389 : AF                  	plo 	rParam2
 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 21 - 15/1/2017 18:19:44


     180/     38A : 98                  	ghi 	rSrc
     181/     38B : BF                  	phi 	rParam2
     182/     38C : DC                  	sep 	rUtilPC
     183/     38D :                     
     184/     38D : F8 0D               	ldi 	13 															; same trick to print CR as above
     185/     38F : 79                  	mark
     186/     390 : DD                  	sep 	rSubPC
     187/     391 : 22                  	dec 	r2
     188/     392 :                     
     189/     392 :                     __ListNext: 															; advance pointer forward and do next.
     190/     392 : 48                  	lda 	rSrc
     191/     393 : 3A 92               	bnz 	__ListNext
     192/     395 : 30 67               	br 		__ListLoop
     193/     397 :                     
     194/     397 :                     ; ***************************************************************************************************************
     195/     397 :                     ;
     196/     397 :                     ;			Print String at rParam2 (ASCIIZ) , on exit leaves rSubPC set up to print a character
     197/     397 :                     ;
     198/     397 :                     ; ***************************************************************************************************************
     199/     397 :                     
     200/     397 : D3                  	sep 	r3
     201/     398 :                     __PrintString:
     202/     398 : (MACRO)             	lrx 	rSubPC,XIOWriteCharacter 									; print character routine
     202/     398 : F8 04                       ldi     (XIOWRITECHARACTER)/256
     202/     39A : BD                          phi     RSUBPC
     202/     39B : F8 09                       ldi     (XIOWRITECHARACTER)&255
     202/     39D : AD                          plo     RSUBPC
     203/     39E : 4F                  	lda 	rParam2
     204/     39F : 32 97               	bz 		__PrintString-1
     205/     3A1 : 79                  	mark
     206/     3A2 : DD                  	sep 	rSubPC
     207/     3A3 : 22                  	dec	 	r2
     208/     3A4 : 30 98               	br 		__PrintString
     209/     3A6 :                     
     210/     3A6 :                     __Prompt: 																; VTL-2 Prompt.
     211/     3A6 : 4F 4B 0D 00         	db 		"OK",13,0
     212/     3AA :                     
     213/     3AA :                     ; ***************************************************************************************************************
     214/     3AA :                     ;
     215/     3AA :                     ;									Edit Line rParam2, new text in rParam1
     216/     3AA :                     ;
     217/     3AA :                     ; ***************************************************************************************************************
     218/     3AA :                     
     219/     3AA :                     Edit: 																	; edit line - number in rParam2, new text in rParam1.
     220/     3AA : 8F                  	glo 	rParam2 													; save line number in rSrc
     221/     3AB : A8                  	plo 	rSrc
     222/     3AC : 9F                  	ghi 	rParam2
     223/     3AD : B8                  	phi 	rSrc
     224/     3AE : (MACRO)             	lrx 	rUtilPC,LocateLine 											; find the line.
     224/     3AE : F8 02                       ldi     (LOCATELINE)/256
     224/     3B0 : BC                          phi     RUTILPC
     224/     3B1 : F8 70                       ldi     (LOCATELINE)&255
     224/     3B3 : AC                          plo     RUTILPC
     225/     3B4 : 79                  	mark 
     226/     3B5 : DC                  	sep 	rUtilPC
     227/     3B6 : 22                  	dec 	r2
     228/     3B7 : 3B C2               	bnf 	__DontDelete 												; if DF = 0 not found line to delete.
     229/     3B9 :                     
     230/     3B9 : (MACRO)             	lrx 	rUtilPC,DeleteLine 											; Delete line (address in rParam2)
     230/     3B9 : F8 02                       ldi     (DELETELINE)/256
 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 22 - 15/1/2017 18:19:44


     230/     3BB : BC                          phi     RUTILPC
     230/     3BC : F8 A9                       ldi     (DELETELINE)&255
     230/     3BE : AC                          plo     RUTILPC
     231/     3BF : 79                  	mark 
     232/     3C0 : DC                  	sep 	rUtilPC
     233/     3C1 : 22                  	dec 	r2
     234/     3C2 :                     
     235/     3C2 :                     __DontDelete:
     236/     3C2 : 0E                  	ldn 	rParam1  													; look at first not space character
     237/     3C3 : 32 47               	bz 		EnterCommand 												; if zero, it's delete only.
     238/     3C5 :                     	;
     239/     3C5 :                     	;	Insert line at rParam2, rSrc line Number, rParam1 text to insert.
     240/     3C5 :                     	;
     241/     3C5 : 30 C5               w1:	br w1
     242/     3C7 :                     
     243/     3C7 :                     Execute:
     244/     3C7 :                     	; do it. look for side effects, #=n goes into a different routine which runs code.
     245/     3C7 : 30 C7               	br 	Execute
     246/     3C9 :                     
     247/     3C9 :                     	align 	256
     248/     400 :                     	include	virtualio.asm 												; I/O routines that are hardware specific.
(1)    1/     400 :                     ; ***************************************************************************************************************
(1)    2/     400 :                     ; ***************************************************************************************************************
(1)    3/     400 :                     ;
(1)    4/     400 :                     ;		File:		virtualio.asm
(1)    5/     400 :                     ;		Purpose:	Input/Output routines.
(1)    6/     400 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     400 :                     ;		Date:		14th January 2017.
(1)    8/     400 :                     ;
(1)    9/     400 :                     ; ***************************************************************************************************************
(1)   10/     400 :                     ; ***************************************************************************************************************
(1)   11/     400 :                     
(1)   12/     400 :                     ; ***************************************************************************************************************
(1)   13/     400 :                     ;
(1)   14/     400 :                     ;	These routines will be entered with P = rUtilPC or P = rSubPC and should change no registers other than
(1)   15/     400 :                     ; 	D and DF. On entry R2 will point to an empty stack space.
(1)   16/     400 :                     ;
(1)   17/     400 :                     ; ***************************************************************************************************************
(1)   18/     400 :                     
(1)   19/     400 :                     ; ***************************************************************************************************************
(1)   20/     400 :                     ;
(1)   21/     400 :                     ;												Get a keystroke into D.
(1)   22/     400 :                     ;
(1)   23/     400 :                     ; ***************************************************************************************************************
(1)   24/     400 :                     
(1)   25/     400 : (MACRO)             	return
(1)   25/     400 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)   26/     401 :                     XIOGetKey:
(1)   27/     401 : E2                  	sex 	r2 															; fix up after Mark.
(1)   28/     402 : 69                  	inp 	1 															; read keyboard port
(1)   29/     403 : 32 01               	bz 		XIOGetKey 													; no key, keep trying
(1)   30/     405 : 12                  	inc 	r2 															; standard return.
(1)   31/     406 : 30 00               	br 		XIOGetKey-1
(1)   32/     408 :                     
(1)   33/     408 :                     ; ***************************************************************************************************************
(1)   34/     408 :                     ;
(1)   35/     408 :                     ;										    Write a character to the display
(1)   36/     408 :                     ;
(1)   37/     408 :                     ; ***************************************************************************************************************
(1)   38/     408 :                     
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(virtualio.asm) - page 23 - 15/1/2017 18:19:44


(1)   39/     408 : (MACRO)             	return
(1)   39/     408 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)   40/     409 :                     XIOWriteCharacter:
(1)   41/     409 : E2                  	sex 	r2
(1)   42/     40A : 52                  	str 	r2
(1)   43/     40B : 61                  	out 	1
(1)   44/     40C : 22                  	dec 	r2
(1)   45/     40D : 12                  	inc 	r2
(1)   46/     40E : 30 08               	br 		XIOWriteCharacter-1
     249/     410 :                     
     250/     410 :                     
     251/     410 :                     
     252/     410 :                     
     253/     410 :                     ; ***************************************************************************************************************
     254/     410 :                     ;
     255/     410 :                     ;												VTL-2 Code, test 
     256/     410 :                     ;
     257/     410 :                     ; ***************************************************************************************************************
     258/     410 :                     
     259/     410 :                     vtl macro line,code 													; creating VTL-2 code in line.
     260/     410 :                     startLine:
     261/     410 :                     	db 		endLine-startLine 											; +0 offset to next
     262/     410 :                     	db 		line & 255,line / 256 										; +1,+2 line number
     263/     410 :                     	db 		code,0 														; ASCIIZ line.
     264/     410 :                     endLine:	
     265/     410 :                     	endm
     266/     410 :                     
     267/     410 :                     ProgramStart:
     268/     410 : (MACRO)             	vtl 	10,"A=42) this is a comment"
     268/     410 :                     startLine:
     268/     410 : 1B                          db              endLine-startLine                                                                                       ; +0 offset to next
     268/     411 : 0A 00                       db              10 & 255,10 / 256                                                                           ; +1,+2 10 number
     268/     413 : 41 3D 34 32 29 20           db              "A=42) this is a comment",0                                                                                                          ; ASCIIZ 10.
                    74 68 69 73 20 69 
                    73 20 61 20 63 6F 
                    6D 6D 65 6E 74 00 
     268/     42B :                     endLine:        
     269/     42B : (MACRO)             	vtl 	20,"#=?"		
     269/     42B :                     startLine:
     269/     42B : 07                          db              endLine-startLine                                                                                       ; +0 offset to next
     269/     42C : 14 00                       db              20 & 255,20 / 256                                                                           ; +1,+2 20 number
     269/     42E : 23 3D 3F 00                 db              "#=?",0                                                                                                          ; ASCIIZ 20.
     269/     432 :                     endLine:        
     270/     432 : (MACRO)             	vtl 	30,"?=A"
     270/     432 :                     startLine:
     270/     432 : 07                          db              endLine-startLine                                                                                       ; +0 offset to next
     270/     433 : 1E 00                       db              30 & 255,30 / 256                                                                           ; +1,+2 30 number
     270/     435 : 3F 3D 41 00                 db              "?=A",0                                                                                                          ; ASCIIZ 30.
     270/     439 :                     endLine:        
     271/     439 : (MACRO)             	vtl	 	40,"a"
     271/     439 :                     startLine:
     271/     439 : 05                          db              endLine-startLine                                                                                       ; +0 offset to next
     271/     43A : 28 00                       db              40 & 255,40 / 256                                                                           ; +1,+2 40 number
     271/     43C : 61 00                       db              "a",0                                                                                                          ; ASCIIZ 40.
     271/     43E :                     endLine:        
     272/     43E : (MACRO)             	vtl 	50,"b"
     272/     43E :                     startLine:
     272/     43E : 05                          db              endLine-startLine                                                                                       ; +0 offset to next
     272/     43F : 32 00                       db              50 & 255,50 / 256                                                                           ; +1,+2 50 number
     272/     441 : 62 00                       db              "b",0                                                                                                          ; ASCIIZ 50.
 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 24 - 15/1/2017 18:19:44


     272/     443 :                     endLine:        
     273/     443 : (MACRO)             	vtl 	60,"c"
     273/     443 :                     startLine:
     273/     443 : 05                          db              endLine-startLine                                                                                       ; +0 offset to next
     273/     444 : 3C 00                       db              60 & 255,60 / 256                                                                           ; +1,+2 60 number
     273/     446 : 63 00                       db              "c",0                                                                                                          ; ASCIIZ 60.
     273/     448 :                     endLine:        
     274/     448 : (MACRO)             	vtl 	1260,"z"
     274/     448 :                     startLine:
     274/     448 : 05                          db              endLine-startLine                                                                                       ; +0 offset to next
     274/     449 : EC 04                       db              1260 & 255,1260 / 256                                                                           ; +1,+2 1260 number
     274/     44B : 7A 00                       db              "z",0                                                                                                          ; ASCIIZ 1260.
     274/     44D :                     endLine:        
     275/     44D : (MACRO)             	vtl 	32260,"zz"
     275/     44D :                     startLine:
     275/     44D : 06                          db              endLine-startLine                                                                                       ; +0 offset to next
     275/     44E : 04 7E                       db              32260 & 255,32260 / 256                                                                           ; +1,+2 32260 number
     275/     450 : 7A 7A 00                    db              "zz",0                                                                                                          ; ASCIIZ 32260.
     275/     453 :                     endLine:        
     276/     453 : (MACRO)             	vtl 	40000,"qq"
     276/     453 :                     startLine:
     276/     453 : 06                          db              endLine-startLine                                                                                       ; +0 offset to next
     276/     454 : 40 9C                       db              40000 & 255,40000 / 256                                                                           ; +1,+2 40000 number
     276/     456 : 71 71 00                    db              "qq",0                                                                                                          ; ASCIIZ 40000.
     276/     459 :                     endLine:        
     277/     459 :                     ProgramEnd:	
     278/     459 : 00                  	db 		0
 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 25 - 15/1/2017 18:19:44


  symbol table (* = unused):
  ------------------------

*ARCHITECTURE :                                        x86_64-unknown-linux - |
 ASCIITOINTEGER :               1B0 C | *BIGENDIAN :                      0 - |
*BRANCHEXT :                      0 - | *CASESENSITIVE :                  0 - |
*CONSTPI :        3.141592653589793 - | *DATE :                   15/1/2017 - |
 DELETELINE :                   2A9 C |  DIVIDE :                        C0 C |
 EDIT :                         3AA C |  ENTERCOMMAND :                 347 C |
 EXECUTE :                      3C7 C | *EXPREVALUATE :                  14 C |
*FALSE :                          0 - |  FINDRAMTOP :                   307 C |
 FOUNDRAMTOP :                  315 C | *FULLPMMU :                       1 - |
*HAS64 :                          1 - | *HASDSP :                         0 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
*INEXTMODE :                      0 - |  INITIALISE :                   300 C |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
 INTEGERTOASCII :               159 C | *LISTON :                         1 - |
*LISTPROGRAM :                  361 C |  LOCATELINE :                   270 C |
*MACEXP :                         1 - | *MOMCPU :                      1802 - |
*MOMCPUNAME :                  1802 - |  MULTIPLY :                     18B C |
*NESTMAX :                      100 - | *PACKING :                        0 - |
*PADDING :                        1 - |  PROGRAMEND :                   459 C |
 PROGRAMSTART :                 410 C |  PROMPT :                       32C C |
*R0 :                             0 - | *R1 :                             1 - |
 R2 :                             2 - |  R3 :                             3 - |
 READLINE :                     23F C | *RELAXED :                        0 - |
 REXPRPC :                        7 - |  RPARAM1 :                        E - |
 RPARAM2 :                        F - |  RPARENTHESISLEVEL :              A - |
 RSAVESTACK :                     B - |  RSPECIALHANDLER :                9 - |
 RSRC :                           8 - |  RSUBPC :                         D - |
 RUTILPC :                        C - |  RVARPTR :                        6 - |
 SPECIALHANDLER :               201 C | *TIME :                    18:19:44 - |
*TRUE :                           1 - | *VERSION :                     142F - |
 W1 :                           3C5 C |  XIOGETKEY :                    401 C |
 XIOWRITECHARACTER :            409 C |  __ATOIEXIT :                   1AD C |
 __ATOILOOP :                   1B6 C |  __DELETELOOP :                 2B9 C |
 __DIVEXIT :                     BE C | *__DIVLOOP :                     CF C |
 __DIVLOOPINCR2 :                CE C |  __DIVLOOPINCR2INCR2 :           CD C |
 __DONTDELETE :                 3C2 C |  __EXPRARRAY :                   57 C |
 __EXPRDESTACKBRACKET :          A4 C |  __EXPREXIT :                     A C |
 __EXPREXITDEC :                  9 C |  __EXPRFINDOPERATION :           6E C |
 __EXPRFOUNDOPERATION :          76 C |  __EXPRGOTCHARACTER :            5F C |
 __EXPRGOTTERM :                 67 C |  __EXPRNEWLEVEL :                1C C |
 __EXPRNEWTERM :                 24 C |  __EXPRNOTDIVIDE :               90 C |
 __EXPRSKIPSPACE :               94 C |  __ITOAEXIT :                   157 C |
 __ITOALOOP :                   15D C |  __LISTLOOP :                   367 C |
 __LISTNEXT :                   392 C |  __LLEXIT :                     2A5 C |
 __LLFOUND :                    29A C |  __LLSEARCH :                   27C C |
 __MULDONTADD :                 19F C |  __MULEXIT :                    186 C |
 __MULLOOP :                    190 C |  __OPADD :                      100 C |
 __OPEQISTRUE :                 14F C |  __OPEQNZ :                     14B C |
 __OPEQUALITY :                 147 C |  __OPERATORTABLE :               AF C |
 __OPLOOKUP :                   10D C |  __OPLT0 :                      140 C |
 __OPRETURN :                   123 C |  __OPSUB :                      126 C |
 __OPWRITEBOOLEAN :             151 C |  __PRINTSTRING :                398 C |
 __PROMPT :                     3A6 C | *__RLLEXIT :                    263 C |
 __RLLLOOP :                    245 C |  __RLLNEXTCHARACTER :           244 C |
 __RLLPREVCHARACTER :           269 C |  __SHEXIT :                     200 C |
 __SHGETKEY :                   20D C |  __SHINPUT :                    21C C |
 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 26 - 15/1/2017 18:19:44



    113 symbols
     34 unused symbols

 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 27 - 15/1/2017 18:19:44


  defined macros:
  ---------------

LRX                                   | OPER                                 
RETURN                                | VTL                                  
__ATOIDOUBLERPARAM2                   |

      5 macros

 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 28 - 15/1/2017 18:19:44


  codepages:
  ----------

STANDARD (0 changed characters)


0.01 seconds assembly time

   1234 lines source file
   1404 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
