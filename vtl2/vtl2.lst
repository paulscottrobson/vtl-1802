 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 1 - 18/1/2017 16:31:26


       1/       0 :                     ; ***************************************************************************************************************
       2/       0 :                     ; ***************************************************************************************************************
       3/       0 :                     ;
       4/       0 :                     ;		File:		vtl2.asm
       5/       0 :                     ;		Purpose:	Main Program.
       6/       0 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
       7/       0 :                     ;		Date:		14th January 2017.
       8/       0 :                     ;
       9/       0 :                     ; ***************************************************************************************************************
      10/       0 :                     ; ***************************************************************************************************************
      11/       0 :                     
      12/       0 :                     	cpu 	1802 														; obviously !
      13/       0 :                     	
      14/       0 : =0H                 r0 = 0 																	; not used (may be used in interrupt display)
      15/       0 : =1H                 r1 = 1 																	; interrupt register
      16/       0 : =2H                 r2 = 2 																	; stack pointer
      17/       0 : =3H                 r3 = 3 																	; general run P
      18/       0 : =4H                 rExecutePC = 4 															; execute commands using R4. (param1 = code to execute)
      19/       0 : =5H                 rCurrentLine = 5 														; current line pointer.
      20/       0 : =6H                 rVarPtr = 6 															; always points to variables (64 variables 2 bytes each 6 bit ASCII)
      21/       0 : =7H                 rExprPC = 7 															; used as P register in expression (mandated)
      22/       0 : =8H                 rSrc = 8 																; source code.
      23/       0 : =9H                 rSpecialHandler = 9 													; special variables handler.
      24/       0 : =AH                 rParenthesisLevel = 10 													; bracket level (low byte)
      25/       0 : =BH                 rSaveStack = 11 														; original value of stack pointer
      26/       0 :                     
      27/       0 : =CH                 rUtilPC = 12 															; used as P register calling routines (not mandated)
      28/       0 : =DH                 rSubPC = 13																; used as P register to call routines within routines
      29/       0 : =EH                 rParam1 = 14 															; subroutine parameters/return values.
      30/       0 : =FH                 rParam2 = 15
      31/       0 :                     
      32/       0 :                     return macro 															; allows subroutine returns to disable/enable interrupts as you want.
      33/       0 :                     	dis 																; this program uses MARK-subroutines
      34/       0 :                     	endm
      35/       0 :                     
      36/       0 :                     lrx macro 	r,n 														; load 16 bit value into register macro
      37/       0 :                     	ldi 	(n)/256
      38/       0 :                     	phi 	r
      39/       0 :                     	ldi 	(n)&255
      40/       0 :                     	plo 	r
      41/       0 :                     	endm
      42/       0 :                     
      43/       0 :                     ; ***************************************************************************************************************
      44/       0 :                     ;
      45/       0 :                     ;													Start up 1802
      46/       0 :                     ;
      47/       0 :                     ; ***************************************************************************************************************
      48/       0 :                     
      49/       0 : (MACRO)             	return 																; enable/disable interrupts, switch to R3.
      49/       0 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
      50/       1 : 00                  	db 		000h
      51/       2 : (MACRO)             	lrx 	r3,Initialise 												; jump to start.
      51/       2 : F8 00                       ldi     (INITIALISE)/256
      51/       4 : B3                          phi     R3
      51/       5 : F8 09                       ldi     (INITIALISE)&255
      51/       7 : A3                          plo     R3
      52/       8 : D3                  	sep 	r3
      53/       9 :                     
      54/       9 :                     ; ***************************************************************************************************************
      55/       9 :                     ;
 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 2 - 18/1/2017 16:31:26


      56/       9 :                     ;												Initialisation
      57/       9 :                     ;
      58/       9 :                     ; ***************************************************************************************************************
      59/       9 :                     
      60/       9 :                     Initialise:
      61/       9 : (MACRO)             	lrx 	r2,0FFFFh 													; find top of memory for stack & vartop.
      61/       9 : F8 FF                       ldi     (0FFFFH)/256
      61/       B : B2                          phi     R2
      61/       C : F8 FF                       ldi     (0FFFFH)&255
      61/       E : A2                          plo     R2
      62/       F : E2                  	sex 	r2 															; this won't work with mirrored memory.
      63/      10 :                     findRAMTop:
      64/      10 : F8 5A               	ldi 	05Ah 														; write this and re-read it.
      65/      12 : 52                  	str 	r2 													
      66/      13 : 02                  	ldn 	r2	
      67/      14 : FB 5A               	xri 	05Ah 														; check the write actually worked.
      68/      16 : 32 1E               	bz		foundRAMTop
      69/      18 : 92                  	ghi 	r2
      70/      19 : FF 01               	smi 	1
      71/      1B : B2                  	phi 	r2
      72/      1C : 30 10               	br 		findRAMTop 
      73/      1E :                     foundRAMTop:
      74/      1E : F8 55               	ldi 	('*' & 03Fh) * 2 + 1 										; set up rVarPtr.0 so it will point to MSB of RAMTop.
      75/      20 : A6                  	plo 	rVarPtr
      76/      21 : 92                  	ghi 	r2 															; use the top page of RAM for the variables + keyboard buffer
      77/      22 : B6                  	phi 	rVarPtr
      78/      23 : FF 01               	smi 	1 															; and the page below that is the stack.
      79/      25 : B2                  	phi 	r2
      80/      26 : 56                  	str 	rVarPtr 													; save in RAMTop MSB
      81/      27 : 26                  	dec 	rVarPtr
      82/      28 : F8 00               	ldi 	0 															; zero RAMTop LSB
      83/      2A : 56                  	str 	rVarPtr
      84/      2B :                     
      85/      2B : F8 4C               	ldi 	('&' & 03Fh) * 2  											; set program end pointer (&)
      86/      2D : A6                  	plo 	rVarPtr
      87/      2E : F8 82               	ldi 	(ProgramEnd & 255)
      88/      30 : 56                  	str 	rVarPtr
      89/      31 : 16                  	inc 	rVarPtr
      90/      32 : F8 05               	ldi 	(ProgramEnd / 256)
      91/      34 : 56                  	str 	rVarPtr
      92/      35 :                     
      93/      35 : F8 4E               	ldi 	(39 & 03Fh) * 2 											; initialise RNG
      94/      37 : A6                  	plo 	rVarPtr
      95/      38 : 56                  	str 	rVarPtr
      96/      39 :                     
      97/      39 :                     ; ***************************************************************************************************************
      98/      39 :                     ;
      99/      39 :                     ;						OK Prompt (Come here after CMD exec, or program halted) also clears #
     100/      39 :                     ;
     101/      39 :                     ; ***************************************************************************************************************
     102/      39 :                     
     103/      39 :                     Prompt:
     104/      39 : (MACRO)             	lrx 	rUtilPC,__PrintString 										; print Prompt
     104/      39 : F8 05                       ldi     (__PRINTSTRING)/256
     104/      3B : BC                          phi     RUTILPC
     104/      3C : F8 42                       ldi     (__PRINTSTRING)&255
     104/      3E : AC                          plo     RUTILPC
     105/      3F : (MACRO)             	lrx 	rParam2,__Prompt
     105/      3F : F8 03                       ldi     (__PROMPT)/256
     105/      41 : BF                          phi     RPARAM2
 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 3 - 18/1/2017 16:31:26


     105/      42 : F8 DC                       ldi     (__PROMPT)&255
     105/      44 : AF                          plo     RPARAM2
     106/      45 : DC                  	sep 	rUtilPC
     107/      46 :                     
     108/      46 : F8 46               	ldi 	('#' & 03Fh) * 2 											; # = 0
     109/      48 : A6                  	plo 	rVarPtr
     110/      49 : F8 00               	ldi 	0
     111/      4B : 56                  	str 	rVarPtr
     112/      4C : 16                  	inc 	rVarPtr
     113/      4D : 56                  	str 	rVarPtr
     114/      4E : (MACRO)             	lrx 	rSpecialHandler,SpecialHandler 								; initialise 'special handler' vector.
     114/      4E : F8 03                       ldi     (SPECIALHANDLER)/256
     114/      50 : B9                          phi     RSPECIALHANDLER
     114/      51 : F8 01                       ldi     (SPECIALHANDLER)&255
     114/      53 : A9                          plo     RSPECIALHANDLER
     115/      54 :                     
     116/      54 :                     ; ***************************************************************************************************************
     117/      54 :                     ;
     118/      54 :                     ;							Read line loop (come back here if modifying program)
     119/      54 :                     ;
     120/      54 :                     ; ***************************************************************************************************************
     121/      54 :                     
     122/      54 :                     EnterCommand:
     123/      54 : (MACRO)             	lrx 	rUtilPC,READLine 											; input a new line.
     123/      54 : F8 05                       ldi     (READLINE)/256
     123/      56 : BC                          phi     RUTILPC
     123/      57 : F8 00                       ldi     (READLINE)&255
     123/      59 : AC                          plo     RUTILPC
     124/      5A : 79                  	mark
     125/      5B : DC                  	sep 	rUtilPC
     126/      5C : 22                  	dec 	r2
     127/      5D :                     
     128/      5D : (MACRO)             	lrx 	rUtilPC,ASCIIToInteger 										; see if there is a number up front
     128/      5D : F8 02                       ldi     (ASCIITOINTEGER)/256
     128/      5F : BC                          phi     RUTILPC
     128/      60 : F8 B0                       ldi     (ASCIITOINTEGER)&255
     128/      62 : AC                          plo     RUTILPC
     129/      63 : 79                  	mark
     130/      64 : DC                  	sep 	rUtilPC
     131/      65 : 22                  	dec 	r2 															; if there is it will be in rParam2 and D # 0, rParam1 points to first non-space
     132/      66 :                     
     133/      66 : 32 CA               	bz 		Execute 													; if D = 0, it is text, so execute the command in rParam1.
     134/      68 :                     
     135/      68 : 8F                  	glo 	rParam2 													; if rParam2 is non zero, then go to edit
     136/      69 : 3A A4               	bnz 	Edit 														; if zero (e.g. typed line number zero) this is actually list.
     137/      6B : 9F                  	ghi 	rParam2
     138/      6C : 3A A4               	bnz 	Edit
     139/      6E :                     
     140/      6E :                     ; ***************************************************************************************************************
     141/      6E :                     ;
     142/      6E :                     ;												Program Listing
     143/      6E :                     ;
     144/      6E :                     ; ***************************************************************************************************************
     145/      6E :                     
     146/      6E :                     ListProgram:
     147/      6E :                     
     148/      6E : (MACRO)             	lrx 	rSrc,ProgramStart 											; point rSrc to the start of the program
     148/      6E : F8 05                       ldi     (PROGRAMSTART)/256
     148/      70 : B8                          phi     RSRC
     148/      71 : F8 50                       ldi     (PROGRAMSTART)&255
 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 4 - 18/1/2017 16:31:26


     148/      73 : A8                          plo     RSRC
     149/      74 :                     __ListLoop:
     150/      74 : 48                  	lda 	rSrc 														; read the offset link, which we don't use as a step
     151/      75 : 32 39               	bz 		Prompt 														; if the link is zero, we have reached the end of the program.
     152/      77 :                     
     153/      77 : 48                  	lda 	rSrc 														; read line number into rParam1
     154/      78 : AE                  	plo 	rParam1 													
     155/      79 : 48                  	lda 	rSrc
     156/      7A : BE                  	phi 	rParam1 													
     157/      7B :                     
     158/      7B : 96                  	ghi 	rVarPtr 													; use keyboard buffer for conversion
     159/      7C : BF                  	phi 	rParam2
     160/      7D : F8 FF               	ldi 	0FFh
     161/      7F : AF                  	plo 	rParam2
     162/      80 : (MACRO)             	lrx 	rUtilPC,IntegerToASCII 										; and convert it to ASCII
     162/      80 : F8 02                       ldi     (INTEGERTOASCII)/256
     162/      82 : BC                          phi     RUTILPC
     162/      83 : F8 59                       ldi     (INTEGERTOASCII)&255
     162/      85 : AC                          plo     RUTILPC
     163/      86 : 79                  	mark 	
     164/      87 : DC                  	sep 	rUtilPC
     165/      88 : 22                  	dec 	r2
     166/      89 :                     
     167/      89 : (MACRO)             	lrx 	rUtilPC,__PrintString 										; print it.
     167/      89 : F8 05                       ldi     (__PRINTSTRING)/256
     167/      8B : BC                          phi     RUTILPC
     167/      8C : F8 42                       ldi     (__PRINTSTRING)&255
     167/      8E : AC                          plo     RUTILPC
     168/      8F : DC                  	sep 	rUtilPC
     169/      90 :                     
     170/      90 : F8 20               	ldi 	' '															; print a space - note this takes advantage of __PrintString
     171/      92 : 79                  	mark 																; loading rSubPC with the XIOWriteCharacter() routine.
     172/      93 : DD                  	sep 	rSubPC
     173/      94 : 22                  	dec 	r2
     174/      95 :                     
     175/      95 : 88                  	glo 	rSrc 														; put rSrc -> rParam2 and print that.
     176/      96 : AF                  	plo 	rParam2
     177/      97 : 98                  	ghi 	rSrc
     178/      98 : BF                  	phi 	rParam2
     179/      99 : DC                  	sep 	rUtilPC
     180/      9A :                     
     181/      9A : F8 0D               	ldi 	13 															; same trick to print CR as above
     182/      9C : 79                  	mark
     183/      9D : DD                  	sep 	rSubPC
     184/      9E : 22                  	dec 	r2
     185/      9F :                     
     186/      9F :                     __ListNext: 															; advance pointer forward and do next.
     187/      9F : 48                  	lda 	rSrc
     188/      A0 : 3A 9F               	bnz 	__ListNext
     189/      A2 : 30 74               	br 		__ListLoop
     190/      A4 :                     
     191/      A4 :                     ; ***************************************************************************************************************
     192/      A4 :                     ;
     193/      A4 :                     ;									Edit Line rParam2, new text in rParam1
     194/      A4 :                     ;
     195/      A4 :                     ; ***************************************************************************************************************
     196/      A4 :                     
     197/      A4 :                     Edit: 																	; edit line - number in rParam2, new text in rParam1.
     198/      A4 : 8F                  	glo 	rParam2 													; save line number in rSrc
     199/      A5 : A8                  	plo 	rSrc
 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 5 - 18/1/2017 16:31:26


     200/      A6 : 9F                  	ghi 	rParam2
     201/      A7 : B8                  	phi 	rSrc
     202/      A8 : (MACRO)             	lrx 	rUtilPC,LocateLine 											; find the line.
     202/      A8 : F8 03                       ldi     (LOCATELINE)/256
     202/      AA : BC                          phi     RUTILPC
     202/      AB : F8 3F                       ldi     (LOCATELINE)&255
     202/      AD : AC                          plo     RUTILPC
     203/      AE : 79                  	mark 
     204/      AF : DC                  	sep 	rUtilPC
     205/      B0 : 22                  	dec 	r2
     206/      B1 : 3B BC               	bnf 	__DontDelete 												; if DF = 0 not found line to delete.
     207/      B3 :                     
     208/      B3 : (MACRO)             	lrx 	rUtilPC,DeleteLine 											; Delete line (address in rParam2)
     208/      B3 : F8 03                       ldi     (DELETELINE)/256
     208/      B5 : BC                          phi     RUTILPC
     208/      B6 : F8 78                       ldi     (DELETELINE)&255
     208/      B8 : AC                          plo     RUTILPC
     209/      B9 : 79                  	mark 
     210/      BA : DC                  	sep 	rUtilPC
     211/      BB : 22                  	dec 	r2
     212/      BC :                     
     213/      BC :                     __DontDelete:
     214/      BC : 0E                  	ldn 	rParam1  													; look at first not space character
     215/      BD : 32 54               	bz 		EnterCommand 												; if zero, it's delete only.
     216/      BF :                     
     217/      BF : (MACRO)             	lrx 	rUtilPC,InsertLine 											; Insert the new line
     217/      BF : F8 03                       ldi     (INSERTLINE)/256
     217/      C1 : BC                          phi     RUTILPC
     217/      C2 : F8 A1                       ldi     (INSERTLINE)&255
     217/      C4 : AC                          plo     RUTILPC
     218/      C5 : 79                  	mark 
     219/      C6 : DC                  	sep 	rUtilPC
     220/      C7 : 22                  	dec 	r2
     221/      C8 : 30 54               	br 		EnterCommand
     222/      CA :                     
     223/      CA :                     ; ***************************************************************************************************************
     224/      CA :                     ;	
     225/      CA :                     ;										Execute line in rParam1
     226/      CA :                     ;
     227/      CA :                     ; ***************************************************************************************************************
     228/      CA :                     
     229/      CA :                     Execute:
     230/      CA : 0E                  	ldn 	rParam1 													; read first character
     231/      CB : 32 54               	bz 		EnterCommand 												; blank line, do nothing
     232/      CD : (MACRO)             	lrx 	rExecutePC,ExecuteCommand 									; execute command in P1.
     232/      CD : F8 04                       ldi     (EXECUTECOMMAND)/256
     232/      CF : B4                          phi     REXECUTEPC
     232/      D0 : F8 03                       ldi     (EXECUTECOMMAND)&255
     232/      D2 : A4                          plo     REXECUTEPC
     233/      D3 : D4                  	sep 	rExecutePC 
     234/      D4 :                     
     235/      D4 : F8 46               	ldi 	('#' & 03Fh) * 2 											; look at '#'
     236/      D6 : A6                  	plo 	rVarPtr
     237/      D7 : 46                  	lda 	rVarPtr 													; if non zero go to run code.
     238/      D8 : 3A DD               	bnz 	RunProgram
     239/      DA : 06                  	ldn 	rVarPtr 	
     240/      DB : 32 39               	bz 		Prompt  													; if zero, loop back, displaying "OK"
     241/      DD :                     
     242/      DD :                     ; ***************************************************************************************************************
     243/      DD :                     ;
 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 6 - 18/1/2017 16:31:26


     244/      DD :                     ;													In Run Mode.
     245/      DD :                     ;
     246/      DD :                     ; ***************************************************************************************************************
     247/      DD :                     
     248/      DD :                     RunProgram:
     249/      DD : 05                  	ldn		rCurrentLine 												; if current offset = 0 (end of program) then exit to prompt
     250/      DE : 52                  	str 	r2 															; save at TOS.
     251/      DF : 32 39               	bz 		Prompt
     252/      E1 : 85                  	glo 	rCurrentLine 												; copy current line into rParam1
     253/      E2 : AE                  	plo 	rParam1
     254/      E3 : 95                  	ghi 	rCurrentLine
     255/      E4 : BE                  	phi 	rParam1
     256/      E5 :                     
     257/      E5 : 85                  	glo 	rCurrentLine 												; set currentPC to point to next line.
     258/      E6 : F4                  	add  																; done here so the Execute Routine can update it if it wants.
     259/      E7 : A5                  	plo 	rCurrentLine
     260/      E8 : 95                  	ghi 	rCurrentLine
     261/      E9 : 7C 00               	adci 	0
     262/      EB : B5                  	phi 	rCurrentLine
     263/      EC :                     
     264/      EC : F8 46               	ldi 	('#' & 03Fh) * 2 											; set rVarPtr to point to current line number
     265/      EE : A6                  	plo 	rVarPtr
     266/      EF : 1E                  	inc 	rParam1 													; skip over offset
     267/      F0 : 4E                  	lda 	rParam1 													; read line# low
     268/      F1 : 56                  	str 	rVarPtr 													; copy to # low
     269/      F2 : 4E                  	lda 	rParam1 													; read line# high
     270/      F3 : 16                  	inc 	rVarPtr 													; copy to # high
     271/      F4 : 56                  	str 	rVarPtr 	 												; now points to first byte of command.
     272/      F5 :                     
     273/      F5 : D4                  	sep 	rExecutePC 													; and execute it.
     274/      F6 : 30 DD               	br 		RunProgram
     275/      F8 :                     
     276/      F8 :                     
     277/      F8 :                     	align 	256
     278/     100 :                     	include expression.asm 												; expression evaluator, all arithmetic, atoi/itoa
(1)    1/     100 :                     ; ***************************************************************************************************************
(1)    2/     100 :                     ; ***************************************************************************************************************
(1)    3/     100 :                     ;
(1)    4/     100 :                     ;		File:		expression.asm
(1)    5/     100 :                     ;		Purpose:	Evaluate an ASCII expression.
(1)    6/     100 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     100 :                     ;		Date:		11th January 2017.
(1)    8/     100 :                     ;
(1)    9/     100 :                     ; ***************************************************************************************************************
(1)   10/     100 :                     ; ***************************************************************************************************************
(1)   11/     100 :                     
(1)   12/     100 :                     ; ***************************************************************************************************************
(1)   13/     100 :                     ;
(1)   14/     100 :                     ;	Expression Evaluator : L -> R evaluation with parenthesis.
(1)   15/     100 :                     ;
(1)   16/     100 :                     ;	rSrc 			points to ASCIIZ expression, next character on exit. 
(1)   17/     100 :                     ;	rExprPC 		runs in this R(P), this is mandatory.
(1)   18/     100 :                     ;	rVarPtr.1 		points to variables
(1)   19/     100 :                     ; 	rParam1 		returned value of expression.
(1)   20/     100 :                     ;	rSpecialHandler	Routine (ends with sep rExprPC) which processes the provided character for special values
(1)   21/     100 :                     ;					e.g. side effect variables like ?. Char in D, zeroes D if the character is found and processed,
(1)   22/     100 :                     ;					in which case the result should be in rParam2
(1)   23/     100 :                     ;
(1)   24/     100 :                     ;	This does not report errors. VTL-2 does not. So if you have an error then the result returned may be somewhat
(1)   25/     100 :                     ;	unexpected and should not be relied on, despite what the VTL-2 manual hints :)
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 7 - 18/1/2017 16:31:26


(1)   26/     100 :                     ;
(1)   27/     100 :                     ;	Note this routine breaks most of the registers R6-R15. If this is called recursively it must still run in
(1)   28/     100 :                     ;	rExprPC and the original rExprPC,rSrc,rParenthesisLevel and rSaveStack must be saved. rVarPtr does not change
(1)   29/     100 :                     ;	but must be restored if changed by an external routine.
(1)   30/     100 :                     ;
(1)   31/     100 :                     ;	The routine is designed to occupy two complete pages. At present there are about 16 bytes free at the end of
(1)   32/     100 :                     ;	each page allowing for bug fixing, if the first page is preceded by the preamble (dis ; loading r3 ; sep r3)
(1)   33/     100 :                     ;
(1)   34/     100 :                     ; ***************************************************************************************************************
(1)   35/     100 :                     
(1)   36/     100 :                     __EXPRExitDec:
(1)   37/     100 : 28                  	dec 	rSrc 														; unpick bad source gets
(1)   38/     101 :                     __EXPRExit:
(1)   39/     101 : 8B                  	glo 	rSaveStack 													; because we don't handle errors properly we 
(1)   40/     102 : A2                  	plo 	r2 															; may have incomplete operations on exit.
(1)   41/     103 : 9B                  	ghi 	rSaveStack 													; (VTL-2 does not report expression syntax errors)
(1)   42/     104 : B2                  	phi 	r2
(1)   43/     105 : 22                  	dec 	r2 															; load top most expression which is the answer
(1)   44/     106 : 42                  	lda 	r2 															; if it actually worked.
(1)   45/     107 : AE                  	plo 	rParam1
(1)   46/     108 : 42                  	lda 	r2
(1)   47/     109 : BE                  	phi 	rParam1
(1)   48/     10A : (MACRO)             	return
(1)   48/     10A : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)   49/     10B :                     
(1)   50/     10B :                     EXPREvaluate:
(1)   51/     10B : E2                  	sex 	r2 															; using X = 2 again
(1)   52/     10C : F8 00               	ldi 	0 															; clear parenthesis level to 0.
(1)   53/     10E : AA                  	plo 	rParenthesisLevel 
(1)   54/     10F :                     
(1)   55/     10F : 82                  	glo	 	r2 															; save original stack position
(1)   56/     110 : AB                  	plo 	rSaveStack
(1)   57/     111 : 92                  	ghi 	r2
(1)   58/     112 : BB                  	phi 	rSaveStack 
(1)   59/     113 :                     
(1)   60/     113 :                     __EXPRNewLevel:	
(1)   61/     113 : F8 00               	ldi 	0 															; push $0000  + on the stack.
(1)   62/     115 : 73                  	stxd 																; MSB first
(1)   63/     116 : 73                  	stxd 																; LSB
(1)   64/     117 : F8 2B               	ldi 	'+' 												 		; the put '+' on the stack as pending operation.
(1)   65/     119 : 73                  	stxd
(1)   66/     11A : 1A                  	inc 	rParenthesisLevel 											; bump the parenthesis level up 1.
(1)   67/     11B :                     ;
(1)   68/     11B :                     ;		On reaching this point, we are looking for a new Term.
(1)   69/     11B :                     ;
(1)   70/     11B :                     __EXPRNewTerm:
(1)   71/     11B : 88                  	glo 	rSrc 														; put rSrc into rParam1
(1)   72/     11C : AE                  	plo 	rParam1
(1)   73/     11D : 98                  	ghi 	rSrc
(1)   74/     11E : BE                  	phi 	rParam1
(1)   75/     11F :                     
(1)   76/     11F : (MACRO)             	lrx 	rUtilPC,ASCIIToInteger 										; call the atoi() routine.
(1)   76/     11F : F8 02                       ldi     (ASCIITOINTEGER)/256
(1)   76/     121 : BC                          phi     RUTILPC
(1)   76/     122 : F8 B0                       ldi     (ASCIITOINTEGER)&255
(1)   76/     124 : AC                          plo     RUTILPC
(1)   77/     125 : 79                  	mark
(1)   78/     126 : DC                  	sep 	rUtilPC
(1)   79/     127 : 22                  	dec 	r2 		
(1)   80/     128 :                     
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 8 - 18/1/2017 16:31:26


(1)   81/     128 : FC FF               	adi 	0FFh 														; sets DF if non zero value returned
(1)   82/     12A : 8E                  	glo 	rParam1 													; constant rParam1 back into rSrc
(1)   83/     12B : A8                  	plo 	rSrc
(1)   84/     12C : 9E                  	ghi 	rParam1
(1)   85/     12D : B8                  	phi 	rSrc
(1)   86/     12E : 33 66               	bdf 	__EXPRGotTerm 												; if constant then done.
(1)   87/     130 :                     
(1)   88/     130 : 48                  	lda 	rSrc 														; look at character.
(1)   89/     131 : 32 00               	bz 		__EXPRExitDec 												; none provided.
(1)   90/     133 : FB 22               	xri 	'"'															; is it quote mark
(1)   91/     135 : 32 5E               	bz 		__EXPRGotCharacter 											; if so do that handler.
(1)   92/     137 : FB 0A               	xri	 	'('!'"' 													; is it open parenthesis.
(1)   93/     139 : 32 13               	bz		__EXPRNewLevel 												; if so open new level.
(1)   94/     13B : FB 12               	xri 	':'!'('														; is it new array ?
(1)   95/     13D : 32 56               	bz 		__EXPRArray
(1)   96/     13F : FB 3A               	xri 	':' 														; so make it back to the correct character.
(1)   97/     141 : D9                  	sep 	rSpecialHandler 											; check for 'special ones'
(1)   98/     142 : 32 66               	bz 		__EXPRGotTerm 												; if found one, we've got a term.
(1)   99/     144 :                     
(1)  100/     144 : FC 9F               	adi 	256-'a' 													; a+ will generate DF
(1)  101/     146 : 3B 4A               	bnf 	__EXPRNotLower
(1)  102/     148 : 7F 20               	smbi 	32
(1)  103/     14A :                     __EXPRNotLower:	
(1)  104/     14A : FF 9F               	smi 	256-'a'
(1)  105/     14C :                     
(1)  106/     14C : FA 3F               	ani 	03Fh 														; convert to six bit ASCII.
(1)  107/     14E : FE                  	shl 																; byte size to word size
(1)  108/     14F : A6                  	plo 	rVarPtr 													; now point to variable
(1)  109/     150 : 46                  	lda 	rVarPtr 													; read LSB into Param2
(1)  110/     151 : AF                  	plo 	rParam2
(1)  111/     152 : 06                  	ldn 	rVarPtr 													; and MSB
(1)  112/     153 : BF                  	phi 	rParam2
(1)  113/     154 : 30 66               	br 		__EXPRGotTerm 
(1)  114/     156 :                     ;
(1)  115/     156 :                     ;	Found an array : - same as open parenthesis except we stack a '@'
(1)  116/     156 :                     ;	
(1)  117/     156 :                     __EXPRArray:
(1)  118/     156 : F8 40               	ldi 	'@' 														; push @@@ on the stack,  the first two don't matter.
(1)  119/     158 : 73                  	stxd
(1)  120/     159 : 73                  	stxd
(1)  121/     15A : 73                  	stxd
(1)  122/     15B : 1A                  	inc 	rParenthesisLevel 											; it's like bracket with a different operator.
(1)  123/     15C : 30 1B               	br 		__EXPRNewTerm
(1)  124/     15E :                     ;
(1)  125/     15E :                     ;	Found a "<char>" 
(1)  126/     15E :                     ;
(1)  127/     15E :                     __EXPRGotCharacter:
(1)  128/     15E : BF                  	phi 	rParam2 													; clear high byte of rParam2.
(1)  129/     15F : 48                  	lda 	rSrc 														; get character in quotes, skip over it
(1)  130/     160 : 32 00               	bz 		__EXPRExitDec 												; none provided, exit backing up.
(1)  131/     162 : AF                  	plo 	rParam2 													; put in rParam2.0
(1)  132/     163 : 48                  	lda 	rSrc 														; look for what should be a quote but we dont check
(1)  133/     164 : 32 00               	bz 		__EXPRExitDec
(1)  134/     166 :                     ;
(1)  135/     166 :                     ;	New term is in rParam2. Look at the TOS expression to do, look it up and do it.
(1)  136/     166 :                     ;
(1)  137/     166 :                     __EXPRGotTerm:  														; new term is in rParam2.
(1)  138/     166 : 12                  	inc 	r2 															; point stack to operator.
(1)  139/     167 : (MACRO)             	lrx 	rParam1,(__OperatorTable-2) 								; rParam1 is the operator look up table.
(1)  139/     167 : F8 01                       ldi     ((__OPERATORTABLE-2))/256
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 9 - 18/1/2017 16:31:26


(1)  139/     169 : BE                          phi     RPARAM1
(1)  139/     16A : F8 AC                       ldi     ((__OPERATORTABLE-2))&255
(1)  139/     16C : AE                          plo     RPARAM1
(1)  140/     16D :                     __EXPRFindOperation:
(1)  141/     16D : 1E                  	inc 	rParam1
(1)  142/     16E : 1E                  	inc 	rParam1
(1)  143/     16F : 4E                  	lda 	rParam1 													; look to see what it is.
(1)  144/     170 : 32 75               	bz 		__EXPRFoundOperation 										; end of table.
(1)  145/     172 : F3                  	xor 																; same as stacked operator
(1)  146/     173 : 3A 6D               	bnz 	__EXPRFindOperation 
(1)  147/     175 :                     __EXPRFoundOperation:	
(1)  148/     175 : 42                  	lda 	r2 															; load the stacked value into rParenthesisLevel.1
(1)  149/     176 : BA                  	phi 	rParenthesisLevel
(1)  150/     177 : 4E                  	lda 	rParam1 													; put address of routine into rUtilPC
(1)  151/     178 : AC                  	plo 	rUtilPC
(1)  152/     179 : 0E                  	ldn 	rParam1
(1)  153/     17A : BC                  	phi 	rUtilPC
(1)  154/     17B :                     
(1)  155/     17B : 42                  	lda 	r2 															; read TOS for into param1
(1)  156/     17C : AE                  	plo 	rParam1
(1)  157/     17D : 02                  	ldn 	r2
(1)  158/     17E : BE                  	phi 	rParam1
(1)  159/     17F : 79                  	mark  																; and call the routine.
(1)  160/     180 : DC                  	sep 	rUtilPC
(1)  161/     181 : 22                  	dec 	r2
(1)  162/     182 :                     
(1)  163/     182 :                     ;
(1)  164/     182 :                     ;	Having got the result, check to see if it was divide, if so write out the remainder to '%'
(1)  165/     182 :                     ;
(1)  166/     182 : 9A                  	ghi 	rParenthesisLevel 											; get the operator
(1)  167/     183 : FB 2F               	xri 	'/'															; was it divide ?
(1)  168/     185 : 3A 8F               	bnz 	__EXPRNotDivide
(1)  169/     187 : F8 4A               	ldi 	('%' & 03Fh) * 2 											; point rVarPtr to % variable
(1)  170/     189 : A6                  	plo 	rVarPtr
(1)  171/     18A : 8F                  	glo 	rParam2 													; save remainder there
(1)  172/     18B : 56                  	str 	rVarPtr
(1)  173/     18C : 9F                  	ghi 	rParam2
(1)  174/     18D : 16                  	inc 	rVarPtr
(1)  175/     18E : 56                  	str 	rVarPtr
(1)  176/     18F :                     __EXPRNotDivide:	
(1)  177/     18F :                     
(1)  178/     18F : 9E                  	ghi 	rParam1 													; push the result back on the stack.
(1)  179/     190 : 73                  	stxd
(1)  180/     191 : 8E                  	glo 	rParam1
(1)  181/     192 : 73                  	stxd
(1)  182/     193 :                     ;
(1)  183/     193 :                     ;	Get the next operation, this is normally stacked, except if ) in which case the bracketed operation is closed
(1)  184/     193 :                     ;
(1)  185/     193 :                     __EXPRSkipSpace:
(1)  186/     193 : 48                  	lda 	rSrc 														; get the next operator.
(1)  187/     194 : 32 00               	bz 		__EXPRExitDec 												; done the next operator.
(1)  188/     196 : FB 20               	xri 	' '
(1)  189/     198 : 32 93               	bz 		__EXPRSkipSpace
(1)  190/     19A : FB 09               	xri 	')'!' '														; was it )
(1)  191/     19C : 32 A3               	bz 		__EXPRDestackBracket
(1)  192/     19E : FB 29               	xri 	')' 														; get it back
(1)  193/     1A0 : 73                  	stxd 																; push it on the stack.
(1)  194/     1A1 : 30 1B               	br 		__EXPRNewTerm 												; and get the next term.
(1)  195/     1A3 :                     ;
(1)  196/     1A3 :                     ; 	Close the bracketed operation
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 10 - 18/1/2017 16:31:26


(1)  197/     1A3 :                     ;
(1)  198/     1A3 :                     __EXPRDestackBracket:
(1)  199/     1A3 : 2A                  	dec 	rParenthesisLevel 											; dec brackets
(1)  200/     1A4 : 8A                  	glo 	rParenthesisLevel 											; if zero it is end of expression ) so exit.	
(1)  201/     1A5 : 32 01               	bz 		__EXPRExit
(1)  202/     1A7 :                     
(1)  203/     1A7 : 12                  	inc 	r2 															; pop rParam2 off the stack.
(1)  204/     1A8 : 42                  	lda 	r2
(1)  205/     1A9 : AF                  	plo 	rParam2
(1)  206/     1AA : 02                  	ldn 	r2
(1)  207/     1AB : BF                  	phi 	rParam2
(1)  208/     1AC :                     
(1)  209/     1AC : 30 66               	br 		__EXPRGotTerm 												; go back and do the stacked operation below
(1)  210/     1AE :                     
(1)  211/     1AE :                     ; ***************************************************************************************************************
(1)  212/     1AE :                     ;
(1)  213/     1AE :                     ;	Look up table for binary operators. 0 signifies the end of the table and default, so it covers - > < =
(1)  214/     1AE :                     ;
(1)  215/     1AE :                     ; ***************************************************************************************************************
(1)  216/     1AE :                     
(1)  217/     1AE :                     oper macro chdb,addr
(1)  218/     1AE :                     	db 		chdb,(addr) & 255,(addr) / 256
(1)  219/     1AE :                     	endm 
(1)  220/     1AE :                     
(1)  221/     1AE :                     __OperatorTable:
(1)  222/     1AE : (MACRO)             	oper 	'+',__OpAdd 
(1)  222/     1AE : 2B 00 02                    db              '+',(__OPADD) & 255,(__OPADD) / 256
(1)  223/     1B1 : (MACRO)             	oper	'*',Multiply
(1)  223/     1B1 : 2A 8B 02                    db              '*',(MULTIPLY) & 255,(MULTIPLY) / 256
(1)  224/     1B4 : (MACRO)             	oper 	'/',Divide
(1)  224/     1B4 : 2F BF 01                    db              '/',(DIVIDE) & 255,(DIVIDE) / 256
(1)  225/     1B7 : (MACRO)             	oper 	'@',__OpLookUp 
(1)  225/     1B7 : 40 0D 02                    db              '@',(__OPLOOKUP) & 255,(__OPLOOKUP) / 256
(1)  226/     1BA : (MACRO)             	oper 	0,__OpSub
(1)  226/     1BA : 00 26 02                    db              0,(__OPSUB) & 255,(__OPSUB) / 256
(1)  227/     1BD :                     
(1)  228/     1BD :                     ; ***************************************************************************************************************
(1)  229/     1BD :                     ;
(1)  230/     1BD :                     ;										Divide Code here
(1)  231/     1BD :                     ;
(1)  232/     1BD :                     ; ***************************************************************************************************************
(1)  233/     1BD :                     
(1)  234/     1BD :                     	include utility/divide.asm
(2)    1/     1BD :                     ; ***************************************************************************************************************
(2)    2/     1BD :                     ; ***************************************************************************************************************
(2)    3/     1BD :                     ;
(2)    4/     1BD :                     ;		File:		divide.asm
(2)    5/     1BD :                     ;		Purpose:	Divide two 16 bit integers.
(2)    6/     1BD :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(2)    7/     1BD :                     ;		Date:		9th January 2017.
(2)    8/     1BD :                     ;		Size: 		54 bytes.
(2)    9/     1BD :                     ;
(2)   10/     1BD :                     ; ***************************************************************************************************************
(2)   11/     1BD :                     ; ***************************************************************************************************************
(2)   12/     1BD :                     
(2)   13/     1BD :                     ; *******************************************************************************************************************
(2)   14/     1BD :                     ;
(2)   15/     1BD :                     ;				Calculate rParam1 / rParam2.  Result in rParam1. Remainder in rParam2.
(2)   16/     1BD :                     ;
(2)   17/     1BD :                     ; *******************************************************************************************************************
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(divide.asm) - page 11 - 18/1/2017 16:31:26


(2)   18/     1BD :                     
(2)   19/     1BD :                     __DIVExit:
(2)   20/     1BD : 12                  	inc 	r2 															; point to XP on the stack
(2)   21/     1BE : (MACRO)             	return
(2)   21/     1BE : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(2)   22/     1BF :                     
(2)   23/     1BF :                     Divide:
(2)   24/     1BF : E2                  	sex 	r2 															; back using R2 as the index register
(2)   25/     1C0 :                     																		; rParam1 is the dividend.
(2)   26/     1C0 :                     																		; rParam2 is the remainder.
(2)   27/     1C0 :                     																		; tos is [divisor:2][counter:1] 
(2)   28/     1C0 :                     
(2)   29/     1C0 : F8 10               	ldi 	16															; push counter on stack - 16 because post	
(2)   30/     1C2 : 73                  	stxd 																; decrements in main loop.
(2)   31/     1C3 :                     
(2)   32/     1C3 : 9F                  	ghi 	rParam2 													; push divisor on stack.
(2)   33/     1C4 : 73                  	stxd
(2)   34/     1C5 : 8F                  	glo 	rParam2
(2)   35/     1C6 : 52                  	str 	r2 	
(2)   36/     1C7 :                     	
(2)   37/     1C7 : F8 00               	ldi 	0 															; clear the remainder
(2)   38/     1C9 : BF                  	phi 	rParam2
(2)   39/     1CA : AF                  	plo 	rParam2
(2)   40/     1CB : F4                  	add 																; anything + 0 clears DF.
(2)   41/     1CC :                     
(2)   42/     1CC :                     __DIVLoopIncR2IncR2:
(2)   43/     1CC : 12                  	inc		r2 															; point R2 back to the counter.
(2)   44/     1CD :                     __DIVLoopIncR2:
(2)   45/     1CD : 12                  	inc 	r2
(2)   46/     1CE :                     
(2)   47/     1CE :                     __DIVLoop:
(2)   48/     1CE :                     
(2)   49/     1CE : 8E                  	glo 	rParam1 													; shift DF into dividend, shift old bit 15 to DF
(2)   50/     1CF : 7E                  	rshl
(2)   51/     1D0 : AE                  	plo 	rParam1
(2)   52/     1D1 : 9E                  	ghi 	rParam1
(2)   53/     1D2 : 7E                  	rshl
(2)   54/     1D3 : BE                  	phi 	rParam1
(2)   55/     1D4 :                     
(2)   56/     1D4 : 02                  	ldn 	r2 															; look at counter.
(2)   57/     1D5 : 32 BD               	bz 		__DIVExit 													; if zero then complete (decrement done later)
(2)   58/     1D7 :                     
(2)   59/     1D7 : 8F                  	glo	 	rParam2 													; shift DF into then remainder (rParam2)
(2)   60/     1D8 : 7E                  	rshl
(2)   61/     1D9 : AF                  	plo 	rParam2
(2)   62/     1DA : 9F                  	ghi 	rParam2
(2)   63/     1DB : 7E                  	rshl
(2)   64/     1DC : BF                  	phi 	rParam2
(2)   65/     1DD :                     
(2)   66/     1DD : 02                  	ldn 	r2 															; decrement the counter (AFTER the test)
(2)   67/     1DE : FF 01               	smi 	1
(2)   68/     1E0 : 73                  	stxd 																; when saving back, point R2 to divisor LSB.
(2)   69/     1E1 : 22                  	dec 	r2
(2)   70/     1E2 :                     
(2)   71/     1E2 : 8F                  	glo 	rParam2 													; calculate remainder.0 - divisor.0
(2)   72/     1E3 : F7                  	sm
(2)   73/     1E4 : 22                  	dec 	r2 															; save the interim value below the LSB.
(2)   74/     1E5 : 52                  	str 	r2
(2)   75/     1E6 : 12                  	inc 	r2 															; to LSB
(2)   76/     1E7 : 12                  	inc		r2 															; to MSB
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(divide.asm) - page 12 - 18/1/2017 16:31:26


(2)   77/     1E8 : 9F                  	ghi 	rParam2 													; calculate remainder.1 - divisor.1
(2)   78/     1E9 : 77                  	smb
(2)   79/     1EA :                     
(2)   80/     1EA : 3B CD               	bnf 	__DIVLoopIncR2 												; if DF = 0 then inc r2 (to ctr) and loop back
(2)   81/     1EC :                     
(2)   82/     1EC : BF                  	phi 	rParam2 													; copy result to remainder
(2)   83/     1ED : 22                  	dec 	r2 															; to divisor.0
(2)   84/     1EE : 22                  	dec 	r2 															; to temp result
(2)   85/     1EF : 42                  	lda 	r2 															; get temp result, to divisor.0
(2)   86/     1F0 : AF                  	plo 	rParam2
(2)   87/     1F1 : 30 CC               	br 		__DIVLoopIncR2IncR2 										; go back, inc r2 twice to counter
(2)   88/     1F3 :                     
(1)  235/     1F3 :                     	align 	256
(1)  236/     200 :                     	
(1)  237/     200 :                     ; ***************************************************************************************************************
(1)  238/     200 :                     ;
(1)  239/     200 :                     ;								Addition. rParam1 := rParam1 + rParam2
(1)  240/     200 :                     ;
(1)  241/     200 :                     ; ***************************************************************************************************************
(1)  242/     200 :                     
(1)  243/     200 :                     __OpAdd:
(1)  244/     200 : E2                  	sex		r2 														; rParam1 := rParam1 + rParam2
(1)  245/     201 : 8F                  	glo 	rParam2
(1)  246/     202 : 52                  	str 	r2
(1)  247/     203 : 8E                  	glo 	rParam1
(1)  248/     204 : F4                  	add	
(1)  249/     205 : AE                  	plo 	rParam1
(1)  250/     206 : 9F                  	ghi 	rParam2
(1)  251/     207 : 52                  	str 	r2
(1)  252/     208 : 9E                  	ghi 	rParam1
(1)  253/     209 : 74                  	adc
(1)  254/     20A : BE                  	phi 	rParam1
(1)  255/     20B : 12                  	inc 	r2
(1)  256/     20C : (MACRO)             	return
(1)  256/     20C : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)  257/     20D :                     
(1)  258/     20D :                     ; ***************************************************************************************************************
(1)  259/     20D :                     ;
(1)  260/     20D :                     ;				Array Lookup. rParam1 := Memory['&' + rParam * 2]. '*' is the top of memory variable.
(1)  261/     20D :                     ;
(1)  262/     20D :                     ; ***************************************************************************************************************
(1)  263/     20D :                     
(1)  264/     20D :                     __OpLookUp: 														; rParam1 := Memory[& + rParam2 * 2]
(1)  265/     20D : E2                  	sex 	r2
(1)  266/     20E : 8F                  	glo 	rParam2 												; double rParam2
(1)  267/     20F : FE                  	shl
(1)  268/     210 : AF                  	plo 	rParam2
(1)  269/     211 : 9F                  	ghi 	rParam2
(1)  270/     212 : 7E                  	rshl
(1)  271/     213 : BF                  	phi 	rParam2
(1)  272/     214 : F8 4C               	ldi 	('&' & 03Fh) * 2 										; point VarPtr to '&' variable
(1)  273/     216 : A6                  	plo 	rVarPtr
(1)  274/     217 : E6                  	sex 	rVarPtr
(1)  275/     218 :                     
(1)  276/     218 : 8F                  	glo 	rParam2 												; add contents of & to rParam2 
(1)  277/     219 : F4                  	add
(1)  278/     21A : AF                  	plo 	rParam2		
(1)  279/     21B : 16                  	inc 	rVarPtr
(1)  280/     21C : 9F                  	ghi 	rParam2
(1)  281/     21D : 74                  	adc
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 13 - 18/1/2017 16:31:26


(1)  282/     21E : BF                  	phi 	rParam2 
(1)  283/     21F :                     
(1)  284/     21F : 4F                  	lda 	rParam2 												; read rParam2 into rParam1
(1)  285/     220 : AE                  	plo 	rParam1
(1)  286/     221 : 0F                  	ldn 	rParam2
(1)  287/     222 : BE                  	phi 	rParam1
(1)  288/     223 :                     __OpReturn:	
(1)  289/     223 : E2                  	sex 	r2
(1)  290/     224 : 12                  	inc 	r2
(1)  291/     225 : (MACRO)             	return
(1)  291/     225 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)  292/     226 :                     
(1)  293/     226 :                     ; ***************************************************************************************************************
(1)  294/     226 :                     ;
(1)  295/     226 :                     ;								Subtraction. rParam1 := rParam1 - rParam2
(1)  296/     226 :                     ;									 (Also > < = which return 0 or 1)
(1)  297/     226 :                     ;
(1)  298/     226 :                     ; ***************************************************************************************************************
(1)  299/     226 :                     
(1)  300/     226 :                     __OpSub:															; rParam1 := rParam1 - rParam2
(1)  301/     226 : E2                  	sex		r2
(1)  302/     227 : 8F                  	glo 	rParam2
(1)  303/     228 : 52                  	str 	r2
(1)  304/     229 : 8E                  	glo 	rParam1
(1)  305/     22A : F7                  	sm
(1)  306/     22B : AE                  	plo 	rParam1
(1)  307/     22C : 9F                  	ghi 	rParam2
(1)  308/     22D : 52                  	str 	r2
(1)  309/     22E : 9E                  	ghi 	rParam1
(1)  310/     22F : 77                  	smb
(1)  311/     230 : BE                  	phi 	rParam1
(1)  312/     231 :                     
(1)  313/     231 : 9A                  	ghi 	rParenthesisLevel 										; this is the saved operator character
(1)  314/     232 : FB 2D               	xri 	'-'														; exit if '-'
(1)  315/     234 : 32 23               	bz 		__OpReturn
(1)  316/     236 : FB 10               	xri 	'-'!'='													; check if equals.
(1)  317/     238 : 32 47               	bz 		__OpEquality
(1)  318/     23A :                     ;
(1)  319/     23A :                     ;	Handle < > option. Note that > is actually the >= operation and is also the overall default.
(1)  320/     23A :                     ;
(1)  321/     23A : FB 03               	xri 	'>'!'='													; will now be 0 if >= , nonzero for < if anything else.
(1)  322/     23C : 32 40               	bz 		__OpLT0 	
(1)  323/     23E : F8 01               	ldi 	1
(1)  324/     240 :                     __OpLT0: 															; now 0 if >, 1 if <
(1)  325/     240 : 7C 00               	adci 	0 														; will now be odd if correct - adds in result from subtract
(1)  326/     242 : FA 01               	ani 	1 														; so isolate bit zero
(1)  327/     244 : 30 51               	br 		__OpWriteBoolean 										; and write it out.
(1)  328/     246 :                     
(1)  329/     246 : (MACRO)             	return
(1)  329/     246 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)  330/     247 :                     ;
(1)  331/     247 :                     ;	Handle = option
(1)  332/     247 :                     ;
(1)  333/     247 :                     __OpEquality:
(1)  334/     247 : 8E                  	glo 	rParam1 												; get low result
(1)  335/     248 : 3A 4B               	bnz 	__OpEqNZ 	
(1)  336/     24A : 9E                  	ghi 	rParam1 												; if zero get high result
(1)  337/     24B :                     __OpEqNZ:															; if zero here both are zero e.g. it is 'true'
(1)  338/     24B : 32 4F               	bz 		__OpEqIsTrue 											
(1)  339/     24D : F8 01               	ldi 	1 															
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 14 - 18/1/2017 16:31:26


(1)  340/     24F :                     __OpEqIsTrue:														; now 0 true 1 false
(1)  341/     24F : FB 01               	xri 	1 														; now 1 true 0 false
(1)  342/     251 :                     __OpWriteBoolean:	
(1)  343/     251 : AE                  	plo 	rParam1 												; put into rParam1
(1)  344/     252 : F8 00               	ldi 	0
(1)  345/     254 : BE                  	phi 	rParam1 							
(1)  346/     255 : 30 23               	br 		__OpReturn
(1)  347/     257 :                     
(1)  348/     257 :                     ; ***************************************************************************************************************
(1)  349/     257 :                     ;
(1)  350/     257 :                     ;										Outstanding utility routines fit here
(1)  351/     257 :                     ;
(1)  352/     257 :                     ; ***************************************************************************************************************
(1)  353/     257 :                     
(1)  354/     257 :                     	include utility/itoa.asm
(2)    1/     257 :                     ; ***************************************************************************************************************
(2)    2/     257 :                     ; ***************************************************************************************************************
(2)    3/     257 :                     ;
(2)    4/     257 :                     ;		File:		itoa.asm
(2)    5/     257 :                     ;		Purpose:	Convert 16 bit integer to ASCIIZ string
(2)    6/     257 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(2)    7/     257 :                     ;		Date:		10th January 2017.
(2)    8/     257 :                     ;		Size: 		47 bytes.
(2)    9/     257 :                     ;
(2)   10/     257 :                     ; ***************************************************************************************************************
(2)   11/     257 :                     ; ***************************************************************************************************************
(2)   12/     257 :                     
(2)   13/     257 :                     ; *******************************************************************************************************************
(2)   14/     257 :                     ;
(2)   15/     257 :                     ;	rParam1 is the number to convert. rParam2 is the end of the buffer, the digits are written backwards. On exit.
(2)   16/     257 :                     ;	rParam2 points to the string terminated in a NULL character. The NULL character is at the original value
(2)   17/     257 :                     ;	of rParam2. 
(2)   18/     257 :                     ;
(2)   19/     257 :                     ; *******************************************************************************************************************
(2)   20/     257 :                     
(2)   21/     257 :                     __ITOAExit:
(2)   22/     257 : 12                  	inc 	r2
(2)   23/     258 : (MACRO)             	return
(2)   23/     258 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(2)   24/     259 :                     
(2)   25/     259 :                     IntegerToASCII:
(2)   26/     259 : E2                  	sex 	r2 															; index back at 2
(2)   27/     25A : F8 00               	ldi 	0 															; write the NULL terminator.
(2)   28/     25C : 5F                  	str 	rParam2
(2)   29/     25D :                     __ITOALoop:
(2)   30/     25D : 73                  	stxd 																; push dummy value, digit return stored here.
(2)   31/     25E : 9F                  	ghi 	rParam2 													; push rParam2 on the stack.
(2)   32/     25F : 73                  	stxd
(2)   33/     260 : 8F                  	glo	 	rParam2
(2)   34/     261 : 73                  	stxd
(2)   35/     262 : F8 00               	ldi 	0		 													; set to divide by 10.
(2)   36/     264 : BF                  	phi 	rParam2
(2)   37/     265 : F8 0A               	ldi 	10
(2)   38/     267 : AF                  	plo 	rParam2
(2)   39/     268 : F8 01               	ldi 	Divide/256
(2)   40/     26A : BD                  	phi 	rSubPC
(2)   41/     26B : F8 BF               	ldi 	Divide&255
(2)   42/     26D : AD                  	plo 	rSubPC
(2)   43/     26E : 79                  	mark  
(2)   44/     26F : DD                  	sep 	rSubPC 														; do the call.
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(itoa.asm) - page 15 - 18/1/2017 16:31:26


(2)   45/     270 : 12                  	inc 	r2
(2)   46/     271 : 12                  	inc 	r2 															; save digit result in dummy space
(2)   47/     272 : 8F                  	glo 	rParam2
(2)   48/     273 : 73                  	stxd 
(2)   49/     274 : 22                  	dec 	r2 															; now points to memory pointer for result
(2)   50/     275 : 42                  	lda 	r2 															; restore buffer pointer
(2)   51/     276 : AF                  	plo 	rParam2
(2)   52/     277 : 42                  	lda 	r2
(2)   53/     278 : BF                  	phi 	rParam2
(2)   54/     279 : 02                  	ldn 	r2 															; restore digit
(2)   55/     27A : F9 30               	ori		'0'															; make ASCII 
(2)   56/     27C : 2F                  	dec 	rParam2 													; back one character.
(2)   57/     27D : 5F                  	str 	rParam2 													; write into buffer
(2)   58/     27E :                     
(2)   59/     27E : 8E                  	glo 	rParam1 													; go around again if non-zero
(2)   60/     27F : 3A 5D               	bnz 	__ITOALoop
(2)   61/     281 : 9E                  	ghi 	rParam1
(2)   62/     282 : 3A 5D               	bnz 	__ITOALoop
(2)   63/     284 : 30 57               	br 		__ITOAExit 													; and prepare to exit.
(1)  355/     286 :                     	include utility/multiply.asm
(2)    1/     286 :                     ; ***************************************************************************************************************
(2)    2/     286 :                     ; ***************************************************************************************************************
(2)    3/     286 :                     ;
(2)    4/     286 :                     ;		File:		multiply.asm
(2)    5/     286 :                     ;		Purpose:	Multiply two 16 bit integers.
(2)    6/     286 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(2)    7/     286 :                     ;		Date:		9th January 2017.
(2)    8/     286 :                     ;		Size: 		41 bytes.
(2)    9/     286 :                     ;
(2)   10/     286 :                     ; ***************************************************************************************************************
(2)   11/     286 :                     ; ***************************************************************************************************************
(2)   12/     286 :                     
(2)   13/     286 :                     ; *******************************************************************************************************************
(2)   14/     286 :                     ;
(2)   15/     286 :                     ;	Multiply the values in rParam1 and rParam2 , returning result in rParam1.
(2)   16/     286 :                     ;
(2)   17/     286 :                     ; *******************************************************************************************************************
(2)   18/     286 :                     
(2)   19/     286 :                     __MULExit:
(2)   20/     286 : 42                  	lda 	r2 															; pop LSB result off stack.
(2)   21/     287 : AE                  	plo 	rParam1
(2)   22/     288 : 42                  	lda 	r2  														; pop MSB result off stack, do inc r2
(2)   23/     289 : BE                  	phi 	rParam1
(2)   24/     28A : (MACRO)             	return
(2)   24/     28A : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(2)   25/     28B :                     
(2)   26/     28B :                     Multiply:
(2)   27/     28B : E2                  	sex 	r2 															; back using R2 as the index register
(2)   28/     28C : F8 00               	ldi 	0 															; reset the result, which is on the stack.
(2)   29/     28E : 73                  	stxd	
(2)   30/     28F : 52                  	str 	r2
(2)   31/     290 :                     
(2)   32/     290 :                     __MULLoop:
(2)   33/     290 :                     
(2)   34/     290 : 9E                  	ghi 	rParam1 													; shift first multiplier right into DF
(2)   35/     291 : F6                  	shr
(2)   36/     292 : BE                  	phi 	rParam1
(2)   37/     293 : 8E                  	glo 	rParam1
(2)   38/     294 : 76                  	rshr
(2)   39/     295 : AE                  	plo 	rParam1
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(multiply.asm) - page 16 - 18/1/2017 16:31:26


(2)   40/     296 : 3B 9F               	bnf 	__MULDontAdd 												; if DF is set add rParam2 to the result.
(2)   41/     298 :                     
(2)   42/     298 : 8F                  	glo 	rParam2 													; add rParam2 to result on TOS.
(2)   43/     299 : F4                  	add 
(2)   44/     29A : 52                  	str 	r2
(2)   45/     29B : 12                  	inc 	r2
(2)   46/     29C : 9F                  	ghi 	rParam2
(2)   47/     29D : 74                  	adc
(2)   48/     29E : 73                  	stxd 
(2)   49/     29F :                     
(2)   50/     29F :                     __MULDontAdd:
(2)   51/     29F : 8F                  	glo 	rParam2 													; shift rParam2 left
(2)   52/     2A0 : FE                  	shl
(2)   53/     2A1 : AF                  	plo 	rParam2
(2)   54/     2A2 : 9F                  	ghi 	rParam2
(2)   55/     2A3 : 7E                  	rshl
(2)   56/     2A4 : BF                  	phi 	rParam2
(2)   57/     2A5 :                     
(2)   58/     2A5 : 8E                  	glo 	rParam1 													; is first multiplier non zero, if not go back.
(2)   59/     2A6 : 3A 90               	bnz 	__MULLoop
(2)   60/     2A8 : 9E                  	ghi 	rParam1
(2)   61/     2A9 : 3A 90               	bnz 	__MULLoop
(2)   62/     2AB : 30 86               	br 		__MULExit 													; both are zero, so exit.	
(1)  356/     2AD :                     	include utility/atoi.asm
(2)    1/     2AD :                     ; ***************************************************************************************************************
(2)    2/     2AD :                     ; ***************************************************************************************************************
(2)    3/     2AD :                     ;
(2)    4/     2AD :                     ;		File:		atoi.asm
(2)    5/     2AD :                     ;		Purpose:	Extract 16 bit integer from ASCII string.
(2)    6/     2AD :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(2)    7/     2AD :                     ;		Date:		9th January 2017.
(2)    8/     2AD :                     ;		Size: 		67 bytes.
(2)    9/     2AD :                     ;
(2)   10/     2AD :                     ; ***************************************************************************************************************
(2)   11/     2AD :                     ; ***************************************************************************************************************
(2)   12/     2AD :                     
(2)   13/     2AD :                     ; *******************************************************************************************************************
(2)   14/     2AD :                     ;
(2)   15/     2AD :                     ;	Takes one value in rParam1, pointer to a string, returns number read in rParam2.
(2)   16/     2AD :                     ;	rParam1 points to the next character after the last one of the number.	
(2)   17/     2AD :                     ;	
(2)   18/     2AD :                     ;	On exit non-zero if a digit was read.
(2)   19/     2AD :                     ;
(2)   20/     2AD :                     ; *******************************************************************************************************************
(2)   21/     2AD :                     
(2)   22/     2AD :                     __ATOIExit:
(2)   23/     2AD : 2E                  	dec 	rParam1 													; undo the last read, wasn't a digit.
(2)   24/     2AE : 42                  	lda 	r2 															; read the flag for 'digits read'
(2)   25/     2AF : (MACRO)             	return
(2)   25/     2AF : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(2)   26/     2B0 :                     
(2)   27/     2B0 :                     ASCIIToInteger:
(2)   28/     2B0 : E2                  	sex 	r2 															; index back at 2
(2)   29/     2B1 : F8 00               	ldi 	0 															; clear number read
(2)   30/     2B3 : AF                  	plo 	rParam2
(2)   31/     2B4 : BF                  	phi 	rParam2
(2)   32/     2B5 : 52                  	str 	r2 															; [TOS] is count of digits read okay.
(2)   33/     2B6 :                     
(2)   34/     2B6 :                     __ATOILoop:
(2)   35/     2B6 : 4E                  	lda 	rParam1 													; read next character and bump
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(atoi.asm) - page 17 - 18/1/2017 16:31:26


(2)   36/     2B7 : FB 20               	xri 	' ' 														; skip over spaces.
(2)   37/     2B9 : 32 B6               	bz 		__ATOILoop 												
(2)   38/     2BB : FB 20               	xri 	' ' 														; fix it back.
(2)   39/     2BD : FC C6               	adi 	255-'9' 													; will cause DF if >= '9'
(2)   40/     2BF : 33 AD               	bdf 	__ATOIExit
(2)   41/     2C1 : FC 0A               	adi 	10 															; adding 10 will cause NF if < '0'	
(2)   42/     2C3 : 3B AD               	bnf 	__ATOIExit
(2)   43/     2C5 :                     
(2)   44/     2C5 : 73                  	stxd 																; push digit value, current value of number
(2)   45/     2C6 : 9F                  	ghi 	rParam2  													; on stack.
(2)   46/     2C7 : 73                  	stxd
(2)   47/     2C8 : 8F                  	glo 	rParam2
(2)   48/     2C9 : 52                  	str 	r2
(2)   49/     2CA :                     
(2)   50/     2CA :                     __ATOIDoubleRParam2 macro 												; macro that doubles the value in rParam2
(2)   51/     2CA :                     	glo 	rParam2 													
(2)   52/     2CA :                     	shl
(2)   53/     2CA :                     	plo 	rParam2
(2)   54/     2CA :                     	ghi 	rParam2
(2)   55/     2CA :                     	rshl
(2)   56/     2CA :                     	phi 	rParam2
(2)   57/     2CA :                     	endm
(2)   58/     2CA :                     
(2)   59/     2CA : (MACRO)             	__ATOIDoubleRParam2 												; rParam2 * 2
(2)   59/     2CA : 8F                          glo     rParam2                                                                                                         
(2)   59/     2CB : FE                          shl
(2)   59/     2CC : AF                          plo     rParam2
(2)   59/     2CD : 9F                          ghi     rParam2
(2)   59/     2CE : 7E                          rshl
(2)   59/     2CF : BF                          phi     rParam2
(2)   60/     2D0 : (MACRO)             	__ATOIDoubleRParam2 												; rParam2 * 4
(2)   60/     2D0 : 8F                          glo     rParam2                                                                                                         
(2)   60/     2D1 : FE                          shl
(2)   60/     2D2 : AF                          plo     rParam2
(2)   60/     2D3 : 9F                          ghi     rParam2
(2)   60/     2D4 : 7E                          rshl
(2)   60/     2D5 : BF                          phi     rParam2
(2)   61/     2D6 : 8F                  	glo 	rParam2 													; add stack values on there.
(2)   62/     2D7 : F4                  	add
(2)   63/     2D8 : AF                  	plo 	rParam2
(2)   64/     2D9 : 12                  	inc 	r2
(2)   65/     2DA : 9F                  	ghi 	rParam2
(2)   66/     2DB : 74                  	adc
(2)   67/     2DC : BF                  	phi 	rParam2  													; so now rParam * 5
(2)   68/     2DD : (MACRO)             	__ATOIDoubleRParam2 												; so now rParam * 10
(2)   68/     2DD : 8F                          glo     rParam2                                                                                                         
(2)   68/     2DE : FE                          shl
(2)   68/     2DF : AF                          plo     rParam2
(2)   68/     2E0 : 9F                          ghi     rParam2
(2)   68/     2E1 : 7E                          rshl
(2)   68/     2E2 : BF                          phi     rParam2
(2)   69/     2E3 :                     
(2)   70/     2E3 : 12                  	inc 	r2 															; point to digit value
(2)   71/     2E4 : 8F                  	glo 	rParam2
(2)   72/     2E5 : F4                  	add
(2)   73/     2E6 : AF                  	plo 	rParam2
(2)   74/     2E7 : 9F                  	ghi 	rParam2
(2)   75/     2E8 : 7C 00               	adci 	0
(2)   76/     2EA : BF                  	phi 	rParam2
(2)   77/     2EB :                     
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(atoi.asm) - page 18 - 18/1/2017 16:31:26


(2)   78/     2EB : F8 FF               	ldi 	0FFh 														; set the 'read a digit' flag.
(2)   79/     2ED : 52                  	str 	r2 
(2)   80/     2EE : 30 B6               	br 		__ATOILoop
(2)   81/     2F0 :                     
(1)  357/     2F0 :                     
     279/     2F0 :                     	align 	256 
     280/     300 :                     	include handler.asm 												; special routine handler.
(1)    1/     300 :                     ; ***************************************************************************************************************
(1)    2/     300 :                     ; ***************************************************************************************************************
(1)    3/     300 :                     ;
(1)    4/     300 :                     ;		File:		handler.asm
(1)    5/     300 :                     ;		Purpose:	Handle side-effect variables on read.
(1)    6/     300 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     300 :                     ;		Date:		11th January 2017.
(1)    8/     300 :                     ;
(1)    9/     300 :                     ; ***************************************************************************************************************
(1)   10/     300 :                     ; ***************************************************************************************************************
(1)   11/     300 :                     
(1)   12/     300 :                     ; ***************************************************************************************************************
(1)   13/     300 :                     ;
(1)   14/     300 :                     ;		This routine provides the variable in D. On exit, if D = 0 the "variable" has been accessed and
(1)   15/     300 :                     ;		put in rParam2. Otherwise D should be unchanged.
(1)   16/     300 :                     ;
(1)   17/     300 :                     ;		The right hand variables with side effects in VTL-2 are :-
(1)   18/     300 :                     ;
(1)   19/     300 :                     ;		?	input an integer (technically an expression .....)
(1)   20/     300 :                     ; 		$ 	input a single character
(1)   21/     300 :                     ;
(1)   22/     300 :                     ;		This is run with P = rSpecialHandler X = 2
(1)   23/     300 :                     ;
(1)   24/     300 :                     ;		Must preserve: rSrc, rVarPtr*, rExprPC, rParenthesisLevel, rSaveStack and of course R2.
(1)   25/     300 :                     ;
(1)   26/     300 :                     ;		* can be assumed constant.
(1)   27/     300 :                     ;
(1)   28/     300 :                     ;		Use: rUtilPC, rSubPC, rParam1, rParam2.
(1)   29/     300 :                     ;
(1)   30/     300 :                     ; ***************************************************************************************************************
(1)   31/     300 :                     
(1)   32/     300 :                     __SHExit:
(1)   33/     300 : D7                  	sep 	rExprPC
(1)   34/     301 :                     SpecialHandler:
(1)   35/     301 : FB 24               	xri 	'$'															; check if '$' (get character)
(1)   36/     303 : 32 0D               	bz 		__SHGetKey
(1)   37/     305 : FB 1B               	xri 	'$'!'?'														; check if '?' (get string expression)
(1)   38/     307 : 32 1C               	bz 		__SHInput
(1)   39/     309 : FB 3F               	xri 	'?'
(1)   40/     30B : 30 00               	br 		__SHExit
(1)   41/     30D :                     
(1)   42/     30D :                     ; ***************************************************************************************************************
(1)   43/     30D :                     ;
(1)   44/     30D :                     ;							$ operator. Returns a single key press in rParam2
(1)   45/     30D :                     ;
(1)   46/     30D :                     ; ***************************************************************************************************************
(1)   47/     30D :                     
(1)   48/     30D :                     __SHGetKey:
(1)   49/     30D : (MACRO)             	lrx 	rUtilPC,XIOGetKey 											; this is the external function which reads the keyboard
(1)   49/     30D : F8 05                       ldi     (XIOGETKEY)/256
(1)   49/     30F : BC                          phi     RUTILPC
(1)   49/     310 : F8 32                       ldi     (XIOGETKEY)&255
(1)   49/     312 : AC                          plo     RUTILPC
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(handler.asm) - page 19 - 18/1/2017 16:31:26


(1)   50/     313 : 79                  	mark 																; and it is called using the MARK method. 
(1)   51/     314 : DC                  	sep 	rUtilPC
(1)   52/     315 : 22                  	dec 	r2
(1)   53/     316 : AF                  	plo 	rParam2 													; put result in rParam2.0
(1)   54/     317 : F8 00               	ldi 	0 															; clear rParam2.1 and D, indicating successful processing.
(1)   55/     319 : BF                  	phi 	rParam2
(1)   56/     31A : 30 00               	br 		__SHExit 													; and exit.
(1)   57/     31C :                     
(1)   58/     31C :                     ; ***************************************************************************************************************
(1)   59/     31C :                     ;
(1)   60/     31C :                     ;							? operator. Inputs a string, evaluates it and returns.
(1)   61/     31C :                     ;
(1)   62/     31C :                     ; ***************************************************************************************************************
(1)   63/     31C :                     
(1)   64/     31C :                     __SHInput:
(1)   65/     31C : (MACRO)             	lrx 	rSubPC,XIOWriteCharacter 									; prompt.
(1)   65/     31C : F8 05                       ldi     (XIOWRITECHARACTER)/256
(1)   65/     31E : BD                          phi     RSUBPC
(1)   65/     31F : F8 3A                       ldi     (XIOWRITECHARACTER)&255
(1)   65/     321 : AD                          plo     RSUBPC
(1)   66/     322 : F8 3F               	ldi 	'?'
(1)   67/     324 : 79                  	mark
(1)   68/     325 : DD                  	sep 	rSubPC
(1)   69/     326 : 22                  	dec 	r2
(1)   70/     327 :                     
(1)   71/     327 : (MACRO)             	lrx 	rUtilPC,READLine 											; read line into input buffer.
(1)   71/     327 : F8 05                       ldi     (READLINE)/256
(1)   71/     329 : BC                          phi     RUTILPC
(1)   71/     32A : F8 00                       ldi     (READLINE)&255
(1)   71/     32C : AC                          plo     RUTILPC
(1)   72/     32D : 79                  	mark 																; returns it in rParam1
(1)   73/     32E : DC                  	sep 	rUtilPC 
(1)   74/     32F : 22                  	dec 	r2
(1)   75/     330 :                     
(1)   76/     330 : (MACRO)             	lrx 	rUtilPC,ASCIIToInteger										; convert to number
(1)   76/     330 : F8 02                       ldi     (ASCIITOINTEGER)/256
(1)   76/     332 : BC                          phi     RUTILPC
(1)   76/     333 : F8 B0                       ldi     (ASCIITOINTEGER)&255
(1)   76/     335 : AC                          plo     RUTILPC
(1)   77/     336 : 79                  	mark 																; and do so.
(1)   78/     337 : DC                  	sep 	rUtilPC
(1)   79/     338 : 22                  	dec 	r2
(1)   80/     339 : 32 1C               	bz 		__SHInput
(1)   81/     33B :                     
(1)   82/     33B : F8 00               	ldi 	0  															; and exit with D = 0 indicating done.
(1)   83/     33D : 30 00               	br 		__SHExit 
(1)   84/     33F :                     
(1)   85/     33F :                     
     281/     33F :                     	include editing.asm 												; line editing code	
(1)    1/     33F :                     ; ***************************************************************************************************************
(1)    2/     33F :                     ; ***************************************************************************************************************
(1)    3/     33F :                     ;
(1)    4/     33F :                     ;		File:		editing.asm
(1)    5/     33F :                     ;		Purpose:	Line editing/finding functionality.
(1)    6/     33F :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     33F :                     ;		Date:		14th January 2017.
(1)    8/     33F :                     ;
(1)    9/     33F :                     ; ***************************************************************************************************************
(1)   10/     33F :                     ; ***************************************************************************************************************
(1)   11/     33F :                     
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(editing.asm) - page 20 - 18/1/2017 16:31:26


(1)   12/     33F :                     ; ***************************************************************************************************************
(1)   13/     33F :                     ;
(1)   14/     33F :                     ;	Find line number, return pointer to it in rParam2, return DF = 1 if exact match. DF = 0 if just next one.
(1)   15/     33F :                     ;	So if lines are 10,20,30 25 will be ^30 and DF = 0, 20 will be ^20 and DF = 1
(1)   16/     33F :                     ;
(1)   17/     33F :                     ; ***************************************************************************************************************
(1)   18/     33F :                     
(1)   19/     33F :                     LocateLine:
(1)   20/     33F : E2                  	sex 	r2 															; save the target on the stack.
(1)   21/     340 : 22                  	dec 	r2
(1)   22/     341 : 9F                  	ghi 	rParam2
(1)   23/     342 : 73                  	stxd
(1)   24/     343 : 8F                  	glo 	rParam2
(1)   25/     344 : 52                  	str 	r2
(1)   26/     345 :                     
(1)   27/     345 : (MACRO)             	lrx 	rParam2,ProgramStart  										; read base of program into rParam2
(1)   27/     345 : F8 05                       ldi     (PROGRAMSTART)/256
(1)   27/     347 : BF                          phi     RPARAM2
(1)   27/     348 : F8 50                       ldi     (PROGRAMSTART)&255
(1)   27/     34A : AF                          plo     RPARAM2
(1)   28/     34B :                     	
(1)   29/     34B :                     __LLSearch:
(1)   30/     34B : 0F                  	ldn 	rParam2 													; look at the link.	
(1)   31/     34C : FC FF               	adi 	255 														; DF will be zero if the link was zero, any +ve sets it.
(1)   32/     34E : 3B 74               	bnf 	__LLExit
(1)   33/     350 :                     
(1)   34/     350 : 1F                  	inc 	rParam2 													; point to line number.0
(1)   35/     351 : 4F                  	lda 	rParam2 													; calculate current - required
(1)   36/     352 : F7                  	sm 
(1)   37/     353 : A6                  	plo 	rVarPtr 													; save interim value in rVarPtr.0
(1)   38/     354 : 12                  	inc 	r2 													
(1)   39/     355 : 0F                  	ldn 	rParam2 											
(1)   40/     356 : 77                  	smb 
(1)   41/     357 : 22                  	dec 	r2
(1)   42/     358 : 33 69               	bdf 	__LLFound 													; if DF set is >= so this is the find point.
(1)   43/     35A :                     
(1)   44/     35A : 2F                  	dec 	rParam2 													; point rParam2 back to the offset address
(1)   45/     35B : 2F                  	dec 	rParam2
(1)   46/     35C : 0F                  	ldn 	rParam2 													; read offset
(1)   47/     35D : 22                  	dec 	r2 															; save on stack.
(1)   48/     35E : 52                  	str 	r2 												
(1)   49/     35F : 8F                  	glo 	rParam2 													; add to position.
(1)   50/     360 : F4                  	add
(1)   51/     361 : AF                  	plo 	rParam2
(1)   52/     362 : 9F                  	ghi 	rParam2
(1)   53/     363 : 7C 00               	adci 	0
(1)   54/     365 : BF                  	phi 	rParam2
(1)   55/     366 : 12                  	inc 	r2 															; drop stacked value.
(1)   56/     367 : 30 4B               	br 		__LLSearch 													; and go to the next one.
(1)   57/     369 :                     
(1)   58/     369 :                     __LLFound: 																; found answer, DF set. 
(1)   59/     369 : 2F                  	dec 	rParam2 													; point back to the link.
(1)   60/     36A : 2F                  	dec 	rParam2
(1)   61/     36B : FC 00               	adi 	0 															; clear DF.
(1)   62/     36D : 3A 74               	bnz 	__LLExit 													; if results non-zero return DF = 0
(1)   63/     36F : 86                  	glo 	rVarPtr 													
(1)   64/     370 : 3A 74               	bnz 	__LLExit 
(1)   65/     372 : FD 00               	sdi 	0 															; set DF
(1)   66/     374 :                     
(1)   67/     374 :                     __LLExit:
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(editing.asm) - page 21 - 18/1/2017 16:31:26


(1)   68/     374 : 12                  	inc 	r2 															; throw stacked values.
(1)   69/     375 : 12                  	inc 	r2
(1)   70/     376 : 12                  	inc 	r2 															; return from subroutine.
(1)   71/     377 : (MACRO)             	return 
(1)   71/     377 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)   72/     378 :                     
(1)   73/     378 :                     ; ***************************************************************************************************************
(1)   74/     378 :                     ;
(1)   75/     378 :                     ;				Delete program line at rParam2 (address), breaks rSubPC, rParenthesisLevel
(1)   76/     378 :                     ;
(1)   77/     378 :                     ; ***************************************************************************************************************
(1)   78/     378 :                     
(1)   79/     378 :                     DeleteLine:
(1)   80/     378 : EF                  	sex 	rParam2 													; (X) is the offset
(1)   81/     379 :                     
(1)   82/     379 : 8F                  	glo 	rParam2 
(1)   83/     37A : AA                  	plo 	rParenthesisLevel
(1)   84/     37B : F4                  	add
(1)   85/     37C : AD                  	plo 	rSubPC 														; copy from rSubPC to rParenthesisLevel
(1)   86/     37D : 9F                  	ghi 	rParam2
(1)   87/     37E : BA                  	phi 	rParenthesisLevel
(1)   88/     37F : 7C 00               	adci 	0
(1)   89/     381 : BD                  	phi 	rSubPC
(1)   90/     382 :                     
(1)   91/     382 : F8 4C               	ldi 	('&' & 03Fh) * 2 											; point rVarPtr to the end of memory.
(1)   92/     384 : A6                  	plo 	rVarPtr
(1)   93/     385 : E6                  	sex 	rVarPtr
(1)   94/     386 :                     
(1)   95/     386 : 2D                  	dec 	rSubPC
(1)   96/     387 : 2A                  	dec 	rParenthesisLevel
(1)   97/     388 :                     __DeleteLoop:
(1)   98/     388 : 1A                  	inc 	rParenthesisLevel 											; copy one byte over.
(1)   99/     389 : 1D                  	inc 	rSubPC
(1)  100/     38A : 0D                  	ldn 	rSubPC
(1)  101/     38B : 5A                  	str 	rParenthesisLevel
(1)  102/     38C : F8 00               	ldi 	0 															; clear newly cleared memory (not really required)
(1)  103/     38E : 5D                  	str 	rSubPC
(1)  104/     38F : 8D                  	glo 	rSubPC 														; loop back if not at end
(1)  105/     390 : F3                  	xor
(1)  106/     391 : 3A 88               	bnz 	__DeleteLoop
(1)  107/     393 : 16                  	inc 	rVarPtr
(1)  108/     394 : 9D                  	ghi 	rSubPC 														; source reached program top ?
(1)  109/     395 : F3                  	xor
(1)  110/     396 : 26                  	dec 	rVarPtr
(1)  111/     397 : 3A 88               	bnz 	__DeleteLoop 												
(1)  112/     399 :                     
(1)  113/     399 : 8A                  	glo 	rParenthesisLevel 											; update top of program.
(1)  114/     39A : 56                  	str 	rVarPtr
(1)  115/     39B : 16                  	inc 	rVarPtr
(1)  116/     39C : 9A                  	ghi 	rParenthesisLevel
(1)  117/     39D : 56                  	str 	rVarPtr
(1)  118/     39E :                     
(1)  119/     39E : E2                  	sex 	r2
(1)  120/     39F : 12                  	inc 	r2
(1)  121/     3A0 : (MACRO)             	return	
(1)  121/     3A0 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)  122/     3A1 :                     
(1)  123/     3A1 :                     ; ***************************************************************************************************************
(1)  124/     3A1 :                     ;
(1)  125/     3A1 :                     ;					Insert line at rParam2, rSrc line Number, rParam1 text to insert.
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(editing.asm) - page 22 - 18/1/2017 16:31:26


(1)  126/     3A1 :                     ;
(1)  127/     3A1 :                     ; ***************************************************************************************************************
(1)  128/     3A1 :                     
(1)  129/     3A1 :                     InsertLine:
(1)  130/     3A1 : E2                  	sex 	r2
(1)  131/     3A2 :                     
(1)  132/     3A2 : 8E                  	glo 	rParam1 													; find how much space.
(1)  133/     3A3 : AD                  	plo 	rSubPC
(1)  134/     3A4 : 9E                  	ghi 	rParam1
(1)  135/     3A5 : BD                  	phi 	rSubPC
(1)  136/     3A6 : F8 03               	ldi 	3 															; 3 + length of string including ASCIIZ.
(1)  137/     3A8 : 52                  	str 	r2 															; as we are going to copy offset, lsb number, msb number
(1)  138/     3A9 :                     __ILLength:
(1)  139/     3A9 : 02                  	ldn 	r2
(1)  140/     3AA : FC 01               	adi 	1
(1)  141/     3AC : 52                  	str 	r2
(1)  142/     3AD : 4D                  	lda 	rSubPC
(1)  143/     3AE : 3A A9               	bnz 	__ILLength
(1)  144/     3B0 :                     
(1)  145/     3B0 :                     
(1)  146/     3B0 : F8 4C               	ldi 	('&' & 03Fh) * 2 											; point rVarPtr to the end of memory.
(1)  147/     3B2 : A6                  	plo 	rVarPtr
(1)  148/     3B3 :                     
(1)  149/     3B3 : 46                  	lda 	rVarPtr 													; put end of program in rSubPC (copy from) rParenthesisLevel (copy to)
(1)  150/     3B4 : AD                  	plo 	rSubPC
(1)  151/     3B5 : F4                  	add 																; adding the adjustment as we go.
(1)  152/     3B6 : AA                  	plo 	rParenthesisLevel
(1)  153/     3B7 :                     
(1)  154/     3B7 : 06                  	ldn 	rVarPtr
(1)  155/     3B8 : BD                  	phi 	rSubPC
(1)  156/     3B9 : 7C 00               	adci 	0
(1)  157/     3BB : BA                  	phi 	rParenthesisLevel
(1)  158/     3BC :                     
(1)  159/     3BC : 56                  	str 	rVarPtr 													; write back the new top of program.
(1)  160/     3BD : 8A                  	glo 	rParenthesisLevel
(1)  161/     3BE : 26                  	dec 	rVarPtr
(1)  162/     3BF : 56                  	str 	rVarPtr
(1)  163/     3C0 :                     
(1)  164/     3C0 :                     __ILInsert:
(1)  165/     3C0 : 0D                  	ldn 	rSubPC 														; copy it.
(1)  166/     3C1 : 5A                  	str 	rParenthesisLevel
(1)  167/     3C2 : F8 FF               	ldi 	0FFh 														; write $FF to original position.
(1)  168/     3C4 : 5D                  	str 	rSubPC
(1)  169/     3C5 : 2D                  	dec 	rSubPC 														; decrement
(1)  170/     3C6 : 2A                  	dec 	rParenthesisLevel
(1)  171/     3C7 :                     
(1)  172/     3C7 : 0F                  	ldn 	rParam2 													; has the initial write point been overwritten ?
(1)  173/     3C8 : FB FF               	xri 	0FFh
(1)  174/     3CA : 3A C0               	bnz 	__ILInsert
(1)  175/     3CC :                     
(1)  176/     3CC : 02                  	ldn 	r2 															; read bytes to copy - the offset.
(1)  177/     3CD : 5F                  	str 	rParam2
(1)  178/     3CE : 1F                  	inc 	rParam2
(1)  179/     3CF : 88                  	glo 	rSrc 														; write line# LSB
(1)  180/     3D0 : 5F                  	str 	rParam2
(1)  181/     3D1 : 1F                  	inc 	rParam2
(1)  182/     3D2 : 98                  	ghi 	rSrc 														; write line# MSB
(1)  183/     3D3 : 5F                  	str 	rParam2
(1)  184/     3D4 : 1F                  	inc 	rParam2
(1)  185/     3D5 :                     
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(editing.asm) - page 23 - 18/1/2017 16:31:26


(1)  186/     3D5 :                     __ILCopy: 																; copy text of line.
(1)  187/     3D5 : 4E                  	lda 	rParam1
(1)  188/     3D6 : 5F                  	str 	rParam2
(1)  189/     3D7 : 1F                  	inc 	rParam2
(1)  190/     3D8 : 3A D5               	bnz 	__ILCopy
(1)  191/     3DA :                     
(1)  192/     3DA : 12                  	inc 	r2
(1)  193/     3DB : (MACRO)             	return	
(1)  193/     3DB : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)  194/     3DC :                     
     282/     3DC :                     __Prompt: 																; VTL-2 Prompt.
     283/     3DC : 4F 4B 0D 00         	db 		"OK",13,0
     284/     3E0 :                     	align 	256
     285/     400 :                     	include command.asm 												; command execution code.
(1)    1/     400 :                     ; ***************************************************************************************************************
(1)    2/     400 :                     ; ***************************************************************************************************************
(1)    3/     400 :                     ;
(1)    4/     400 :                     ;		File:		command.asm
(1)    5/     400 :                     ;		Purpose:	Execute a single command
(1)    6/     400 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     400 :                     ;		Date:		18th January 2017.
(1)    8/     400 :                     ;
(1)    9/     400 :                     ; ***************************************************************************************************************
(1)   10/     400 :                     ; ***************************************************************************************************************
(1)   11/     400 :                     
(1)   12/     400 :                     ; ***************************************************************************************************************
(1)   13/     400 :                     ;
(1)   14/     400 :                     ;											Execute command in rParam1. 
(1)   15/     400 :                     ;
(1)   16/     400 :                     ;	Side effects : # (goto, change rCurrentPC and '!') $ (char out) ? (number/literal out) :<expr>) array
(1)   17/     400 :                     ; 	handler.
(1)   18/     400 :                     ;
(1)   19/     400 :                     ; ***************************************************************************************************************
(1)   20/     400 :                     
(1)   21/     400 :                     __ECExitDrop2:
(1)   22/     400 : 12                  	inc 	r2
(1)   23/     401 : 12                  	inc 	r2
(1)   24/     402 :                     __ECExit:
(1)   25/     402 : D3                  	sep 	r3
(1)   26/     403 :                     ExecuteCommand:
(1)   27/     403 : 8E                  	glo  	rParam1 													; copy rParam to rSrc
(1)   28/     404 : A8                  	plo 	rSrc
(1)   29/     405 : 9E                  	ghi 	rParam1
(1)   30/     406 : B8                  	phi 	rSrc
(1)   31/     407 :                     
(1)   32/     407 : (MACRO)             	lrx 	rExprPC,EXPREvaluate 										; this is re-entrant throughout
(1)   32/     407 : F8 01                       ldi     (EXPREVALUATE)/256
(1)   32/     409 : B7                          phi     REXPRPC
(1)   32/     40A : F8 0B                       ldi     (EXPREVALUATE)&255
(1)   32/     40C : A7                          plo     REXPRPC
(1)   33/     40D : F8 4F               	ldi 	(39 & 03Fh) * 2 + 1 										; point rVarPtr to the random number MSB (39 is single quote)
(1)   34/     40F : A6                  	plo 	rVarPtr
(1)   35/     410 : 06                  	ldn 	rVarPtr 													; read MSB
(1)   36/     411 : F6                  	shr 																; shift right and save.
(1)   37/     412 : 56                  	str 	rVarPtr
(1)   38/     413 : 26                  	dec 	rVarPtr
(1)   39/     414 : 06                  	ldn 	rVarPtr 													; rotate into LSB
(1)   40/     415 : 76                  	rshr 
(1)   41/     416 : 56                  	str 	rVarPtr
(1)   42/     417 : 3B 1E               	bnf 	__ECNoXor
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(command.asm) - page 24 - 18/1/2017 16:31:26


(1)   43/     419 : 16                  	inc 	rVarPtr 													; xor the MSB with $B4 is LSB was one.
(1)   44/     41A : 06                  	ldn 	rVarPtr
(1)   45/     41B : FB B4               	xri 	0B4h
(1)   46/     41D : 56                  	str 	rVarPtr
(1)   47/     41E :                     __ECNoXor:
(1)   48/     41E :                     
(1)   49/     41E : 08                  	ldn 	rSrc 														; look at command first character
(1)   50/     41F : FB 29               	xri 	')'															; exit if comment
(1)   51/     421 : 32 02               	bz 		__ECExit
(1)   52/     423 : FB 13               	xri 	')'!':'														; check for array.
(1)   53/     425 : 32 8B               	bz 		__ECArray
(1)   54/     427 : FB 1E               	xri 	':'!'$'
(1)   55/     429 : 32 A4               	bz 		__ECOutput
(1)   56/     42B : FB 1B               	xri 	'$'!'?' 													; if $ or ? go to the output routine.
(1)   57/     42D : 32 A4               	bz 		__ECOutput
(1)   58/     42F :                     
(1)   59/     42F : 48                  	lda 	rSrc 														; read variable ptr and skip over it.
(1)   60/     430 : AE                  	plo 	rParam1 													; save it temporarily.
(1)   61/     431 : FC 9F               	adi 	256-'a' 													; a+ will generate DF
(1)   62/     433 : 3B 37               	bnf 	__ECNotLower
(1)   63/     435 : FF 20               	smi 	32
(1)   64/     437 :                     __ECNotLower:	
(1)   65/     437 : FF 9F               	smi 	256-'a'
(1)   66/     439 : FA 3F               	ani 	3Fh 														; six bit ASCII
(1)   67/     43B : FE                  	shl 																; 2 bytes per variable
(1)   68/     43C : 73                  	stxd 																; save on stack.
(1)   69/     43D : 96                  	ghi 	rVarPtr 													; push high byte of variable address on stack
(1)   70/     43E : 73                  	stxd 
(1)   71/     43F :                     
(1)   72/     43F :                     __ECSkipEquals: 														; advance past equals.
(1)   73/     43F : 48                  	lda 	rSrc
(1)   74/     440 : 32 00               	bz 		__ECExitDrop2
(1)   75/     442 : FB 3D               	xri 	'='
(1)   76/     444 : 3A 3F               	bnz 	__ECSkipEquals
(1)   77/     446 :                     
(1)   78/     446 : 8E                  	glo 	rParam1 													; was it '#' that has a special handler
(1)   79/     447 : FB 23               	xri 	'#'
(1)   80/     449 : 32 58               	bz 		__ECGoto 
(1)   81/     44B :                     
(1)   82/     44B : 79                  	mark  																; evaluate expression.
(1)   83/     44C : D7                  	sep 	rExprPC 
(1)   84/     44D :                     
(1)   85/     44D :                     
(1)   86/     44D : 42                  	lda 	r2 															; read save address MSB (we can miss dec r2/inc r2 after mark.)
(1)   87/     44E : BF                  	phi 	rParam2
(1)   88/     44F : 02                  	ldn 	r2
(1)   89/     450 : AF                  	plo 	rParam2
(1)   90/     451 :                     
(1)   91/     451 : 8E                  	glo 	rParam1 													; write result out.
(1)   92/     452 : 5F                  	str 	rParam2
(1)   93/     453 : 9E                  	ghi 	rParam1
(1)   94/     454 : 1F                  	inc 	rParam2
(1)   95/     455 : 5F                  	str 	rParam2
(1)   96/     456 : 30 02               	br 		__ECExit
(1)   97/     458 :                     
(1)   98/     458 :                     ; ***************************************************************************************************************
(1)   99/     458 :                     ;
(1)  100/     458 :                     ;												Handle #=xxxx (goto)
(1)  101/     458 :                     ;
(1)  102/     458 :                     ; ***************************************************************************************************************
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(command.asm) - page 25 - 18/1/2017 16:31:26


(1)  103/     458 :                     
(1)  104/     458 :                     __ECGoto:
(1)  105/     458 : 12                  	inc 	r2 															; throw save address, we know where it is
(1)  106/     459 : 12                  	inc 	r2
(1)  107/     45A :                     
(1)  108/     45A : 79                  	mark  																; evaluate expression.
(1)  109/     45B : D7                  	sep 	rExprPC 
(1)  110/     45C : 22                  	dec 	r2
(1)  111/     45D :                     
(1)  112/     45D : 8E                  	glo 	rParam1 													; if result is zero do nothing
(1)  113/     45E : 3A 63               	bnz 	__ECGotoNonZero
(1)  114/     460 : 9E                  	ghi 	rParam1
(1)  115/     461 : 32 02               	bz 		__ECExit
(1)  116/     463 :                     __ECGotoNonZero:
(1)  117/     463 :                     
(1)  118/     463 : F8 46               	ldi 	('#' & 03Fh) * 2 											; point rVarPtr to current line.
(1)  119/     465 : A6                  	plo 	rVarPtr
(1)  120/     466 :                     
(1)  121/     466 : 06                  	ldn 	rVarPtr 													; read old to rParam2, save new 
(1)  122/     467 : AF                  	plo 	rParam2
(1)  123/     468 : 8E                  	glo 	rParam1
(1)  124/     469 : 56                  	str 	rVarPtr
(1)  125/     46A :                     
(1)  126/     46A : 16                  	inc 	rVarPtr 													; read old to rParam2, save new
(1)  127/     46B : 06                  	ldn 	rVarPtr
(1)  128/     46C : BF                  	phi 	rParam2
(1)  129/     46D : 9E                  	ghi 	rParam1
(1)  130/     46E : 56                  	str 	rVarPtr
(1)  131/     46F :                     
(1)  132/     46F : 1F                  	inc 	rParam2 													; add 1 to old line number
(1)  133/     470 : F8 42               	ldi 	('!' & 03Fh) * 2 											; write to '!'
(1)  134/     472 : A6                  	plo 	rVarPtr
(1)  135/     473 : 8F                  	glo 	rParam2
(1)  136/     474 : 56                  	str 	rVarPtr
(1)  137/     475 : 16                  	inc 	rVarPtr
(1)  138/     476 : 9F                  	ghi 	rParam2
(1)  139/     477 : 56                  	str 	rVarPtr
(1)  140/     478 :                     
(1)  141/     478 : 8E                  	glo 	rParam1 													; put line number in rParam2
(1)  142/     479 : AF                  	plo 	rParam2
(1)  143/     47A : 9E                  	ghi 	rParam1
(1)  144/     47B : BF                  	phi 	rParam2
(1)  145/     47C : (MACRO)             	lrx 	rUtilPC,LocateLine 											; find out where the line is.
(1)  145/     47C : F8 03                       ldi     (LOCATELINE)/256
(1)  145/     47E : BC                          phi     RUTILPC
(1)  145/     47F : F8 3F                       ldi     (LOCATELINE)&255
(1)  145/     481 : AC                          plo     RUTILPC
(1)  146/     482 : 79                  	mark
(1)  147/     483 : DC                  	sep 	rUtilPC
(1)  148/     484 : 22                  	dec 	r2
(1)  149/     485 : 8F                  	glo 	rParam2 													; copy result to rCurrentLine
(1)  150/     486 : A5                  	plo 	rCurrentLine
(1)  151/     487 : 9F                  	ghi 	rParam2
(1)  152/     488 : B5                  	phi 	rCurrentLine
(1)  153/     489 : 30 02               	br 		__ECExit 
(1)  154/     48B :                     
(1)  155/     48B :                     ; ***************************************************************************************************************
(1)  156/     48B :                     ;
(1)  157/     48B :                     ;										Handle :<array>) = nnnn
(1)  158/     48B :                     ;
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(command.asm) - page 26 - 18/1/2017 16:31:26


(1)  159/     48B :                     ; ***************************************************************************************************************
(1)  160/     48B :                     
(1)  161/     48B :                     __ECArray:
(1)  162/     48B : 18                  	inc 	rSrc 														; skip over the :
(1)  163/     48C : 79                  	mark  																; evaluate expression into rParam1 which is the array index
(1)  164/     48D : D7                  	sep 	rExprPC 
(1)  165/     48E : 22                  	dec 	r2 															; fix up afterwards
(1)  166/     48F :                     
(1)  167/     48F : 8E                  	glo 	rParam1 													; double the array index.
(1)  168/     490 : FE                  	shl
(1)  169/     491 : AE                  	plo 	rParam1
(1)  170/     492 : 9E                  	ghi 	rParam1
(1)  171/     493 : 7E                  	rshl
(1)  172/     494 : BE                  	phi 	rParam1
(1)  173/     495 :                     
(1)  174/     495 : F8 4C               	ldi 	('&' & 03Fh) * 2 											; point rVarPtr to &
(1)  175/     497 : A6                  	plo 	rVarPtr
(1)  176/     498 : E6                  	sex 	rVarPtr 													; use as index.
(1)  177/     499 :                     
(1)  178/     499 : 8E                  	glo 	rParam1 													; add to '*' and push on stack
(1)  179/     49A : F4                  	add
(1)  180/     49B : 52                  	str 	r2
(1)  181/     49C : 22                  	dec 	r2
(1)  182/     49D : 9E                  	ghi 	rParam1
(1)  183/     49E : 16                  	inc 	rVarPtr
(1)  184/     49F : 74                  	adc
(1)  185/     4A0 : E2                  	sex 	r2
(1)  186/     4A1 : 73                  	stxd
(1)  187/     4A2 : 30 3F               	br 		__ECSkipEquals 												; and continue as if variable assignment.
(1)  188/     4A4 :                     
(1)  189/     4A4 :                     ; ***************************************************************************************************************
(1)  190/     4A4 :                     ;
(1)  191/     4A4 :                     ;												Handle ?= and $=
(1)  192/     4A4 :                     ;
(1)  193/     4A4 :                     ; ***************************************************************************************************************
(1)  194/     4A4 :                     
(1)  195/     4A4 :                     __ECOutput:
(1)  196/     4A4 : 30 A4               	br 		__ECOutput
(1)  197/     4A6 :                     
(1)  198/     4A6 :                     
     286/     4A6 :                     	align 	256
     287/     500 :                     
     288/     500 :                     	include readline.asm 												; line input routine.
(1)    1/     500 :                     ; ***************************************************************************************************************
(1)    2/     500 :                     ; ***************************************************************************************************************
(1)    3/     500 :                     ;
(1)    4/     500 :                     ;		File:		readline.asm
(1)    5/     500 :                     ;		Purpose:	Read an input line
(1)    6/     500 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     500 :                     ;		Date:		14th January 2017.
(1)    8/     500 :                     ;
(1)    9/     500 :                     ; ***************************************************************************************************************
(1)   10/     500 :                     ; ***************************************************************************************************************
(1)   11/     500 :                     
(1)   12/     500 :                     ; ***************************************************************************************************************
(1)   13/     500 :                     ;
(1)   14/     500 :                     ;						Read Line in from Keyboard, returns address in rParam1
(1)   15/     500 :                     ;
(1)   16/     500 :                     ; ***************************************************************************************************************
(1)   17/     500 :                     
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(readline.asm) - page 27 - 18/1/2017 16:31:26


(1)   18/     500 :                     READLine:
(1)   19/     500 : F8 7F               	ldi 	7Fh 														; set up rParam1 to point to the string.
(1)   20/     502 : AE                  	plo 	rParam1
(1)   21/     503 : 96                  	ghi 	rVarPtr
(1)   22/     504 : BE                  	phi 	rParam1
(1)   23/     505 :                     
(1)   24/     505 :                     __RLLNextCharacter:
(1)   25/     505 : 1E                  	inc 	rParam1
(1)   26/     506 :                     __RLLLoop:
(1)   27/     506 : E2                  	sex 	r2 															; use R2 as index
(1)   28/     507 : (MACRO)             	lrx 	rSubPC,XIOGetKey 											; call get key routine.
(1)   28/     507 : F8 05                       ldi     (XIOGETKEY)/256
(1)   28/     509 : BD                          phi     RSUBPC
(1)   28/     50A : F8 32                       ldi     (XIOGETKEY)&255
(1)   28/     50C : AD                          plo     RSUBPC
(1)   29/     50D : 79                  	mark 	
(1)   30/     50E : DD                  	sep 	rSubPC
(1)   31/     50F : 22                  	dec 	r2
(1)   32/     510 : 5E                  	str 	rParam1	 													; save in text buffer.
(1)   33/     511 :                     
(1)   34/     511 : (MACRO)             	lrx 	rSubPC,XIOWriteCharacter
(1)   34/     511 : F8 05                       ldi     (XIOWRITECHARACTER)/256
(1)   34/     513 : BD                          phi     RSUBPC
(1)   34/     514 : F8 3A                       ldi     (XIOWRITECHARACTER)&255
(1)   34/     516 : AD                          plo     RSUBPC
(1)   35/     517 : 0E                  	ldn 	rParam1
(1)   36/     518 : 79                  	mark
(1)   37/     519 : DD                  	sep 	rSubPC
(1)   38/     51A : 22                  	dec 	r2
(1)   39/     51B :                     
(1)   40/     51B : 0E                  	ldn 	rParam1
(1)   41/     51C : FB 08               	xri 	8 															; Ctl+H
(1)   42/     51E : 32 2A               	bz 		__RLLPrevCharacter 											; get previous character
(1)   43/     520 : FB 05               	xri 	13!8 														; is it CR ?
(1)   44/     522 : 3A 05               	bnz 	__RLLNextCharacter 											; no go around again
(1)   45/     524 :                     __RLLExit:
(1)   46/     524 : 5E                  	str 	rParam1 													; save the zero in rVarPtr making string ASCIIZ.
(1)   47/     525 : F8 80               	ldi 	80h 														; point rParam1 to the start of the string.
(1)   48/     527 : AE                  	plo 	rParam1
(1)   49/     528 : 12                  	inc 	r2 															; and exit.
(1)   50/     529 : (MACRO)             	return
(1)   50/     529 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)   51/     52A :                     
(1)   52/     52A :                     __RLLPrevCharacter:
(1)   53/     52A : 2E                  	dec 	rParam1 													; handle backspace (chr(8))
(1)   54/     52B : 8E                  	glo 	rParam1
(1)   55/     52C : FE                  	shl
(1)   56/     52D : 33 06               	bdf 	__RLLLoop
(1)   57/     52F : 30 05               	br 		__RLLNextCharacter
(1)   58/     531 :                     
     289/     531 :                     	include	virtualio.asm 												; I/O routines that are hardware specific.
(1)    1/     531 :                     ; ***************************************************************************************************************
(1)    2/     531 :                     ; ***************************************************************************************************************
(1)    3/     531 :                     ;
(1)    4/     531 :                     ;		File:		virtualio.asm
(1)    5/     531 :                     ;		Purpose:	Input/Output routines.
(1)    6/     531 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     531 :                     ;		Date:		14th January 2017.
(1)    8/     531 :                     ;
(1)    9/     531 :                     ; ***************************************************************************************************************
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(virtualio.asm) - page 28 - 18/1/2017 16:31:26


(1)   10/     531 :                     ; ***************************************************************************************************************
(1)   11/     531 :                     
(1)   12/     531 :                     ; ***************************************************************************************************************
(1)   13/     531 :                     ;
(1)   14/     531 :                     ;	These routines will be entered with P = rUtilPC or P = rSubPC and should change no registers other than
(1)   15/     531 :                     ; 	D and DF. On entry R2 will point to an empty stack space.
(1)   16/     531 :                     ;
(1)   17/     531 :                     ; ***************************************************************************************************************
(1)   18/     531 :                     
(1)   19/     531 :                     ; ***************************************************************************************************************
(1)   20/     531 :                     ;
(1)   21/     531 :                     ;												Get a keystroke into D.
(1)   22/     531 :                     ;
(1)   23/     531 :                     ; ***************************************************************************************************************
(1)   24/     531 :                     
(1)   25/     531 : (MACRO)             	return
(1)   25/     531 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)   26/     532 :                     XIOGetKey:
(1)   27/     532 : E2                  	sex 	r2 															; fix up after Mark.
(1)   28/     533 : 69                  	inp 	1 															; read keyboard port
(1)   29/     534 : 32 32               	bz 		XIOGetKey 													; no key, keep trying
(1)   30/     536 : 12                  	inc 	r2 															; standard return.
(1)   31/     537 : 30 31               	br 		XIOGetKey-1
(1)   32/     539 :                     
(1)   33/     539 :                     ; ***************************************************************************************************************
(1)   34/     539 :                     ;
(1)   35/     539 :                     ;										    Write a character to the display
(1)   36/     539 :                     ;
(1)   37/     539 :                     ; ***************************************************************************************************************
(1)   38/     539 :                     
(1)   39/     539 : (MACRO)             	return
(1)   39/     539 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)   40/     53A :                     XIOWriteCharacter:
(1)   41/     53A : E2                  	sex 	r2
(1)   42/     53B : 52                  	str 	r2
(1)   43/     53C : 61                  	out 	1
(1)   44/     53D : 22                  	dec 	r2
(1)   45/     53E : 12                  	inc 	r2
(1)   46/     53F : 30 39               	br 		XIOWriteCharacter-1
(1)   47/     541 :                     
(1)   48/     541 :                     ; ***************************************************************************************************************
(1)   49/     541 :                     ;
(1)   50/     541 :                     ;			Print String at rParam2 (ASCIIZ) , on exit leaves rSubPC set up to print a character
(1)   51/     541 :                     ;
(1)   52/     541 :                     ; ***************************************************************************************************************
(1)   53/     541 :                     
(1)   54/     541 : D3                  	sep 	r3
(1)   55/     542 :                     __PrintString:
(1)   56/     542 : (MACRO)             	lrx 	rSubPC,XIOWriteCharacter 									; print character routine
(1)   56/     542 : F8 05                       ldi     (XIOWRITECHARACTER)/256
(1)   56/     544 : BD                          phi     RSUBPC
(1)   56/     545 : F8 3A                       ldi     (XIOWRITECHARACTER)&255
(1)   56/     547 : AD                          plo     RSUBPC
(1)   57/     548 : 4F                  	lda 	rParam2
(1)   58/     549 : 32 41               	bz 		__PrintString-1
(1)   59/     54B : 79                  	mark
(1)   60/     54C : DD                  	sep 	rSubPC
(1)   61/     54D : 22                  	dec	 	r2
(1)   62/     54E : 30 42               	br 		__PrintString
(1)   63/     550 :                     
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(virtualio.asm) - page 29 - 18/1/2017 16:31:26


(1)   64/     550 :                     
     290/     550 :                     
     291/     550 :                     
     292/     550 :                     ; ***************************************************************************************************************
     293/     550 :                     ;
     294/     550 :                     ;												VTL-2 Code, test 
     295/     550 :                     ;
     296/     550 :                     ; ***************************************************************************************************************
     297/     550 :                     
     298/     550 :                     vtl macro line,code 													; creating VTL-2 code in line.
     299/     550 :                     startLine:
     300/     550 :                     	db 		endLine-startLine 											; +0 offset to next
     301/     550 :                     	db 		line & 255,line / 256 										; +1,+2 line number
     302/     550 :                     	db 		code,0 														; ASCIIZ line.
     303/     550 :                     endLine:	
     304/     550 :                     	endm
     305/     550 :                     
     306/     550 :                     ProgramStart:
     307/     550 : (MACRO)             	vtl 	5,"D=1"
     307/     550 :                     startLine:
     307/     550 : 07                          db              endLine-startLine                                                                                       ; +0 offset to next
     307/     551 : 05 00                       db              5 & 255,5 / 256                                                                           ; +1,+2 5 number
     307/     553 : 44 3D 31 00                 db              "D=1",0                                                                                                          ; ASCIIZ 5.
     307/     557 :                     endLine:        
     308/     557 : (MACRO)             	vtl 	10,"A=42) this is a comment"
     308/     557 :                     startLine:
     308/     557 : 1B                          db              endLine-startLine                                                                                       ; +0 offset to next
     308/     558 : 0A 00                       db              10 & 255,10 / 256                                                                           ; +1,+2 10 number
     308/     55A : 41 3D 34 32 29 20           db              "A=42) this is a comment",0                                                                                                          ; ASCIIZ 10.
                    74 68 69 73 20 69 
                    73 20 61 20 63 6F 
                    6D 6D 65 6E 74 00 
     308/     572 :                     endLine:        
     309/     572 : (MACRO)             	vtl 	20,"B=3"		
     309/     572 :                     startLine:
     309/     572 : 07                          db              endLine-startLine                                                                                       ; +0 offset to next
     309/     573 : 14 00                       db              20 & 255,20 / 256                                                                           ; +1,+2 20 number
     309/     575 : 42 3D 33 00                 db              "B=3",0                                                                                                          ; ASCIIZ 20.
     309/     579 :                     endLine:        
     310/     579 : (MACRO)             	vtl 	30,"C=A+B"
     310/     579 :                     startLine:
     310/     579 : 09                          db              endLine-startLine                                                                                       ; +0 offset to next
     310/     57A : 1E 00                       db              30 & 255,30 / 256                                                                           ; +1,+2 30 number
     310/     57C : 43 3D 41 2B 42 00           db              "C=A+B",0                                                                                                          ; ASCIIZ 30.
     310/     582 :                     endLine:        
     311/     582 :                     ProgramEnd:	
     312/     582 : 00                  	db 		0
     313/     583 :                     
     314/     583 :                     
 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 30 - 18/1/2017 16:31:26


  symbol table (* = unused):
  ------------------------

*ARCHITECTURE :                                        x86_64-unknown-linux - |
 ASCIITOINTEGER :               2B0 C | *BIGENDIAN :                      0 - |
*BRANCHEXT :                      0 - | *CASESENSITIVE :                  0 - |
*CONSTPI :        3.141592653589793 - | *DATE :                   18/1/2017 - |
 DELETELINE :                   378 C |  DIVIDE :                       1BF C |
 EDIT :                          A4 C |  ENTERCOMMAND :                  54 C |
 EXECUTE :                       CA C |  EXECUTECOMMAND :               403 C |
 EXPREVALUATE :                 10B C | *FALSE :                          0 - |
 FINDRAMTOP :                    10 C |  FOUNDRAMTOP :                   1E C |
*FULLPMMU :                       1 - | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - | *INEXTMODE :                      0 - |
 INITIALISE :                     9 C | *INLWORDMODE :                    0 - |
*INMAXMODE :                      0 - |  INSERTLINE :                   3A1 C |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
 INTEGERTOASCII :               259 C | *LISTON :                         1 - |
*LISTPROGRAM :                   6E C |  LOCATELINE :                   33F C |
*MACEXP :                         1 - | *MOMCPU :                      1802 - |
*MOMCPUNAME :                  1802 - |  MULTIPLY :                     28B C |
*NESTMAX :                      100 - | *PACKING :                        0 - |
*PADDING :                        1 - |  PROGRAMEND :                   582 C |
 PROGRAMSTART :                 550 C |  PROMPT :                        39 C |
*R0 :                             0 - | *R1 :                             1 - |
 R2 :                             2 - |  R3 :                             3 - |
 RCURRENTLINE :                   5 - |  READLINE :                     500 C |
*RELAXED :                        0 - |  REXECUTEPC :                     4 - |
 REXPRPC :                        7 - |  RPARAM1 :                        E - |
 RPARAM2 :                        F - |  RPARENTHESISLEVEL :              A - |
 RSAVESTACK :                     B - |  RSPECIALHANDLER :                9 - |
 RSRC :                           8 - |  RSUBPC :                         D - |
 RUNPROGRAM :                    DD C |  RUTILPC :                        C - |
 RVARPTR :                        6 - |  SPECIALHANDLER :               301 C |
*TIME :                    16:31:26 - | *TRUE :                           1 - |
*VERSION :                     142F - |  XIOGETKEY :                    532 C |
 XIOWRITECHARACTER :            53A C |  __ATOIEXIT :                   2AD C |
 __ATOILOOP :                   2B6 C |  __DELETELOOP :                 388 C |
 __DIVEXIT :                    1BD C | *__DIVLOOP :                    1CE C |
 __DIVLOOPINCR2 :               1CD C |  __DIVLOOPINCR2INCR2 :          1CC C |
 __DONTDELETE :                  BC C |  __ECARRAY :                    48B C |
 __ECEXIT :                     402 C |  __ECEXITDROP2 :                400 C |
 __ECGOTO :                     458 C |  __ECGOTONONZERO :              463 C |
 __ECNOTLOWER :                 437 C |  __ECNOXOR :                    41E C |
 __ECOUTPUT :                   4A4 C |  __ECSKIPEQUALS :               43F C |
 __EXPRARRAY :                  156 C |  __EXPRDESTACKBRACKET :         1A3 C |
 __EXPREXIT :                   101 C |  __EXPREXITDEC :                100 C |
 __EXPRFINDOPERATION :          16D C |  __EXPRFOUNDOPERATION :         175 C |
 __EXPRGOTCHARACTER :           15E C |  __EXPRGOTTERM :                166 C |
 __EXPRNEWLEVEL :               113 C |  __EXPRNEWTERM :                11B C |
 __EXPRNOTDIVIDE :              18F C |  __EXPRNOTLOWER :               14A C |
 __EXPRSKIPSPACE :              193 C |  __ILCOPY :                     3D5 C |
 __ILINSERT :                   3C0 C |  __ILLENGTH :                   3A9 C |
 __ITOAEXIT :                   257 C |  __ITOALOOP :                   25D C |
 __LISTLOOP :                    74 C |  __LISTNEXT :                    9F C |
 __LLEXIT :                     374 C |  __LLFOUND :                    369 C |
 __LLSEARCH :                   34B C |  __MULDONTADD :                 29F C |
 __MULEXIT :                    286 C |  __MULLOOP :                    290 C |
 __OPADD :                      200 C |  __OPEQISTRUE :                 24F C |
 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 31 - 18/1/2017 16:31:26


 __OPEQNZ :                     24B C |  __OPEQUALITY :                 247 C |
 __OPERATORTABLE :              1AE C |  __OPLOOKUP :                   20D C |
 __OPLT0 :                      240 C |  __OPRETURN :                   223 C |
 __OPSUB :                      226 C |  __OPWRITEBOOLEAN :             251 C |
 __PRINTSTRING :                542 C |  __PROMPT :                     3DC C |
*__RLLEXIT :                    524 C |  __RLLLOOP :                    506 C |
 __RLLNEXTCHARACTER :           505 C |  __RLLPREVCHARACTER :           52A C |
 __SHEXIT :                     300 C |  __SHGETKEY :                   30D C |
 __SHINPUT :                    31C C |

    130 symbols
     33 unused symbols

 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 32 - 18/1/2017 16:31:26


  defined macros:
  ---------------

LRX                                   | OPER                                 
RETURN                                | VTL                                  
__ATOIDOUBLERPARAM2                   |

      5 macros

 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 33 - 18/1/2017 16:31:26


  codepages:
  ----------

STANDARD (0 changed characters)


0.01 seconds assembly time

   1564 lines source file
   1726 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
