 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 1 - 14/1/2017 18:20:18


       1/       0 :                     
       2/       0 :                     	cpu 	1802
       3/       0 :                     	
       4/       0 : =0H                 r0 = 0 																	; not used (may be used in interrupt display)
       5/       0 : =1H                 r1 = 1 																	; interrupt register
       6/       0 : =2H                 r2 = 2 																	; stack pointer
       7/       0 : =3H                 r3 = 3 																	; general run P
       8/       0 :                     
       9/       0 : =6H                 rVarPtr = 6 															; always points to variables (64 variables 2 bytes each 6 bit ASCII)
      10/       0 : =7H                 rExprPC = 7 															; used as P register in expression (mandated)
      11/       0 : =8H                 rSrc = 8 																; source code.
      12/       0 : =9H                 rSpecialHandler = 9 													; special variables handler.
      13/       0 : =AH                 rParenthesisLevel = 10 													; bracket level (low byte)
      14/       0 : =BH                 rSaveStack = 11 														; original value of stack pointer
      15/       0 :                     
      16/       0 : =CH                 rUtilPC = 12 															; used as P register calling routines (not mandated)
      17/       0 : =DH                 rSubPC = 13																; used as P register to call routines within routines
      18/       0 : =EH                 rParam1 = 14 															; subroutine parameters/return values.
      19/       0 : =FH                 rParam2 = 15
      20/       0 :                     
      21/       0 :                     return macro 															; allows subroutine returns to disable/enable interrupts as you want.
      22/       0 :                     	dis 																; this program uses MARK-subroutines
      23/       0 :                     	endm
      24/       0 :                     
      25/       0 :                     lrx macro 	r,n 														; load 16 bit value into register macro
      26/       0 :                     	ldi 	(n)/256
      27/       0 :                     	phi 	r
      28/       0 :                     	ldi 	(n)&255
      29/       0 :                     	plo 	r
      30/       0 :                     	endm
      31/       0 :                     
      32/       0 :                     ; ***************************************************************************************************************
      33/       0 :                     ;
      34/       0 :                     ;													Start up 1802
      35/       0 :                     ;
      36/       0 :                     ; ***************************************************************************************************************
      37/       0 :                     
      38/       0 : (MACRO)             	return 																; enable/disable interrupts, switch to R3.
      38/       0 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
      39/       1 : 00                  	db 		000h
      40/       2 : 90                  	ghi 	r0
      41/       3 : B3                  	phi 	r3
      42/       4 : F8 08               	ldi 	start & 255
      43/       6 : A3                  	plo 	r3
      44/       7 : D3                  	sep 	r3
      45/       8 :                     
      46/       8 :                     ; ***************************************************************************************************************
      47/       8 :                     ;
      48/       8 :                     ;												Initialisation
      49/       8 :                     ;
      50/       8 :                     ; ***************************************************************************************************************
      51/       8 :                     
      52/       8 :                     start:
      53/       8 : (MACRO)             	lrx 	r2,0FFFFh 													; find top of memory for stack & vartop.
      53/       8 : F8 FF                       ldi     (0FFFFH)/256
      53/       A : B2                          phi     R2
      53/       B : F8 FF                       ldi     (0FFFFH)&255
      53/       D : A2                          plo     R2
      54/       E : E2                  	sex 	r2 															; this won't work with mirrored memory.
      55/       F :                     findRAMTop:
 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 2 - 14/1/2017 18:20:18


      56/       F : F8 5A               	ldi 	05Ah 														; write this and re-read it.
      57/      11 : 52                  	str 	r2 													
      58/      12 : 02                  	ldn 	r2	
      59/      13 : FB 5A               	xri 	05Ah 														; check the write actually worked.
      60/      15 : 32 1D               	bz		foundRAMTop
      61/      17 : 92                  	ghi 	r2
      62/      18 : FF 01               	smi 	1
      63/      1A : B2                  	phi 	r2
      64/      1B : 30 0F               	br 		findRAMTop 
      65/      1D :                     foundRAMTop:
      66/      1D : F8 55               	ldi 	('*' & 03Fh) * 2 + 1 										; set up rVarPtr.0 so it will point to MSB of RAMTop.
      67/      1F : A6                  	plo 	rVarPtr
      68/      20 : 92                  	ghi 	r2 															; use the top page of RAM for the variables + keyboard buffer
      69/      21 : B6                  	phi 	rVarPtr
      70/      22 : FF 01               	smi 	1 															; and the page below that is the stack.
      71/      24 : B2                  	phi 	r2
      72/      25 : 56                  	str 	rVarPtr 													; save in RAMTop MSB
      73/      26 : 26                  	dec 	rVarPtr
      74/      27 : F8 00               	ldi 	0 															; zero RAMTop LSB
      75/      29 : 56                  	str 	rVarPtr
      76/      2A :                     
      77/      2A : (MACRO)             	lrx 	rSrc,eString 												; evaluate the string
      77/      2A : F8 00                       ldi     (ESTRING)/256
      77/      2C : B8                          phi     RSRC
      77/      2D : F8 41                       ldi     (ESTRING)&255
      77/      2F : A8                          plo     RSRC
      78/      30 : (MACRO)             	lrx 	rExprPC,EXPRevaluate 										; the code
      78/      30 : F8 01                       ldi     (EXPREVALUATE)/256
      78/      32 : B7                          phi     REXPRPC
      78/      33 : F8 0B                       ldi     (EXPREVALUATE)&255
      78/      35 : A7                          plo     REXPRPC
      79/      36 : (MACRO)             	lrx 	rSpecialHandler,SpecialHandler 								; dummy special handler.
      79/      36 : F8 03                       ldi     (SPECIALHANDLER)/256
      79/      38 : B9                          phi     RSPECIALHANDLER
      79/      39 : F8 01                       ldi     (SPECIALHANDLER)&255
      79/      3B : A9                          plo     RSPECIALHANDLER
      80/      3C : 79                  	mark
      81/      3D : D7                  	sep 	rExprPC
      82/      3E : 22                  	dec 	r2
      83/      3F :                     wait:
      84/      3F : 30 3F               	br 	wait
      85/      41 :                     
      86/      41 :                     eString:
      87/      41 : 3A 31 29 00         	db 		":1)",0
      88/      45 :                     ;	db 		"(4*5)-(2*3)*2",0
      89/      45 :                     
      90/      45 :                     	align 	256 
      91/     100 :                     	include expression.asm 												; expression evaluator, all arithmetic, atoi/itoa
(1)    1/     100 :                     ; ***************************************************************************************************************
(1)    2/     100 :                     ; ***************************************************************************************************************
(1)    3/     100 :                     ;
(1)    4/     100 :                     ;		File:		expression.asm
(1)    5/     100 :                     ;		Purpose:	Evaluate an ASCII expression.
(1)    6/     100 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     100 :                     ;		Date:		11th January 2017.
(1)    8/     100 :                     ;
(1)    9/     100 :                     ; ***************************************************************************************************************
(1)   10/     100 :                     ; ***************************************************************************************************************
(1)   11/     100 :                     
(1)   12/     100 :                     ; ***************************************************************************************************************
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 3 - 14/1/2017 18:20:18


(1)   13/     100 :                     ;
(1)   14/     100 :                     ;	Expression Evaluator : L -> R evaluation with parenthesis.
(1)   15/     100 :                     ;
(1)   16/     100 :                     ;	rSrc 			points to ASCIIZ expression, next character on exit. 
(1)   17/     100 :                     ;	rExprPC 		runs in this R(P), this is mandatory.
(1)   18/     100 :                     ;	rVarPtr.1 		points to variables
(1)   19/     100 :                     ; 	rParam1 		returned value of expression.
(1)   20/     100 :                     ;	rSpecialHandler	Routine (ends with sep rExprPC) which processes the provided character for special values
(1)   21/     100 :                     ;					e.g. side effect variables like ?. Char in D, zeroes D if the character is found and processed,
(1)   22/     100 :                     ;					in which case the result should be in rParam2
(1)   23/     100 :                     ;
(1)   24/     100 :                     ;	This does not report errors. VTL-2 does not. So if you have an error then the result returned may be somewhat
(1)   25/     100 :                     ;	unexpected and should not be relied on, despite what the VTL-2 manual hints :)
(1)   26/     100 :                     ;
(1)   27/     100 :                     ;	Note this routine breaks most of the registers R6-R15. If this is called recursively it must still run in
(1)   28/     100 :                     ;	rExprPC and the original rExprPC,rSrc,rParenthesisLevel and rSaveStack must be saved. rVarPtr does not change
(1)   29/     100 :                     ;	but must be restored if changed by an external routine.
(1)   30/     100 :                     ;
(1)   31/     100 :                     ;	The routine is designed to occupy two complete pages. At present there are about 16 bytes free at the end of
(1)   32/     100 :                     ;	each page allowing for bug fixing, if the first page is preceded by the preamble (dis ; loading r3 ; sep r3)
(1)   33/     100 :                     ;
(1)   34/     100 :                     ; ***************************************************************************************************************
(1)   35/     100 :                     
(1)   36/     100 :                     __EXPRExitDec:
(1)   37/     100 : 28                  	dec 	rSrc 														; unpick bad source gets
(1)   38/     101 :                     __EXPRExit:
(1)   39/     101 : 8B                  	glo 	rSaveStack 													; because we don't handle errors properly we 
(1)   40/     102 : A2                  	plo 	r2 															; may have incomplete operations on exit.
(1)   41/     103 : 9B                  	ghi 	rSaveStack 													; (VTL-2 does not report expression syntax errors)
(1)   42/     104 : B2                  	phi 	r2
(1)   43/     105 : 22                  	dec 	r2 															; load top most expression which is the answer
(1)   44/     106 : 42                  	lda 	r2 															; if it actually worked.
(1)   45/     107 : AE                  	plo 	rParam1
(1)   46/     108 : 42                  	lda 	r2
(1)   47/     109 : BE                  	phi 	rParam1
(1)   48/     10A : (MACRO)             	return
(1)   48/     10A : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)   49/     10B :                     
(1)   50/     10B :                     EXPREvaluate:
(1)   51/     10B : E2                  	sex 	r2 															; using X = 2 again
(1)   52/     10C : F8 00               	ldi 	0 															; clear parenthesis level to 0.
(1)   53/     10E : AA                  	plo 	rParenthesisLevel 
(1)   54/     10F :                     
(1)   55/     10F : 82                  	glo	 	r2 															; save original stack position
(1)   56/     110 : AB                  	plo 	rSaveStack
(1)   57/     111 : 92                  	ghi 	r2
(1)   58/     112 : BB                  	phi 	rSaveStack 
(1)   59/     113 :                     
(1)   60/     113 :                     __EXPRNewLevel:	
(1)   61/     113 : F8 00               	ldi 	0 															; push $0000  + on the stack.
(1)   62/     115 : 73                  	stxd 																; MSB first
(1)   63/     116 : 73                  	stxd 																; LSB
(1)   64/     117 : F8 2B               	ldi 	'+' 												 		; the put '+' on the stack as pending operation.
(1)   65/     119 : 73                  	stxd
(1)   66/     11A : 1A                  	inc 	rParenthesisLevel 											; bump the parenthesis level up 1.
(1)   67/     11B :                     ;
(1)   68/     11B :                     ;		On reaching this point, we are looking for a new Term.
(1)   69/     11B :                     ;
(1)   70/     11B :                     __EXPRNewTerm:
(1)   71/     11B : 88                  	glo 	rSrc 														; put rSrc into rParam1
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 4 - 14/1/2017 18:20:18


(1)   72/     11C : AE                  	plo 	rParam1
(1)   73/     11D : 98                  	ghi 	rSrc
(1)   74/     11E : BE                  	phi 	rParam1
(1)   75/     11F :                     
(1)   76/     11F : (MACRO)             	lrx 	rUtilPC,ASCIIToInteger 										; call the atoi() routine.
(1)   76/     11F : F8 02                       ldi     (ASCIITOINTEGER)/256
(1)   76/     121 : BC                          phi     RUTILPC
(1)   76/     122 : F8 B0                       ldi     (ASCIITOINTEGER)&255
(1)   76/     124 : AC                          plo     RUTILPC
(1)   77/     125 : 79                  	mark
(1)   78/     126 : DC                  	sep 	rUtilPC
(1)   79/     127 : 22                  	dec 	r2 		
(1)   80/     128 :                     
(1)   81/     128 : FC FF               	adi 	0FFh 														; sets DF if non zero value returned
(1)   82/     12A : 8E                  	glo 	rParam1 													; constant rParam1 back into rSrc
(1)   83/     12B : A8                  	plo 	rSrc
(1)   84/     12C : 9E                  	ghi 	rParam1
(1)   85/     12D : B8                  	phi 	rSrc
(1)   86/     12E : 33 5E               	bdf 	__EXPRGotTerm 												; if constant then done.
(1)   87/     130 :                     
(1)   88/     130 : 48                  	lda 	rSrc 														; look at character.
(1)   89/     131 : 32 00               	bz 		__EXPRExitDec 												; none provided.
(1)   90/     133 : FB 22               	xri 	'"'															; is it quote mark
(1)   91/     135 : 32 56               	bz 		__EXPRGotCharacter 											; if so do that handler.
(1)   92/     137 : FB 0A               	xri	 	'('!'"' 													; is it open parenthesis.
(1)   93/     139 : 32 13               	bz		__EXPRNewLevel 												; if so open new level.
(1)   94/     13B : FB 12               	xri 	':'!'('														; is it new array ?
(1)   95/     13D : 32 4E               	bz 		__EXPRArray
(1)   96/     13F : FB 3A               	xri 	':' 														; so make it back to the correct character.
(1)   97/     141 : D9                  	sep 	rSpecialHandler 											; check for 'special ones'
(1)   98/     142 : 32 5E               	bz 		__EXPRGotTerm 												; if found one, we've got a term.
(1)   99/     144 :                     
(1)  100/     144 : FA 3F               	ani 	03Fh 														; convert to six bit ASCII.
(1)  101/     146 : FE                  	shl 																; byte size to word size
(1)  102/     147 : A6                  	plo 	rVarPtr 													; now point to variable
(1)  103/     148 : 46                  	lda 	rVarPtr 													; read LSB into Param2
(1)  104/     149 : AF                  	plo 	rParam2
(1)  105/     14A : 06                  	ldn 	rVarPtr 													; and MSB
(1)  106/     14B : BF                  	phi 	rParam2
(1)  107/     14C : 30 5E               	br 		__EXPRGotTerm 
(1)  108/     14E :                     ;
(1)  109/     14E :                     ;	Found an array : - same as open parenthesis except we stack a '@'
(1)  110/     14E :                     ;	
(1)  111/     14E :                     __EXPRArray:
(1)  112/     14E : F8 40               	ldi 	'@' 														; push @@@ on the stack,  the first two don't matter.
(1)  113/     150 : 73                  	stxd
(1)  114/     151 : 73                  	stxd
(1)  115/     152 : 73                  	stxd
(1)  116/     153 : 1A                  	inc 	rParenthesisLevel 											; it's like bracket with a different operator.
(1)  117/     154 : 30 1B               	br 		__EXPRNewTerm
(1)  118/     156 :                     ;
(1)  119/     156 :                     ;	Found a "<char>" 
(1)  120/     156 :                     ;
(1)  121/     156 :                     __EXPRGotCharacter:
(1)  122/     156 : BF                  	phi 	rParam2 													; clear high byte of rParam2.
(1)  123/     157 : 48                  	lda 	rSrc 														; get character in quotes, skip over it
(1)  124/     158 : 32 00               	bz 		__EXPRExitDec 												; none provided, exit backing up.
(1)  125/     15A : AF                  	plo 	rParam2 													; put in rParam2.0
(1)  126/     15B : 48                  	lda 	rSrc 														; look for what should be a quote but we dont check
(1)  127/     15C : 32 00               	bz 		__EXPRExitDec
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 5 - 14/1/2017 18:20:18


(1)  128/     15E :                     ;
(1)  129/     15E :                     ;	New term is in rParam2. Look at the TOS expression to do, look it up and do it.
(1)  130/     15E :                     ;
(1)  131/     15E :                     __EXPRGotTerm:  														; new term is in rParam2.
(1)  132/     15E : 12                  	inc 	r2 															; point stack to operator.
(1)  133/     15F : (MACRO)             	lrx 	rParam1,(__OperatorTable-2) 								; rParam1 is the operator look up table.
(1)  133/     15F : F8 01                       ldi     ((__OPERATORTABLE-2))/256
(1)  133/     161 : BE                          phi     RPARAM1
(1)  133/     162 : F8 A4                       ldi     ((__OPERATORTABLE-2))&255
(1)  133/     164 : AE                          plo     RPARAM1
(1)  134/     165 :                     __EXPRFindOperation:
(1)  135/     165 : 1E                  	inc 	rParam1
(1)  136/     166 : 1E                  	inc 	rParam1
(1)  137/     167 : 4E                  	lda 	rParam1 													; look to see what it is.
(1)  138/     168 : 32 6D               	bz 		__EXPRFoundOperation 										; end of table.
(1)  139/     16A : F3                  	xor 																; same as stacked operator
(1)  140/     16B : 3A 65               	bnz 	__EXPRFindOperation 
(1)  141/     16D :                     __EXPRFoundOperation:	
(1)  142/     16D : 42                  	lda 	r2 															; load the stacked value into rParenthesisLevel.1
(1)  143/     16E : BA                  	phi 	rParenthesisLevel
(1)  144/     16F : 4E                  	lda 	rParam1 													; put address of routine into rUtilPC
(1)  145/     170 : AC                  	plo 	rUtilPC
(1)  146/     171 : 0E                  	ldn 	rParam1
(1)  147/     172 : BC                  	phi 	rUtilPC
(1)  148/     173 :                     
(1)  149/     173 : 42                  	lda 	r2 															; read TOS for into param1
(1)  150/     174 : AE                  	plo 	rParam1
(1)  151/     175 : 02                  	ldn 	r2
(1)  152/     176 : BE                  	phi 	rParam1
(1)  153/     177 : 79                  	mark  																; and call the routine.
(1)  154/     178 : DC                  	sep 	rUtilPC
(1)  155/     179 : 22                  	dec 	r2
(1)  156/     17A :                     
(1)  157/     17A :                     ;
(1)  158/     17A :                     ;	Having got the result, check to see if it was divide, if so write out the remainder to '%'
(1)  159/     17A :                     ;
(1)  160/     17A : 9A                  	ghi 	rParenthesisLevel 											; get the operator
(1)  161/     17B : FB 2F               	xri 	'/'															; was it divide ?
(1)  162/     17D : 3A 87               	bnz 	__EXPRNotDivide
(1)  163/     17F : F8 4A               	ldi 	('%' & 03Fh) * 2 											; point rVarPtr to % variable
(1)  164/     181 : A6                  	plo 	rVarPtr
(1)  165/     182 : 8F                  	glo 	rParam2 													; save remainder there
(1)  166/     183 : 56                  	str 	rVarPtr
(1)  167/     184 : 9F                  	ghi 	rParam2
(1)  168/     185 : 16                  	inc 	rVarPtr
(1)  169/     186 : 56                  	str 	rVarPtr
(1)  170/     187 :                     __EXPRNotDivide:	
(1)  171/     187 :                     
(1)  172/     187 : 9E                  	ghi 	rParam1 													; push the result back on the stack.
(1)  173/     188 : 73                  	stxd
(1)  174/     189 : 8E                  	glo 	rParam1
(1)  175/     18A : 73                  	stxd
(1)  176/     18B :                     ;
(1)  177/     18B :                     ;	Get the next operation, this is normally stacked, except if ) in which case the bracketed operation is closed
(1)  178/     18B :                     ;
(1)  179/     18B :                     __EXPRSkipSpace:
(1)  180/     18B : 48                  	lda 	rSrc 														; get the next operator.
(1)  181/     18C : 32 00               	bz 		__EXPRExitDec 												; done the next operator.
(1)  182/     18E : FB 20               	xri 	' '
(1)  183/     190 : 32 8B               	bz 		__EXPRSkipSpace
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 6 - 14/1/2017 18:20:18


(1)  184/     192 : FB 09               	xri 	')'!' '														; was it )
(1)  185/     194 : 32 9B               	bz 		__EXPRDestackBracket
(1)  186/     196 : FB 29               	xri 	')' 														; get it back
(1)  187/     198 : 73                  	stxd 																; push it on the stack.
(1)  188/     199 : 30 1B               	br 		__EXPRNewTerm 												; and get the next term.
(1)  189/     19B :                     ;
(1)  190/     19B :                     ; 	Close the bracketed operation
(1)  191/     19B :                     ;
(1)  192/     19B :                     __EXPRDestackBracket:
(1)  193/     19B : 2A                  	dec 	rParenthesisLevel 											; dec brackets
(1)  194/     19C : 8A                  	glo 	rParenthesisLevel 											; if zero it is end of expression ) so exit.	
(1)  195/     19D : 32 01               	bz 		__EXPRExit
(1)  196/     19F :                     
(1)  197/     19F : 12                  	inc 	r2 															; pop rParam2 off the stack.
(1)  198/     1A0 : 42                  	lda 	r2
(1)  199/     1A1 : AF                  	plo 	rParam2
(1)  200/     1A2 : 02                  	ldn 	r2
(1)  201/     1A3 : BF                  	phi 	rParam2
(1)  202/     1A4 :                     
(1)  203/     1A4 : 30 5E               	br 		__EXPRGotTerm 												; go back and do the stacked operation below
(1)  204/     1A6 :                     
(1)  205/     1A6 :                     ; ***************************************************************************************************************
(1)  206/     1A6 :                     ;
(1)  207/     1A6 :                     ;	Look up table for binary operators. 0 signifies the end of the table and default, so it covers - > < =
(1)  208/     1A6 :                     ;
(1)  209/     1A6 :                     ; ***************************************************************************************************************
(1)  210/     1A6 :                     
(1)  211/     1A6 :                     oper macro chdb,addr
(1)  212/     1A6 :                     	db 		chdb,(addr) & 255,(addr) / 256
(1)  213/     1A6 :                     	endm 
(1)  214/     1A6 :                     
(1)  215/     1A6 :                     __OperatorTable:
(1)  216/     1A6 : (MACRO)             	oper 	'+',__OpAdd 
(1)  216/     1A6 : 2B 00 02                    db              '+',(__OPADD) & 255,(__OPADD) / 256
(1)  217/     1A9 : (MACRO)             	oper	'*',Multiply
(1)  217/     1A9 : 2A 8B 02                    db              '*',(MULTIPLY) & 255,(MULTIPLY) / 256
(1)  218/     1AC : (MACRO)             	oper 	'/',Divide
(1)  218/     1AC : 2F B7 01                    db              '/',(DIVIDE) & 255,(DIVIDE) / 256
(1)  219/     1AF : (MACRO)             	oper 	'@',__OpLookUp 
(1)  219/     1AF : 40 0D 02                    db              '@',(__OPLOOKUP) & 255,(__OPLOOKUP) / 256
(1)  220/     1B2 : (MACRO)             	oper 	0,__OpSub
(1)  220/     1B2 : 00 26 02                    db              0,(__OPSUB) & 255,(__OPSUB) / 256
(1)  221/     1B5 :                     
(1)  222/     1B5 :                     ; ***************************************************************************************************************
(1)  223/     1B5 :                     ;
(1)  224/     1B5 :                     ;										Divide Code here
(1)  225/     1B5 :                     ;
(1)  226/     1B5 :                     ; ***************************************************************************************************************
(1)  227/     1B5 :                     
(1)  228/     1B5 :                     	include utility/divide.asm
(2)    1/     1B5 :                     ; ***************************************************************************************************************
(2)    2/     1B5 :                     ; ***************************************************************************************************************
(2)    3/     1B5 :                     ;
(2)    4/     1B5 :                     ;		File:		divide.asm
(2)    5/     1B5 :                     ;		Purpose:	Divide two 16 bit integers.
(2)    6/     1B5 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(2)    7/     1B5 :                     ;		Date:		9th January 2017.
(2)    8/     1B5 :                     ;		Size: 		54 bytes.
(2)    9/     1B5 :                     ;
(2)   10/     1B5 :                     ; ***************************************************************************************************************
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(divide.asm) - page 7 - 14/1/2017 18:20:18


(2)   11/     1B5 :                     ; ***************************************************************************************************************
(2)   12/     1B5 :                     
(2)   13/     1B5 :                     ; *******************************************************************************************************************
(2)   14/     1B5 :                     ;
(2)   15/     1B5 :                     ;				Calculate rParam1 / rParam2.  Result in rParam1. Remainder in rParam2.
(2)   16/     1B5 :                     ;
(2)   17/     1B5 :                     ; *******************************************************************************************************************
(2)   18/     1B5 :                     
(2)   19/     1B5 :                     __DIVExit:
(2)   20/     1B5 : 12                  	inc 	r2 															; point to XP on the stack
(2)   21/     1B6 : (MACRO)             	return
(2)   21/     1B6 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(2)   22/     1B7 :                     
(2)   23/     1B7 :                     Divide:
(2)   24/     1B7 : E2                  	sex 	r2 															; back using R2 as the index register
(2)   25/     1B8 :                     																		; rParam1 is the dividend.
(2)   26/     1B8 :                     																		; rParam2 is the remainder.
(2)   27/     1B8 :                     																		; tos is [divisor:2][counter:1] 
(2)   28/     1B8 :                     
(2)   29/     1B8 : F8 10               	ldi 	16															; push counter on stack - 16 because post	
(2)   30/     1BA : 73                  	stxd 																; decrements in main loop.
(2)   31/     1BB :                     
(2)   32/     1BB : 9F                  	ghi 	rParam2 													; push divisor on stack.
(2)   33/     1BC : 73                  	stxd
(2)   34/     1BD : 8F                  	glo 	rParam2
(2)   35/     1BE : 52                  	str 	r2 	
(2)   36/     1BF :                     	
(2)   37/     1BF : F8 00               	ldi 	0 															; clear the remainder
(2)   38/     1C1 : BF                  	phi 	rParam2
(2)   39/     1C2 : AF                  	plo 	rParam2
(2)   40/     1C3 : F4                  	add 																; anything + 0 clears DF.
(2)   41/     1C4 :                     
(2)   42/     1C4 :                     __DIVLoopIncR2IncR2:
(2)   43/     1C4 : 12                  	inc		r2 															; point R2 back to the counter.
(2)   44/     1C5 :                     __DIVLoopIncR2:
(2)   45/     1C5 : 12                  	inc 	r2
(2)   46/     1C6 :                     
(2)   47/     1C6 :                     __DIVLoop:
(2)   48/     1C6 :                     
(2)   49/     1C6 : 8E                  	glo 	rParam1 													; shift DF into dividend, shift old bit 15 to DF
(2)   50/     1C7 : 7E                  	rshl
(2)   51/     1C8 : AE                  	plo 	rParam1
(2)   52/     1C9 : 9E                  	ghi 	rParam1
(2)   53/     1CA : 7E                  	rshl
(2)   54/     1CB : BE                  	phi 	rParam1
(2)   55/     1CC :                     
(2)   56/     1CC : 02                  	ldn 	r2 															; look at counter.
(2)   57/     1CD : 32 B5               	bz 		__DIVExit 													; if zero then complete (decrement done later)
(2)   58/     1CF :                     
(2)   59/     1CF : 8F                  	glo	 	rParam2 													; shift DF into then remainder (rParam2)
(2)   60/     1D0 : 7E                  	rshl
(2)   61/     1D1 : AF                  	plo 	rParam2
(2)   62/     1D2 : 9F                  	ghi 	rParam2
(2)   63/     1D3 : 7E                  	rshl
(2)   64/     1D4 : BF                  	phi 	rParam2
(2)   65/     1D5 :                     
(2)   66/     1D5 : 02                  	ldn 	r2 															; decrement the counter (AFTER the test)
(2)   67/     1D6 : FF 01               	smi 	1
(2)   68/     1D8 : 73                  	stxd 																; when saving back, point R2 to divisor LSB.
(2)   69/     1D9 : 22                  	dec 	r2
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(divide.asm) - page 8 - 14/1/2017 18:20:18


(2)   70/     1DA :                     
(2)   71/     1DA : 8F                  	glo 	rParam2 													; calculate remainder.0 - divisor.0
(2)   72/     1DB : F7                  	sm
(2)   73/     1DC : 22                  	dec 	r2 															; save the interim value below the LSB.
(2)   74/     1DD : 52                  	str 	r2
(2)   75/     1DE : 12                  	inc 	r2 															; to LSB
(2)   76/     1DF : 12                  	inc		r2 															; to MSB
(2)   77/     1E0 : 9F                  	ghi 	rParam2 													; calculate remainder.1 - divisor.1
(2)   78/     1E1 : 77                  	smb
(2)   79/     1E2 :                     
(2)   80/     1E2 : 3B C5               	bnf 	__DIVLoopIncR2 												; if DF = 0 then inc r2 (to ctr) and loop back
(2)   81/     1E4 :                     
(2)   82/     1E4 : BF                  	phi 	rParam2 													; copy result to remainder
(2)   83/     1E5 : 22                  	dec 	r2 															; to divisor.0
(2)   84/     1E6 : 22                  	dec 	r2 															; to temp result
(2)   85/     1E7 : 42                  	lda 	r2 															; get temp result, to divisor.0
(2)   86/     1E8 : AF                  	plo 	rParam2
(2)   87/     1E9 : 30 C4               	br 		__DIVLoopIncR2IncR2 										; go back, inc r2 twice to counter
(2)   88/     1EB :                     
(1)  229/     1EB :                     	align 	256
(1)  230/     200 :                     	
(1)  231/     200 :                     ; ***************************************************************************************************************
(1)  232/     200 :                     ;
(1)  233/     200 :                     ;								Addition. rParam1 := rParam1 + rParam2
(1)  234/     200 :                     ;
(1)  235/     200 :                     ; ***************************************************************************************************************
(1)  236/     200 :                     
(1)  237/     200 :                     __OpAdd:
(1)  238/     200 : E2                  	sex		r2 														; rParam1 := rParam1 + rParam2
(1)  239/     201 : 8F                  	glo 	rParam2
(1)  240/     202 : 52                  	str 	r2
(1)  241/     203 : 8E                  	glo 	rParam1
(1)  242/     204 : F4                  	add	
(1)  243/     205 : AE                  	plo 	rParam1
(1)  244/     206 : 9F                  	ghi 	rParam2
(1)  245/     207 : 52                  	str 	r2
(1)  246/     208 : 9E                  	ghi 	rParam1
(1)  247/     209 : 74                  	adc
(1)  248/     20A : BE                  	phi 	rParam1
(1)  249/     20B : 12                  	inc 	r2
(1)  250/     20C : (MACRO)             	return
(1)  250/     20C : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)  251/     20D :                     
(1)  252/     20D :                     ; ***************************************************************************************************************
(1)  253/     20D :                     ;
(1)  254/     20D :                     ;				Array Lookup. rParam1 := Memory['&' + rParam * 2]. '*' is the top of memory variable.
(1)  255/     20D :                     ;
(1)  256/     20D :                     ; ***************************************************************************************************************
(1)  257/     20D :                     
(1)  258/     20D :                     __OpLookUp: 														; rParam1 := Memory[& + rParam2 * 2]
(1)  259/     20D : E2                  	sex 	r2
(1)  260/     20E : 8F                  	glo 	rParam2 												; double rParam2
(1)  261/     20F : FE                  	shl
(1)  262/     210 : AF                  	plo 	rParam2
(1)  263/     211 : 9F                  	ghi 	rParam2
(1)  264/     212 : 7E                  	rshl
(1)  265/     213 : BF                  	phi 	rParam2
(1)  266/     214 : F8 4C               	ldi 	('&' & 03Fh) * 2 										; point VarPtr to '&' variable
(1)  267/     216 : A6                  	plo 	rVarPtr
(1)  268/     217 : E6                  	sex 	rVarPtr
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 9 - 14/1/2017 18:20:18


(1)  269/     218 :                     
(1)  270/     218 : 8F                  	glo 	rParam2 												; add contents of & to rParam2 
(1)  271/     219 : F4                  	add
(1)  272/     21A : AF                  	plo 	rParam2		
(1)  273/     21B : 16                  	inc 	rVarPtr
(1)  274/     21C : 9F                  	ghi 	rParam2
(1)  275/     21D : 74                  	adc
(1)  276/     21E : BF                  	phi 	rParam2 
(1)  277/     21F :                     
(1)  278/     21F : 4F                  	lda 	rParam2 												; read rParam2 into rParam1
(1)  279/     220 : AE                  	plo 	rParam1
(1)  280/     221 : 0F                  	ldn 	rParam2
(1)  281/     222 : BE                  	phi 	rParam1
(1)  282/     223 :                     __OpReturn:	
(1)  283/     223 : E2                  	sex 	r2
(1)  284/     224 : 12                  	inc 	r2
(1)  285/     225 : (MACRO)             	return
(1)  285/     225 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)  286/     226 :                     
(1)  287/     226 :                     ; ***************************************************************************************************************
(1)  288/     226 :                     ;
(1)  289/     226 :                     ;								Subtraction. rParam1 := rParam1 - rParam2
(1)  290/     226 :                     ;									 (Also > < = which return 0 or 1)
(1)  291/     226 :                     ;
(1)  292/     226 :                     ; ***************************************************************************************************************
(1)  293/     226 :                     
(1)  294/     226 :                     __OpSub:															; rParam1 := rParam1 - rParam2
(1)  295/     226 : E2                  	sex		r2
(1)  296/     227 : 8F                  	glo 	rParam2
(1)  297/     228 : 52                  	str 	r2
(1)  298/     229 : 8E                  	glo 	rParam1
(1)  299/     22A : F7                  	sm
(1)  300/     22B : AE                  	plo 	rParam1
(1)  301/     22C : 9F                  	ghi 	rParam2
(1)  302/     22D : 52                  	str 	r2
(1)  303/     22E : 9E                  	ghi 	rParam1
(1)  304/     22F : 77                  	smb
(1)  305/     230 : BE                  	phi 	rParam1
(1)  306/     231 :                     
(1)  307/     231 : 9A                  	ghi 	rParenthesisLevel 										; this is the saved operator character
(1)  308/     232 : FB 2D               	xri 	'-'														; exit if '-'
(1)  309/     234 : 32 23               	bz 		__OpReturn
(1)  310/     236 : FB 10               	xri 	'-'!'='													; check if equals.
(1)  311/     238 : 32 47               	bz 		__OpEquality
(1)  312/     23A :                     ;
(1)  313/     23A :                     ;	Handle < > option. Note that > is actually the >= operation and is also the overall default.
(1)  314/     23A :                     ;
(1)  315/     23A : FB 03               	xri 	'>'!'='													; will now be 0 if >= , nonzero for < if anything else.
(1)  316/     23C : 32 40               	bz 		__OpLT0 	
(1)  317/     23E : F8 01               	ldi 	1
(1)  318/     240 :                     __OpLT0: 															; now 0 if >, 1 if <
(1)  319/     240 : 7C 00               	adci 	0 														; will now be odd if correct - adds in result from subtract
(1)  320/     242 : FA 01               	ani 	1 														; so isolate bit zero
(1)  321/     244 : 30 51               	br 		__OpWriteBoolean 										; and write it out.
(1)  322/     246 :                     
(1)  323/     246 : (MACRO)             	return
(1)  323/     246 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)  324/     247 :                     ;
(1)  325/     247 :                     ;	Handle = option
(1)  326/     247 :                     ;
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(expression.asm) - page 10 - 14/1/2017 18:20:18


(1)  327/     247 :                     __OpEquality:
(1)  328/     247 : 8E                  	glo 	rParam1 												; get low result
(1)  329/     248 : 3A 4B               	bnz 	__OpEqNZ 	
(1)  330/     24A : 9E                  	ghi 	rParam1 												; if zero get high result
(1)  331/     24B :                     __OpEqNZ:															; if zero here both are zero e.g. it is 'true'
(1)  332/     24B : 32 4F               	bz 		__OpEqIsTrue 											
(1)  333/     24D : F8 01               	ldi 	1 															
(1)  334/     24F :                     __OpEqIsTrue:														; now 0 true 1 false
(1)  335/     24F : FB 01               	xri 	1 														; now 1 true 0 false
(1)  336/     251 :                     __OpWriteBoolean:	
(1)  337/     251 : AE                  	plo 	rParam1 												; put into rParam1
(1)  338/     252 : F8 00               	ldi 	0
(1)  339/     254 : BE                  	phi 	rParam1 							
(1)  340/     255 : 30 23               	br 		__OpReturn
(1)  341/     257 :                     
(1)  342/     257 :                     ; ***************************************************************************************************************
(1)  343/     257 :                     ;
(1)  344/     257 :                     ;										Outstanding utility routines fit here
(1)  345/     257 :                     ;
(1)  346/     257 :                     ; ***************************************************************************************************************
(1)  347/     257 :                     
(1)  348/     257 :                     	include utility/itoa.asm
(2)    1/     257 :                     ; ***************************************************************************************************************
(2)    2/     257 :                     ; ***************************************************************************************************************
(2)    3/     257 :                     ;
(2)    4/     257 :                     ;		File:		itoa.asm
(2)    5/     257 :                     ;		Purpose:	Convert 16 bit integer to ASCIIZ string
(2)    6/     257 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(2)    7/     257 :                     ;		Date:		10th January 2017.
(2)    8/     257 :                     ;		Size: 		47 bytes.
(2)    9/     257 :                     ;
(2)   10/     257 :                     ; ***************************************************************************************************************
(2)   11/     257 :                     ; ***************************************************************************************************************
(2)   12/     257 :                     
(2)   13/     257 :                     ; *******************************************************************************************************************
(2)   14/     257 :                     ;
(2)   15/     257 :                     ;	rParam1 is the number to convert. rParam2 is the end of the buffer, the digits are written backwards. On exit.
(2)   16/     257 :                     ;	rParam2 points to the string terminated in a NULL character. The NULL character is at the original value
(2)   17/     257 :                     ;	of rParam2. 
(2)   18/     257 :                     ;
(2)   19/     257 :                     ; *******************************************************************************************************************
(2)   20/     257 :                     
(2)   21/     257 :                     __ITOAExit:
(2)   22/     257 : 12                  	inc 	r2
(2)   23/     258 : (MACRO)             	return
(2)   23/     258 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(2)   24/     259 :                     
(2)   25/     259 :                     IntegerToASCII:
(2)   26/     259 : E2                  	sex 	r2 															; index back at 2
(2)   27/     25A : F8 00               	ldi 	0 															; write the NULL terminator.
(2)   28/     25C : 5F                  	str 	rParam2
(2)   29/     25D :                     __ITOALoop:
(2)   30/     25D : 73                  	stxd 																; push dummy value, digit return stored here.
(2)   31/     25E : 9F                  	ghi 	rParam2 													; push rParam2 on the stack.
(2)   32/     25F : 73                  	stxd
(2)   33/     260 : 8F                  	glo	 	rParam2
(2)   34/     261 : 73                  	stxd
(2)   35/     262 : F8 00               	ldi 	0		 													; set to divide by 10.
(2)   36/     264 : BF                  	phi 	rParam2
(2)   37/     265 : F8 0A               	ldi 	10
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(itoa.asm) - page 11 - 14/1/2017 18:20:18


(2)   38/     267 : AF                  	plo 	rParam2
(2)   39/     268 : F8 01               	ldi 	Divide/256
(2)   40/     26A : BD                  	phi 	rSubPC
(2)   41/     26B : F8 B7               	ldi 	Divide&255
(2)   42/     26D : AD                  	plo 	rSubPC
(2)   43/     26E : 79                  	mark  
(2)   44/     26F : DD                  	sep 	rSubPC 														; do the call.
(2)   45/     270 : 12                  	inc 	r2
(2)   46/     271 : 12                  	inc 	r2 															; save digit result in dummy space
(2)   47/     272 : 8F                  	glo 	rParam2
(2)   48/     273 : 73                  	stxd 
(2)   49/     274 : 22                  	dec 	r2 															; now points to memory pointer for result
(2)   50/     275 : 42                  	lda 	r2 															; restore buffer pointer
(2)   51/     276 : AF                  	plo 	rParam2
(2)   52/     277 : 42                  	lda 	r2
(2)   53/     278 : BF                  	phi 	rParam2
(2)   54/     279 : 02                  	ldn 	r2 															; restore digit
(2)   55/     27A : F9 30               	ori		'0'															; make ASCII 
(2)   56/     27C : 2F                  	dec 	rParam2 													; back one character.
(2)   57/     27D : 5F                  	str 	rParam2 													; write into buffer
(2)   58/     27E :                     
(2)   59/     27E : 8E                  	glo 	rParam1 													; go around again if non-zero
(2)   60/     27F : 3A 5D               	bnz 	__ITOALoop
(2)   61/     281 : 9E                  	ghi 	rParam1
(2)   62/     282 : 3A 5D               	bnz 	__ITOALoop
(2)   63/     284 : 30 57               	br 		__ITOAExit 													; and prepare to exit.
(1)  349/     286 :                     	include utility/multiply.asm
(2)    1/     286 :                     ; ***************************************************************************************************************
(2)    2/     286 :                     ; ***************************************************************************************************************
(2)    3/     286 :                     ;
(2)    4/     286 :                     ;		File:		multiply.asm
(2)    5/     286 :                     ;		Purpose:	Multiply two 16 bit integers.
(2)    6/     286 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(2)    7/     286 :                     ;		Date:		9th January 2017.
(2)    8/     286 :                     ;		Size: 		41 bytes.
(2)    9/     286 :                     ;
(2)   10/     286 :                     ; ***************************************************************************************************************
(2)   11/     286 :                     ; ***************************************************************************************************************
(2)   12/     286 :                     
(2)   13/     286 :                     ; *******************************************************************************************************************
(2)   14/     286 :                     ;
(2)   15/     286 :                     ;	Multiply the values in rParam1 and rParam2 , returning result in rParam1.
(2)   16/     286 :                     ;
(2)   17/     286 :                     ; *******************************************************************************************************************
(2)   18/     286 :                     
(2)   19/     286 :                     __MULExit:
(2)   20/     286 : 42                  	lda 	r2 															; pop LSB result off stack.
(2)   21/     287 : AE                  	plo 	rParam1
(2)   22/     288 : 42                  	lda 	r2  														; pop MSB result off stack, do inc r2
(2)   23/     289 : BE                  	phi 	rParam1
(2)   24/     28A : (MACRO)             	return
(2)   24/     28A : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(2)   25/     28B :                     
(2)   26/     28B :                     Multiply:
(2)   27/     28B : E2                  	sex 	r2 															; back using R2 as the index register
(2)   28/     28C : F8 00               	ldi 	0 															; reset the result, which is on the stack.
(2)   29/     28E : 73                  	stxd	
(2)   30/     28F : 52                  	str 	r2
(2)   31/     290 :                     
(2)   32/     290 :                     __MULLoop:
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(multiply.asm) - page 12 - 14/1/2017 18:20:18


(2)   33/     290 :                     
(2)   34/     290 : 9E                  	ghi 	rParam1 													; shift first multiplier right into DF
(2)   35/     291 : F6                  	shr
(2)   36/     292 : BE                  	phi 	rParam1
(2)   37/     293 : 8E                  	glo 	rParam1
(2)   38/     294 : 76                  	rshr
(2)   39/     295 : AE                  	plo 	rParam1
(2)   40/     296 : 3B 9F               	bnf 	__MULDontAdd 												; if DF is set add rParam2 to the result.
(2)   41/     298 :                     
(2)   42/     298 : 8F                  	glo 	rParam2 													; add rParam2 to result on TOS.
(2)   43/     299 : F4                  	add 
(2)   44/     29A : 52                  	str 	r2
(2)   45/     29B : 12                  	inc 	r2
(2)   46/     29C : 9F                  	ghi 	rParam2
(2)   47/     29D : 74                  	adc
(2)   48/     29E : 73                  	stxd 
(2)   49/     29F :                     
(2)   50/     29F :                     __MULDontAdd:
(2)   51/     29F : 8F                  	glo 	rParam2 													; shift rParam2 left
(2)   52/     2A0 : FE                  	shl
(2)   53/     2A1 : AF                  	plo 	rParam2
(2)   54/     2A2 : 9F                  	ghi 	rParam2
(2)   55/     2A3 : 7E                  	rshl
(2)   56/     2A4 : BF                  	phi 	rParam2
(2)   57/     2A5 :                     
(2)   58/     2A5 : 8E                  	glo 	rParam1 													; is first multiplier non zero, if not go back.
(2)   59/     2A6 : 3A 90               	bnz 	__MULLoop
(2)   60/     2A8 : 9E                  	ghi 	rParam1
(2)   61/     2A9 : 3A 90               	bnz 	__MULLoop
(2)   62/     2AB : 30 86               	br 		__MULExit 													; both are zero, so exit.	
(1)  350/     2AD :                     	include utility/atoi.asm
(2)    1/     2AD :                     ; ***************************************************************************************************************
(2)    2/     2AD :                     ; ***************************************************************************************************************
(2)    3/     2AD :                     ;
(2)    4/     2AD :                     ;		File:		atoi.asm
(2)    5/     2AD :                     ;		Purpose:	Extract 16 bit integer from ASCII string.
(2)    6/     2AD :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(2)    7/     2AD :                     ;		Date:		9th January 2017.
(2)    8/     2AD :                     ;		Size: 		67 bytes.
(2)    9/     2AD :                     ;
(2)   10/     2AD :                     ; ***************************************************************************************************************
(2)   11/     2AD :                     ; ***************************************************************************************************************
(2)   12/     2AD :                     
(2)   13/     2AD :                     ; *******************************************************************************************************************
(2)   14/     2AD :                     ;
(2)   15/     2AD :                     ;	Takes one value in rParam1, pointer to a string, returns number read in rParam2.
(2)   16/     2AD :                     ;	rParam1 points to the next character after the last one of the number.	
(2)   17/     2AD :                     ;	
(2)   18/     2AD :                     ;	On exit non-zero if a digit was read.
(2)   19/     2AD :                     ;
(2)   20/     2AD :                     ; *******************************************************************************************************************
(2)   21/     2AD :                     
(2)   22/     2AD :                     __ATOIExit:
(2)   23/     2AD : 2E                  	dec 	rParam1 													; undo the last read, wasn't a digit.
(2)   24/     2AE : 42                  	lda 	r2 															; read the flag for 'digits read'
(2)   25/     2AF : (MACRO)             	return
(2)   25/     2AF : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(2)   26/     2B0 :                     
(2)   27/     2B0 :                     ASCIIToInteger:
(2)   28/     2B0 : E2                  	sex 	r2 															; index back at 2
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(atoi.asm) - page 13 - 14/1/2017 18:20:18


(2)   29/     2B1 : F8 00               	ldi 	0 															; clear number read
(2)   30/     2B3 : AF                  	plo 	rParam2
(2)   31/     2B4 : BF                  	phi 	rParam2
(2)   32/     2B5 : 52                  	str 	r2 															; [TOS] is count of digits read okay.
(2)   33/     2B6 :                     
(2)   34/     2B6 :                     __ATOILoop:
(2)   35/     2B6 : 4E                  	lda 	rParam1 													; read next character and bump
(2)   36/     2B7 : FB 20               	xri 	' ' 														; skip over spaces.
(2)   37/     2B9 : 32 B6               	bz 		__ATOILoop 												
(2)   38/     2BB : FB 20               	xri 	' ' 														; fix it back.
(2)   39/     2BD : FC C6               	adi 	255-'9' 													; will cause DF if >= '9'
(2)   40/     2BF : 33 AD               	bdf 	__ATOIExit
(2)   41/     2C1 : FC 0A               	adi 	10 															; adding 10 will cause NF if < '0'	
(2)   42/     2C3 : 3B AD               	bnf 	__ATOIExit
(2)   43/     2C5 :                     
(2)   44/     2C5 : 73                  	stxd 																; push digit value, current value of number
(2)   45/     2C6 : 9F                  	ghi 	rParam2  													; on stack.
(2)   46/     2C7 : 73                  	stxd
(2)   47/     2C8 : 8F                  	glo 	rParam2
(2)   48/     2C9 : 52                  	str 	r2
(2)   49/     2CA :                     
(2)   50/     2CA :                     __ATOIDoubleRParam2 macro 												; macro that doubles the value in rParam2
(2)   51/     2CA :                     	glo 	rParam2 													
(2)   52/     2CA :                     	shl
(2)   53/     2CA :                     	plo 	rParam2
(2)   54/     2CA :                     	ghi 	rParam2
(2)   55/     2CA :                     	rshl
(2)   56/     2CA :                     	phi 	rParam2
(2)   57/     2CA :                     	endm
(2)   58/     2CA :                     
(2)   59/     2CA : (MACRO)             	__ATOIDoubleRParam2 												; rParam2 * 2
(2)   59/     2CA : 8F                          glo     rParam2                                                                                                         
(2)   59/     2CB : FE                          shl
(2)   59/     2CC : AF                          plo     rParam2
(2)   59/     2CD : 9F                          ghi     rParam2
(2)   59/     2CE : 7E                          rshl
(2)   59/     2CF : BF                          phi     rParam2
(2)   60/     2D0 : (MACRO)             	__ATOIDoubleRParam2 												; rParam2 * 4
(2)   60/     2D0 : 8F                          glo     rParam2                                                                                                         
(2)   60/     2D1 : FE                          shl
(2)   60/     2D2 : AF                          plo     rParam2
(2)   60/     2D3 : 9F                          ghi     rParam2
(2)   60/     2D4 : 7E                          rshl
(2)   60/     2D5 : BF                          phi     rParam2
(2)   61/     2D6 : 8F                  	glo 	rParam2 													; add stack values on there.
(2)   62/     2D7 : F4                  	add
(2)   63/     2D8 : AF                  	plo 	rParam2
(2)   64/     2D9 : 12                  	inc 	r2
(2)   65/     2DA : 9F                  	ghi 	rParam2
(2)   66/     2DB : 74                  	adc
(2)   67/     2DC : BF                  	phi 	rParam2  													; so now rParam * 5
(2)   68/     2DD : (MACRO)             	__ATOIDoubleRParam2 												; so now rParam * 10
(2)   68/     2DD : 8F                          glo     rParam2                                                                                                         
(2)   68/     2DE : FE                          shl
(2)   68/     2DF : AF                          plo     rParam2
(2)   68/     2E0 : 9F                          ghi     rParam2
(2)   68/     2E1 : 7E                          rshl
(2)   68/     2E2 : BF                          phi     rParam2
(2)   69/     2E3 :                     
(2)   70/     2E3 : 12                  	inc 	r2 															; point to digit value
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(atoi.asm) - page 14 - 14/1/2017 18:20:18


(2)   71/     2E4 : 8F                  	glo 	rParam2
(2)   72/     2E5 : F4                  	add
(2)   73/     2E6 : AF                  	plo 	rParam2
(2)   74/     2E7 : 9F                  	ghi 	rParam2
(2)   75/     2E8 : 7C 00               	adci 	0
(2)   76/     2EA : BF                  	phi 	rParam2
(2)   77/     2EB :                     
(2)   78/     2EB : F8 FF               	ldi 	0FFh 														; set the 'read a digit' flag.
(2)   79/     2ED : 52                  	str 	r2 
(2)   80/     2EE : 30 B6               	br 		__ATOILoop
(2)   81/     2F0 :                     
(1)  351/     2F0 :                     
      92/     2F0 :                     
      93/     2F0 :                     	align 	256 
      94/     300 :                     	include handler.asm 												; special routine handler.
(1)    1/     300 :                     ; ***************************************************************************************************************
(1)    2/     300 :                     ; ***************************************************************************************************************
(1)    3/     300 :                     ;
(1)    4/     300 :                     ;		File:		handler.asm
(1)    5/     300 :                     ;		Purpose:	Handle side-effect variables on read.
(1)    6/     300 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     300 :                     ;		Date:		11th January 2017.
(1)    8/     300 :                     ;
(1)    9/     300 :                     ; ***************************************************************************************************************
(1)   10/     300 :                     ; ***************************************************************************************************************
(1)   11/     300 :                     
(1)   12/     300 :                     ; ***************************************************************************************************************
(1)   13/     300 :                     ;
(1)   14/     300 :                     ;		This routine provides the variable in D. On exit, if D = 0 the "variable" has been accessed and
(1)   15/     300 :                     ;		put in rParam2. Otherwise D should be unchanged.
(1)   16/     300 :                     ;
(1)   17/     300 :                     ;		The right hand variables with side effects in VTL-2 are :-
(1)   18/     300 :                     ;
(1)   19/     300 :                     ;		?	input an integer (technically an expression .....)
(1)   20/     300 :                     ; 		$ 	input a single character
(1)   21/     300 :                     ;
(1)   22/     300 :                     ;		This is run with P = rSpecialHandler X = 2
(1)   23/     300 :                     ;
(1)   24/     300 :                     ;		Must preserve: rSrc, rVarPtr*, rExprPC, rParenthesisLevel, rSaveStack and of course R2.
(1)   25/     300 :                     ;
(1)   26/     300 :                     ;		* can be assumed constant.
(1)   27/     300 :                     ;
(1)   28/     300 :                     ;		Use: rUtilPC, rSubPC, rParam1, rParam2.
(1)   29/     300 :                     ;
(1)   30/     300 :                     ; ***************************************************************************************************************
(1)   31/     300 :                     
(1)   32/     300 :                     __SHExit:
(1)   33/     300 : D7                  	sep 	rExprPC
(1)   34/     301 :                     SpecialHandler:
(1)   35/     301 : FB 24               	xri 	'$'															; check if '$' (get character)
(1)   36/     303 : 32 0D               	bz 		__SHGetKey
(1)   37/     305 : FB 1B               	xri 	'$'!'?'														; check if '?' (get string expression)
(1)   38/     307 : 32 1C               	bz 		__SHInput
(1)   39/     309 : FB 3F               	xri 	'?'
(1)   40/     30B : 30 00               	br 		__SHExit
(1)   41/     30D :                     
(1)   42/     30D :                     ; ***************************************************************************************************************
(1)   43/     30D :                     ;
(1)   44/     30D :                     ;							$ operator. Returns a single key press in rParam2
(1)   45/     30D :                     ;
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(handler.asm) - page 15 - 14/1/2017 18:20:18


(1)   46/     30D :                     ; ***************************************************************************************************************
(1)   47/     30D :                     
(1)   48/     30D :                     __SHGetKey:
(1)   49/     30D : (MACRO)             	lrx 	rUtilPC,XIOGetKey 											; this is the external function which reads the keyboard
(1)   49/     30D : F8 04                       ldi     (XIOGETKEY)/256
(1)   49/     30F : BC                          phi     RUTILPC
(1)   49/     310 : F8 01                       ldi     (XIOGETKEY)&255
(1)   49/     312 : AC                          plo     RUTILPC
(1)   50/     313 : 79                  	mark 																; and it is called using the MARK method. 
(1)   51/     314 : DC                  	sep 	rUtilPC
(1)   52/     315 : 22                  	dec 	r2
(1)   53/     316 : AF                  	plo 	rParam2 													; put result in rParam2.0
(1)   54/     317 : F8 00               	ldi 	0 															; clear rParam2.1 and D, indicating successful processing.
(1)   55/     319 : BF                  	phi 	rParam2
(1)   56/     31A : 30 00               	br 		__SHExit 													; and exit.
(1)   57/     31C :                     
(1)   58/     31C :                     ; ***************************************************************************************************************
(1)   59/     31C :                     ;
(1)   60/     31C :                     ;							? operator. Inputs a string, evaluates it and returns.
(1)   61/     31C :                     ;
(1)   62/     31C :                     ; ***************************************************************************************************************
(1)   63/     31C :                     
(1)   64/     31C :                     __SHInput:
(1)   65/     31C : (MACRO)             	lrx 	rSubPC,XIOWriteCharacter 									; prompt.
(1)   65/     31C : F8 04                       ldi     (XIOWRITECHARACTER)/256
(1)   65/     31E : BD                          phi     RSUBPC
(1)   65/     31F : F8 09                       ldi     (XIOWRITECHARACTER)&255
(1)   65/     321 : AD                          plo     RSUBPC
(1)   66/     322 : F8 3F               	ldi 	'?'
(1)   67/     324 : 79                  	mark
(1)   68/     325 : DD                  	sep 	rSubPC
(1)   69/     326 : 22                  	dec 	r2
(1)   70/     327 :                     
(1)   71/     327 : (MACRO)             	lrx 	rUtilPC,READLine 											; read line into input buffer.
(1)   71/     327 : F8 03                       ldi     (READLINE)/256
(1)   71/     329 : BC                          phi     RUTILPC
(1)   71/     32A : F8 3F                       ldi     (READLINE)&255
(1)   71/     32C : AC                          plo     RUTILPC
(1)   72/     32D : 79                  	mark 																; returns it in rParam1
(1)   73/     32E : DC                  	sep 	rUtilPC 
(1)   74/     32F : 22                  	dec 	r2
(1)   75/     330 :                     
(1)   76/     330 : (MACRO)             	lrx 	rUtilPC,ASCIIToInteger										; convert to number
(1)   76/     330 : F8 02                       ldi     (ASCIITOINTEGER)/256
(1)   76/     332 : BC                          phi     RUTILPC
(1)   76/     333 : F8 B0                       ldi     (ASCIITOINTEGER)&255
(1)   76/     335 : AC                          plo     RUTILPC
(1)   77/     336 : 79                  	mark 																; and do so.
(1)   78/     337 : DC                  	sep 	rUtilPC
(1)   79/     338 : 22                  	dec 	r2
(1)   80/     339 : 32 1C               	bz 		__SHInput
(1)   81/     33B :                     
(1)   82/     33B : F8 00               	ldi 	0  															; and exit with D = 0 indicating done.
(1)   83/     33D : 30 00               	br 		__SHExit 
(1)   84/     33F :                     
(1)   85/     33F :                     
      95/     33F :                     	include readline.asm 												; line input routine.
(1)    1/     33F :                     ; ***************************************************************************************************************
(1)    2/     33F :                     ; ***************************************************************************************************************
(1)    3/     33F :                     ;
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(readline.asm) - page 16 - 14/1/2017 18:20:18


(1)    4/     33F :                     ;		File:		readline.asm
(1)    5/     33F :                     ;		Purpose:	Read an input line
(1)    6/     33F :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     33F :                     ;		Date:		14th January 2017.
(1)    8/     33F :                     ;
(1)    9/     33F :                     ; ***************************************************************************************************************
(1)   10/     33F :                     ; ***************************************************************************************************************
(1)   11/     33F :                     
(1)   12/     33F :                     ; ***************************************************************************************************************
(1)   13/     33F :                     ;
(1)   14/     33F :                     ;						Read Line in from Keyboard, returns address in rParam1
(1)   15/     33F :                     ;
(1)   16/     33F :                     ; ***************************************************************************************************************
(1)   17/     33F :                     
(1)   18/     33F :                     READLine:
(1)   19/     33F : F8 7F               	ldi 	7Fh 														; set up rParam1 to point to the string.
(1)   20/     341 : AE                  	plo 	rParam1
(1)   21/     342 : 96                  	ghi 	rVarPtr
(1)   22/     343 : BE                  	phi 	rParam1
(1)   23/     344 :                     
(1)   24/     344 :                     __RLLNextCharacter:
(1)   25/     344 : 1E                  	inc 	rParam1
(1)   26/     345 :                     __RLLLoop:
(1)   27/     345 : E2                  	sex 	r2 															; use R2 as index
(1)   28/     346 : (MACRO)             	lrx 	rSubPC,XIOGetKey 											; call get key routine.
(1)   28/     346 : F8 04                       ldi     (XIOGETKEY)/256
(1)   28/     348 : BD                          phi     RSUBPC
(1)   28/     349 : F8 01                       ldi     (XIOGETKEY)&255
(1)   28/     34B : AD                          plo     RSUBPC
(1)   29/     34C : 79                  	mark 	
(1)   30/     34D : DD                  	sep 	rSubPC
(1)   31/     34E : 22                  	dec 	r2
(1)   32/     34F : 5E                  	str 	rParam1	 													; save in text buffer.
(1)   33/     350 :                     
(1)   34/     350 : (MACRO)             	lrx 	rSubPC,XIOWriteCharacter
(1)   34/     350 : F8 04                       ldi     (XIOWRITECHARACTER)/256
(1)   34/     352 : BD                          phi     RSUBPC
(1)   34/     353 : F8 09                       ldi     (XIOWRITECHARACTER)&255
(1)   34/     355 : AD                          plo     RSUBPC
(1)   35/     356 : 0E                  	ldn 	rParam1
(1)   36/     357 : 79                  	mark
(1)   37/     358 : DD                  	sep 	rSubPC
(1)   38/     359 : 22                  	dec 	r2
(1)   39/     35A :                     
(1)   40/     35A : 0E                  	ldn 	rParam1
(1)   41/     35B : FB 08               	xri 	8 															; Ctl+H
(1)   42/     35D : 32 69               	bz 		__RLLPrevCharacter 											; get previous character
(1)   43/     35F : FB 05               	xri 	13!8 														; is it CR ?
(1)   44/     361 : 3A 44               	bnz 	__RLLNextCharacter 											; no go around again
(1)   45/     363 :                     __RLLExit:
(1)   46/     363 : 5E                  	str 	rParam1 													; save the zero in rVarPtr making string ASCIIZ.
(1)   47/     364 : F8 80               	ldi 	80h 														; point rParam1 to the start of the string.
(1)   48/     366 : AE                  	plo 	rParam1
(1)   49/     367 : 12                  	inc 	r2 															; and exit.
(1)   50/     368 : (MACRO)             	return
(1)   50/     368 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)   51/     369 :                     
(1)   52/     369 :                     __RLLPrevCharacter:
(1)   53/     369 : 2E                  	dec 	rParam1 													; handle backspace (chr(8))
(1)   54/     36A : 8E                  	glo 	rParam1
 AS V1.42 Beta [Bld 114] - source file vtl2.asm(readline.asm) - page 17 - 14/1/2017 18:20:18


(1)   55/     36B : FE                  	shl
(1)   56/     36C : 33 45               	bdf 	__RLLLoop
(1)   57/     36E : 30 44               	br 		__RLLNextCharacter
(1)   58/     370 :                     
      96/     370 :                     
      97/     370 :                     	align 	256
      98/     400 :                     	include	virtualio.asm 												; I/O routines that are hardware specific.
(1)    1/     400 :                     ; ***************************************************************************************************************
(1)    2/     400 :                     ; ***************************************************************************************************************
(1)    3/     400 :                     ;
(1)    4/     400 :                     ;		File:		virtualio.asm
(1)    5/     400 :                     ;		Purpose:	Input/Output routines.
(1)    6/     400 :                     ;		Author:		Paul Robson (paul@robsons.org.uk)
(1)    7/     400 :                     ;		Date:		14th January 2017.
(1)    8/     400 :                     ;
(1)    9/     400 :                     ; ***************************************************************************************************************
(1)   10/     400 :                     ; ***************************************************************************************************************
(1)   11/     400 :                     
(1)   12/     400 :                     ; ***************************************************************************************************************
(1)   13/     400 :                     ;
(1)   14/     400 :                     ;	These routines will be entered with P = rUtilPC or P = rSubPC and should change no registers other than
(1)   15/     400 :                     ; 	D and DF. On entry R2 will point to an empty stack space.
(1)   16/     400 :                     ;
(1)   17/     400 :                     ; ***************************************************************************************************************
(1)   18/     400 :                     
(1)   19/     400 :                     ; ***************************************************************************************************************
(1)   20/     400 :                     ;
(1)   21/     400 :                     ;												Get a keystroke into D.
(1)   22/     400 :                     ;
(1)   23/     400 :                     ; ***************************************************************************************************************
(1)   24/     400 :                     
(1)   25/     400 : (MACRO)             	return
(1)   25/     400 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)   26/     401 :                     XIOGetKey:
(1)   27/     401 : E2                  	sex 	r2 															; fix up after Mark.
(1)   28/     402 : 69                  	inp 	1 															; read keyboard port
(1)   29/     403 : 32 01               	bz 		XIOGetKey 													; no key, keep trying
(1)   30/     405 : 12                  	inc 	r2 															; standard return.
(1)   31/     406 : 30 00               	br 		XIOGetKey-1
(1)   32/     408 :                     
(1)   33/     408 :                     ; ***************************************************************************************************************
(1)   34/     408 :                     ;
(1)   35/     408 :                     ;										    Write a character to the display
(1)   36/     408 :                     ;
(1)   37/     408 :                     ; ***************************************************************************************************************
(1)   38/     408 :                     
(1)   39/     408 : (MACRO)             	return
(1)   39/     408 : 71                          dis                                                                                                                             ; this program uses MARK-subroutines
(1)   40/     409 :                     XIOWriteCharacter:
(1)   41/     409 : E2                  	sex 	r2
(1)   42/     40A : 52                  	str 	r2
(1)   43/     40B : 61                  	out 	1
(1)   44/     40C : 22                  	dec 	r2
(1)   45/     40D : 12                  	inc 	r2
(1)   46/     40E : 30 08               	br 		XIOWriteCharacter-1
      99/     410 :                     
 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 18 - 14/1/2017 18:20:18


  symbol table (* = unused):
  ------------------------

*ARCHITECTURE :                                        x86_64-unknown-linux - |
 ASCIITOINTEGER :               2B0 C | *BIGENDIAN :                      0 - |
*BRANCHEXT :                      0 - | *CASESENSITIVE :                  0 - |
*CONSTPI :        3.141592653589793 - | *DATE :                   14/1/2017 - |
 DIVIDE :                       1B7 C |  ESTRING :                       41 C |
 EXPREVALUATE :                 10B C | *FALSE :                          0 - |
 FINDRAMTOP :                     F C |  FOUNDRAMTOP :                   1D C |
*FULLPMMU :                       1 - | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - | *INEXTMODE :                      0 - |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
*INTEGERTOASCII :               259 C | *LISTON :                         1 - |
*MACEXP :                         1 - | *MOMCPU :                      1802 - |
*MOMCPUNAME :                  1802 - |  MULTIPLY :                     28B C |
*NESTMAX :                      100 - | *PACKING :                        0 - |
*PADDING :                        1 - |  R0 :                             0 - |
*R1 :                             1 - |  R2 :                             2 - |
 R3 :                             3 - |  READLINE :                     33F C |
*RELAXED :                        0 - |  REXPRPC :                        7 - |
 RPARAM1 :                        E - |  RPARAM2 :                        F - |
 RPARENTHESISLEVEL :              A - |  RSAVESTACK :                     B - |
 RSPECIALHANDLER :                9 - |  RSRC :                           8 - |
 RSUBPC :                         D - |  RUTILPC :                        C - |
 RVARPTR :                        6 - |  SPECIALHANDLER :               301 C |
 START :                          8 C | *TIME :                    18:20:18 - |
*TRUE :                           1 - | *VERSION :                     142F - |
 WAIT :                          3F C |  XIOGETKEY :                    401 C |
 XIOWRITECHARACTER :            409 C |  __ATOIEXIT :                   2AD C |
 __ATOILOOP :                   2B6 C |  __DIVEXIT :                    1B5 C |
*__DIVLOOP :                    1C6 C |  __DIVLOOPINCR2 :               1C5 C |
 __DIVLOOPINCR2INCR2 :          1C4 C |  __EXPRARRAY :                  14E C |
 __EXPRDESTACKBRACKET :         19B C |  __EXPREXIT :                   101 C |
 __EXPREXITDEC :                100 C |  __EXPRFINDOPERATION :          165 C |
 __EXPRFOUNDOPERATION :         16D C |  __EXPRGOTCHARACTER :           156 C |
 __EXPRGOTTERM :                15E C |  __EXPRNEWLEVEL :               113 C |
 __EXPRNEWTERM :                11B C |  __EXPRNOTDIVIDE :              187 C |
 __EXPRSKIPSPACE :              18B C |  __ITOAEXIT :                   257 C |
 __ITOALOOP :                   25D C |  __MULDONTADD :                 29F C |
 __MULEXIT :                    286 C |  __MULLOOP :                    290 C |
 __OPADD :                      200 C |  __OPEQISTRUE :                 24F C |
 __OPEQNZ :                     24B C |  __OPEQUALITY :                 247 C |
 __OPERATORTABLE :              1A6 C |  __OPLOOKUP :                   20D C |
 __OPLT0 :                      240 C |  __OPRETURN :                   223 C |
 __OPSUB :                      226 C |  __OPWRITEBOOLEAN :             251 C |
*__RLLEXIT :                    363 C |  __RLLLOOP :                    345 C |
 __RLLNEXTCHARACTER :           344 C |  __RLLPREVCHARACTER :           369 C |
 __SHEXIT :                     300 C |  __SHGETKEY :                   30D C |
 __SHINPUT :                    31C C |

     96 symbols
     32 unused symbols

 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 19 - 14/1/2017 18:20:18


  defined macros:
  ---------------

LRX                                   | OPER                                 
RETURN                                | __ATOIDOUBLERPARAM2                  

      4 macros

 AS V1.42 Beta [Bld 114] - source file vtl2.asm - page 20 - 14/1/2017 18:20:18


  codepages:
  ----------

STANDARD (0 changed characters)


0.01 seconds assembly time

    933 lines source file
   1016 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
